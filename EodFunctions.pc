


   
   
   
   
   
   
   
   
   
   
   
   



#include "stdio_64.h" 
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>
#include <string.h>
#include <signal.h>

#include "CR_Common.h"

/* Bageshri--10GM */
#include "CO_LenConstdef.h"

/*Commented for Linux Migration
#define OS_UNIX */
#define S_PROGNAME_LENGTH 40
#define S_RESTART_DATA_LENGTH 200 
#define S_ERR_MSG_LENGTH 200
#define S_PROGSTRING_LENGTH 200

#define S_RESTART 10
#define S_START 11
#define S_CANNOT_EXECUTE 12
#define S_CONFLICT 13
#define S_PREDECESSOR 14
#define S_DATE_LENGTH 20
#define S_SLEEP_TIME 60

#define COMMIT_COUNT_E 1000

/* Added By Hardik to increase the MS_MSGENT purging for 25 to 200 */
/* changed By Ram to increase the MS_MSGENT purging for 200 to 5000 */
#define COMMITSIZE 5000

EXEC SQL INCLUDE SQLCA.H;




char chr_db_id[APL_USERID_LEN];
char chr_db_pwd[100];

static int	CO_Upd_SToNextBussDt(const	char		*p_tmp_date,
								char				*p_out_date,
								DEBUG_INFO_STRUCT_H   **l_debug_info_ptr
								)
{
	char	chr_out_date[APL_DATE_LEN]	=	APL_NULL_STRING;
	char chr_p_inp_date[APL_DATE_LEN]=APL_NULL_STRING;
	short	i_out_date	=	0;

	/*Smita - Changed Col Names - HDFCCA Base Version*/
	strcpy(chr_p_inp_date,p_tmp_date);
	sprintf(chr_p_inp_date+11,"12:00:00");
	EXEC SQL VAR chr_p_inp_date IS STRING;
	EXEC SQL select MAX(H_DATE) + 1
	into	:chr_out_date:i_out_date
	from MT_HOLIDAY
	where STATUS='AA'
	AND BANK_IND='Y'
	connect by prior H_DATE + 1 = H_DATE
				and prior STATUS = STATUS
				and prior BANK_IND = BANK_IND
	start with H_DATE=:chr_p_inp_date and STATUS='AA'
	AND BANK_IND='Y';

	IS_ANY_ORA_ERROR

	if	(i_out_date	==	-1)
	{
		strcpy(chr_out_date,chr_p_inp_date);
	}

	strcpy(p_out_date,chr_out_date);
	
		APL_GOBACK_SUCCESS
      RETURN_SUCCESS  :
      {
			return (APL_SUCCESS);
      }
      RETURN_FAILURE  :
      {
         return (APL_FAILURE);
		}
}

int CO_Pro_BatchScheduler(char *p_progname,
							 char *chr_p_key_a,
							 char *chr_l_sysdate_a,
							 char *userid,
							 char *h_mode,
							 char *processtion,
							 char *auth_req,
							 char *subprocess,
							 char *h_process,
							 char *funcparams)
{
	FILE *chr_logfile=NULL;
	FILE *chr_inifile=NULL;
	char chr_custody_id_b[APL_USERID_LEN];
	char chr_h_prog_function[APL_FUNC_NAME_LENGTH];
	char chr_h_restartdata[S_RESTART_DATA_LENGTH]; 
	short i_restartData;
	char chr_h_execit[S_PROGSTRING_LENGTH];
	int int_l_childstatus = 0;
	int int_l_canstart;
	int i;
	int int_resacl;
	int int_l_progno;
	int int_l_exitcode;
	int int_no_msgs=0;
	char *chr_sesamini;
	char chr_flag[2];
	char *argv[10];
	char chr_statinfo[100];
	char chr_sesaminidir[PATH_LENGTH];
	char chr_sesamlogdir[PATH_LENGTH];
	char chr_l_nextdate_a[APL_DATE_LEN];
	char chr_l_nextoutdate[APL_DATE_LEN];
	static int int_max_times_refire=-1;
	int    int_refire_count=0;
	int    int_refired_successfully=0;
	
	char chr_l_sysdatetime[APL_DATE_LEN]= APL_NULL_STRING;      

	
	char chr_l_msgdatadir[PATH_LENGTH]   = APL_NULL_STRING;
   char chr_errmsg[200] = APL_NULL_STRING;
	int 	int_h_count = 0;
	short	int_i_count = 0;

	
	int int_l_canstartholdg,int_l_canstartpendg,int_l_canstarttrans;
	int int_l_childstatusholdg=0,int_l_childstatuspendg=0,int_l_childstatustrans=0;
   char chr_h_msgschexe[41] = APL_NULL_STRING;
	int int_l_exitcodeholdg,int_l_exitcodependg,int_l_exitcodetrans;
	int int_pid_i_msgsch,int_pid_i_msgschholdg,int_pid_i_msgschpendg,int_pid_i_msgschtrans;
	int int_exit_sig_arr[3]={0,0,0};
	int int_pid_cnt=0,int_temppid,j;
    pid_t pid_arr[3],int_retval,retval=0;; //AIX - changes
	
	/* added for test start */
	int l_flg = 0;
		/* added for test  end*/

	/** Added by Sana for EOD Handover [start] **/
	char l_chr_eod_hndovr_flg[2];
	memset(l_chr_eod_hndovr_flg,APL_NULL_CHAR,2);
	short i_chr_eod_hndovr_flg = 0;
	/** Added by Sana for EOD Handover [end] **/

	DEBUG_INFO_STRUCT_H *l_debug_infostruct_h=NULL;   
	INTL_ENV_DATA_STRUCT_H l_intl_env_datastruct_h;
	INTL_ENV_DATA_STRUCT_H *p_intl_env_datastruct_h=&l_intl_env_datastruct_h;
	DEBUG_INFO_STRUCT_H **l_debug_info_ptr=&l_debug_infostruct_h;
	l_debug_infostruct_h=NULL;
	strcpy(l_intl_env_datastruct_h.usr,userid);
	strcpy(l_intl_env_datastruct_h.h_mode,h_mode);
	strcpy(l_intl_env_datastruct_h.processtion,processtion);
	strcpy(l_intl_env_datastruct_h.auth_req,auth_req);
	strcpy(l_intl_env_datastruct_h.subprocess,subprocess);
	strcpy(l_intl_env_datastruct_h.h_process,h_process);

	EXEC SQL VAR chr_h_restartdata IS STRING;
	EXEC SQL VAR chr_statinfo IS STRING;
	EXEC SQL VAR chr_l_nextdate_a IS STRING;
	EXEC SQL VAR chr_l_nextoutdate IS STRING;
	EXEC SQL VAR chr_flag IS STRING;
	EXEC SQL VAR chr_h_execit IS STRING;
	EXEC SQL VAR p_progname IS STRING;
	EXEC SQL VAR chr_p_key_a IS STRING;
	EXEC SQL VAR userid IS STRING; /* Bageshri--10GM */
	EXEC SQL VAR h_mode IS STRING;
	EXEC SQL VAR processtion IS STRING;
	EXEC SQL VAR auth_req IS STRING;
	EXEC SQL VAR subprocess IS STRING;
	EXEC SQL VAR h_process IS STRING;
	EXEC SQL VAR chr_db_id IS STRING;
	EXEC SQL VAR chr_db_pwd IS STRING;
	EXEC SQL VAR funcparams IS STRING;
	EXEC SQL VAR chr_h_prog_function IS STRING;
	EXEC SQL VAR chr_h_msgschexe IS STRING;


	chr_sesamini=NULL;
	chr_sesamini=getenv("INTL_ROOT_PATH");
	if(!chr_sesamini){
		fprintf(APL_OUT_FILE,"Ini dir env variable not set\n");
		exit(-1);
		}
	strcpy(chr_sesaminidir,chr_sesamini);

	chr_inifile=fopen(strcat(chr_sesaminidir,"/intl_sun.cfg"),"r");
	if(!chr_inifile) {
		fprintf(APL_OUT_FILE,"Could not open ini h_file %s\n",chr_sesaminidir);
		exit(-1);
		}


	

   if ( APL_FAILURE == CO_ReadToken(   chr_inifile,
                                       "INTL_MS_DATA_PATH",
                                       chr_l_msgdatadir,
                                       l_debug_info_ptr ))
                                       /* OPT:AIX &l_debug_info_ptr )) */
   {
      fclose(chr_inifile);
      exit(-1);
   }

	
	
APL_FETCH_DB_LOGIN_DETAILS(chr_inifile,chr_custody_id_b,chr_db_id,chr_db_pwd,APL_OUT_FILE,l_debug_info_ptr);


	EXEC SQL CONNECT :chr_db_id IDENTIFIED BY :chr_db_pwd;
	IS_ANY_ORA_ERROR
	
argv[0]=p_progname;
argv[1]=chr_p_key_a;
argv[2]=chr_l_sysdate_a;
argv[3]=userid;
argv[4]=h_mode;
argv[5]="Eod stream";
argv[6]=auth_req;
argv[7]=subprocess;
argv[8]=h_process;
argv[9]=funcparams;

   if ( CO_Rtv_RptFileName("0E",
								APL_LOGFILE_DESC,
								100,
								processtion,
								argv,
								&chr_logfile,
								l_debug_info_ptr) ==APL_FAILURE) 
	{
		exit(-1);	
	}
	EXEC SQL COMMIT;
	IS_ANY_ORA_ERROR
	fprintf(chr_logfile,"Starting chr_log for Eod");
	fprintf(chr_logfile," for chr_date %s\n",chr_l_sysdate_a);

	
	if ( CO_RtvSysParams(l_debug_info_ptr) == APL_FAILURE)
   APL_GOBACK_FAIL

	fprintf(chr_logfile,"SMI_Installed Flag is :%s\n",g_mt_commonsys_params_struct_h.ei_smi_ind);
  	fflush(chr_logfile);

	

	
	EXEC SQL SELECT PROCESSING_STATUS INTO : chr_h_restartdata :i_restartData
		FROM SYS_BATCHPROC
			WHERE PROCESS_NAME=:p_progname
			AND STARTDATE=:chr_l_sysdate_a
			AND STATUS='completed'
			AND PROC_INIT=:chr_p_key_a;

	

	if(sqlca.sqlcode!=1403) {
		EXEC SQL DELETE SYS_BATCHPROC
			WHERE PROCESS_NAME=:p_progname
			AND 	STARTDATE=:chr_l_sysdate_a
			AND	STATUS='started'
			AND 	PROC_INIT=:chr_p_key_a;

		//fprintf(chr_logfile,"Eod completed for chr_date\n",chr_l_sysdate_a); Changes done for AIX Migration
		fprintf(chr_logfile,"Eod completed for chr_date %s\n",chr_l_sysdate_a);
		fflush(chr_logfile);
		fclose(chr_logfile);
		return APL_SUCCESS;
		}
	IS_ANY_ORA_ERROR
	
	
	EXEC SQL SELECT PROCESSING_STATUS INTO : chr_h_restartdata :i_restartData
		FROM SYS_BATCHPROC
			WHERE PROCESS_NAME=:p_progname
			AND STARTDATE=:chr_l_sysdate_a
			AND STATUS='started'
			AND PROC_INIT=:chr_p_key_a
				FOR UPDATE OF STATUS,PROCESSING_STATUS;

	

	if(sqlca.sqlcode==1403){
		fprintf(chr_logfile,"Eod completed for chr_date %s\n",chr_l_sysdate_a);
		fflush(chr_logfile);
		fclose(chr_logfile);
		return APL_SUCCESS;
		}

	IS_ANY_ORA_ERROR

	/** Added by Sana for EOD Handover [start] **/
	IF_COND_EXISTS("EOD_FUNC","EOD_HNDOVR")
	{
		EXEC SQL SELECT hand_over_ind INTO :l_chr_eod_hndovr_flg:i_chr_eod_hndovr_flg
				FROM PRO_SYS_HANDOVER;
		IS_ANY_ORA_ERROR
	
		Alert("Handover flag is |%s|",l_chr_eod_hndovr_flg);
		fflush(stdout);

		if(l_chr_eod_hndovr_flg[0] != 'E')
		{
			fprintf(chr_logfile,"System Has Not Been Handed Over for EOD \n");
			fflush(chr_logfile);
			//Commented For ISKB_6165 on 19-06-2013
			//APL_GOBACK_FAIL
			APL_GOBACK_SUCCESS
		}
	}
	/** Added by Sana for EOD Handover [End] **/
		
	
	EXEC SQL SELECT EOD_IND INTO :chr_flag
		FROM PRO_SYS_DATE;
	IS_ANY_ORA_ERROR
	if((chr_flag[0]!='E')&&(chr_flag[0]!='O')) {
		fprintf(chr_logfile,"System not in Eod state\n");
		fflush(chr_logfile);
		//Commented For ISKB_6165 on 19-06-2013
		//APL_GOBACK_FAIL
		APL_GOBACK_SUCCESS
		}

	EXEC SQL	UPDATE PRO_SYS_DATE SET EOD_IND='E';
	printf("sqlca .sql code is |%d|",sqlca.sqlcode);
	IS_ANY_ORA_ERROR

	EXEC SQL COMMIT;


	printf("\n Inside EodFunctions.pc: Calling for loop now...");

	for(;;)  
	{
	
	EXEC SQL SELECT PROCESSING_STATUS INTO : chr_h_restartdata :i_restartData
		FROM SYS_BATCHPROC
			WHERE PROCESS_NAME=:p_progname
			AND STARTDATE=:chr_l_sysdate_a
			AND STATUS='completed'
			AND PROC_INIT=:chr_p_key_a;

	printf("\n Inside EodFunctions.pc: Selected record from sys_batchproc...");
	

	if(sqlca.sqlcode!=1403) {
		EXEC SQL DELETE SYS_BATCHPROC
			WHERE PROCESS_NAME=:p_progname
			AND 	STARTDATE=:chr_l_sysdate_a
			AND	STATUS='started'
			AND 	PROC_INIT=:chr_p_key_a;
		fprintf(chr_logfile,"Eod completed for chr_date %s\n",chr_l_sysdate_a);
		fflush(chr_logfile);
		fclose(chr_logfile);
		EXEC SQL COMMIT;
		return APL_SUCCESS;
		}
	IS_ANY_ORA_ERROR

	
	EXEC SQL SELECT PROCESSING_STATUS INTO : chr_h_restartdata INDICATOR :i_restartData
		FROM SYS_BATCHPROC
			WHERE PROCESS_NAME=:p_progname
			AND STARTDATE=:chr_l_sysdate_a
			AND STATUS='started'
			AND PROC_INIT=:chr_p_key_a
				FOR UPDATE OF STATUS,PROCESSING_STATUS;

	

	if(sqlca.sqlcode==1403) {
		fprintf(chr_logfile,"Eod completed for chr_date %s\n",chr_l_sysdate_a);
		fflush(chr_logfile);
		fclose(chr_logfile);
		return APL_SUCCESS;
	}
	if(i_restartData==-1)
		int_l_progno=1;
	else
		sscanf(chr_h_restartdata,"%d",&int_l_progno);

	IS_ANY_ORA_ERROR

	printf("\n Inside EodFunctions.pc: Selecting process names from bact stream...");
		EXEC SQL SELECT PROCESS_NAME,TASK_CD INTO :chr_h_execit,:chr_h_prog_function
		FROM SYS_BATCHSTREAM
			WHERE PROCESS_NO=:int_l_progno
			AND PROC_IND='E';
	
	printf("\n Inside EodFunctions.pc:  chr_h_execit is |%s|, chr_h_prog_function is  |%s| sqlca.sqlcode |%d|...",chr_h_execit,chr_h_prog_function,sqlca.sqlcode);
	if(sqlca.sqlcode==1403) 
		break;
	IS_ANY_ORA_ERROR
		fprintf(chr_logfile,"To exec %s\n",chr_h_execit);
		 
		
		memset(chr_l_sysdatetime,APL_NULL_CHAR,APL_DATE_LEN);
				if (CO_RtvSysDtTime(chr_l_sysdatetime, l_debug_info_ptr) != APL_SUCCESS)
							{APL_GOBACK_FAIL }
		
		fflush(chr_logfile);
		strcpy(p_intl_env_datastruct_h->processtion,chr_h_prog_function);		


		

		if (strcmp(chr_h_execit,S_MSG_SCH) != 0)
		{
	printf("\n Inside EodFunctions.pc: Calling CO_Pro_BatchRestartLPC with chr_h_execit|%s|, chr_p_key_a|%s| , int_l_childstatus is |%d|...",chr_h_execit,chr_p_key_a,int_l_childstatus);
			int_l_canstart=CO_Pro_BatchRestartLPC(chr_h_execit,
												chr_p_key_a,
												"",
												&int_l_childstatus,
												&int_pid_i_msgsch,
												l_debug_info_ptr,
												p_intl_env_datastruct_h);
	printf("\n Inside EodFunctions.pc: After Calling CO_Pro_BatchRestartLPC int_l_canstart=|%d|..int_l_childstatus=|%d|",int_l_canstart,int_l_childstatus);
			if(int_l_canstart==APL_FAILURE) {
				fprintf(chr_logfile,"Cannot initiate execution of %s\n",chr_h_execit);
				APL_GOBACK_FAIL
				}
		}
		else		
		{
			int_l_canstartholdg=CO_Pro_BatchRestartLPC(S_MSG_SCH_HOLDG,
												chr_p_key_a,
												"",
												&int_l_childstatusholdg,
												&int_pid_i_msgschholdg,
												l_debug_info_ptr,
												p_intl_env_datastruct_h);
			if(int_l_canstartholdg == APL_FAILURE) 
			{
				fprintf(chr_logfile,"Cannot initiate execution of %s\n",S_MSG_SCH_HOLDG);
				APL_GOBACK_FAIL
			}

			int_l_canstartpendg=CO_Pro_BatchRestartLPC(S_MSG_SCH_PENDG,
												chr_p_key_a,
												"",
												&int_l_childstatuspendg,
												&int_pid_i_msgschpendg,
												l_debug_info_ptr,
												p_intl_env_datastruct_h);
			if(int_l_canstartpendg == APL_FAILURE) 
			{
				fprintf(chr_logfile,"Cannot initiate execution of %s\n",S_MSG_SCH_PENDG);
				APL_GOBACK_FAIL
			}

			int_l_canstarttrans=CO_Pro_BatchRestartLPC(S_MSG_SCH_TRANS,
												chr_p_key_a,
												"",
												&int_l_childstatustrans,
												&int_pid_i_msgschtrans,
												l_debug_info_ptr,
												p_intl_env_datastruct_h);
			if(int_l_canstarttrans == APL_FAILURE) 
			{
				fprintf(chr_logfile,"Cannot initiate execution of %s\n",S_MSG_SCH_TRANS);
				APL_GOBACK_FAIL
			}
		}

		 

		

		if (strcmp(chr_h_execit,S_MSG_SCH) != 0)
		{
			printf("\n Inside EodFunctions.pc: switching for int_l_childstatus =|%d|..",int_l_childstatus);
			switch(int_l_childstatus){
			case S_RESTART:fprintf(chr_logfile,"The Process %s restarted at time : %s \n",chr_h_execit,chr_l_sysdatetime);
			printf("Inside EodFunctions.pc: The Process %s restarted at time : %s \n",chr_h_execit,chr_l_sysdatetime);
								break;
			case S_START:  fprintf(chr_logfile,"The Process %s started at time : %s \n",chr_h_execit,chr_l_sysdatetime);
			printf("Inside EodFunctions.pc: The Process %s started at time : %s \n",chr_h_execit,chr_l_sysdatetime);
								break;
			case S_CONFLICT:fprintf(chr_logfile,"MISMATCH with %s detected\n",chr_h_execit);	
			printf("Inside EodFunctions.pc: MISMATCH with %s detected\n",chr_h_execit);	
								APL_GOBACK_FAIL
			case S_PREDECESSOR:fprintf(chr_logfile,"PRE_PROCESS problem with %s\n",chr_h_execit);
			printf("Inside EodFunctions.pc: PRE_PROCESS problem with %s\n",chr_h_execit);
								APL_GOBACK_FAIL
			case S_CANNOT_EXECUTE:fprintf(chr_logfile,"A copy of %s running\n",chr_h_execit);
			printf("Inside EodFunctions.pc: A copy of %s running\n",chr_h_execit);
								APL_GOBACK_FAIL
			}
		}
		else
		{
			switch(int_l_childstatusholdg)
			{
				case S_RESTART:fprintf(chr_logfile,"The Process %s restarted at time : %s \n",S_MSG_SCH_HOLDG,chr_l_sysdatetime);
									break;
				case S_START:  fprintf(chr_logfile,"The Process %s started at time : %s \n",S_MSG_SCH_HOLDG,chr_l_sysdatetime);
									break;
				case S_CONFLICT:fprintf(chr_logfile,"Conflict with %s detected\n",S_MSG_SCH_HOLDG);	
									APL_GOBACK_FAIL
				case S_PREDECESSOR:fprintf(chr_logfile,"Predecessor problem with %s\n",S_MSG_SCH_HOLDG);
									APL_GOBACK_FAIL
				case S_CANNOT_EXECUTE:fprintf(chr_logfile,"A copy of %s running\n",S_MSG_SCH_HOLDG);
									APL_GOBACK_FAIL
			}

			switch(int_l_childstatuspendg)
			{
				case S_RESTART:fprintf(chr_logfile,"The Process %s restarted at time : %s \n",S_MSG_SCH_PENDG,chr_l_sysdatetime);
									break;
				case S_START:  fprintf(chr_logfile,"The Process %s started at time : %s \n",S_MSG_SCH_PENDG,chr_l_sysdatetime);
									break;
				case S_CONFLICT:fprintf(chr_logfile,"Conflict with %s detected\n",S_MSG_SCH_PENDG);	
									APL_GOBACK_FAIL
				case S_PREDECESSOR:fprintf(chr_logfile,"Predecessor problem with %s\n",S_MSG_SCH_PENDG);
									APL_GOBACK_FAIL
				case S_CANNOT_EXECUTE:fprintf(chr_logfile,"A copy of %s running\n",S_MSG_SCH_PENDG);
									APL_GOBACK_FAIL
			}

			switch(int_l_childstatustrans)
			{
				case S_RESTART:fprintf(chr_logfile,"The Process %s restarted at time : %s \n",S_MSG_SCH_TRANS,chr_l_sysdatetime);
									break;
				case S_START:  fprintf(chr_logfile,"The Process %s started at time : %s \n",S_MSG_SCH_TRANS,chr_l_sysdatetime);
									break;
				case S_CONFLICT:fprintf(chr_logfile,"Conflict with %s detected\n",S_MSG_SCH_TRANS);	
									APL_GOBACK_FAIL
				case S_PREDECESSOR:fprintf(chr_logfile,"Predecessor problem with %s\n",S_MSG_SCH_TRANS);
									APL_GOBACK_FAIL
				case S_CANNOT_EXECUTE:fprintf(chr_logfile,"A copy of %s running\n",S_MSG_SCH_TRANS);
									APL_GOBACK_FAIL
			}
		}


		


      EXEC SQL SELECT PROCESSING_STATUS INTO : chr_h_restartdata INDICATOR :i_restartData
      FROM SYS_BATCHPROC
	   WHERE PROCESS_NAME=:p_progname
      AND STARTDATE=:chr_l_sysdate_a
	   AND STATUS='started'
	   AND PROC_INIT=:chr_p_key_a
	   FOR UPDATE OF STATUS,PROCESSING_STATUS;


		
		if (strcmp(chr_h_execit,S_MSG_SCH) != 0)
		{
			printf("\n Inside EodFunctions.pc: waiting...");
			printf("\n Now going to wait for PID = |%d| ERRNO = |%d| ",int_pid_i_msgsch,errno);
			/** while((wait(&int_l_childstatus)==-1) && (errno==EINTR)); **/
			/*while((waitpid(int_pid_i_msgsch,&int_l_childstatus,WNOHANG)==-1) && (errno==EINTR)) ; 
			printf("\n Inside EodFunctions.pc: Done with waiting...");*/
			errno=-1;
			/*
				    while(
			(
			((retval=waitpid(int_pid_i_msgsch,&int_l_childstatus,WNOHANG))==-1)||
			((retval=waitpid(int_pid_i_msgsch,&int_l_childstatus,WNOHANG))==0))
			 && (errno==EINTR)) ; 
			*/
			/*** SUBU - Change for AIX Migration
			What was happeniong was that waitpid was returning with status 0 and WIFSIGNALED true but teh signal value
			(WTERMSIG) was coming as 0
			Earlier handled this by signal(SIGCHLD, SIG_DFL)
			in BatchRestartLPC.pc
			But since the problem is recurring, handling case of signal 0 specifically
			***/
			 while(
			((waitpid(int_pid_i_msgsch,&int_l_childstatus,WNOHANG)==-1) && (errno==EINTR)) 
			||
			((waitpid(int_pid_i_msgsch,&int_l_childstatus,WNOHANG)==0) &&  (WIFSIGNALED(int_l_childstatus)==1) && (WTERMSIG(int_l_childstatus)==0))
			);

			printf("\n Inside EodFunctions.pc: Done with waiting... pid <%d> retval <%d> int_l_childstatus <%d> WIF <%d> WIS<%d> WT<%d> errno <%d>\n",
			int_pid_i_msgsch, retval, int_l_childstatus, WIFEXITED(int_l_childstatus),WIFSIGNALED(int_l_childstatus), WTERMSIG(int_l_childstatus),errno);
			fprintf(chr_logfile,"\n Inside EodFunctions.pc: Done with waiting... pid <%d> retval <%d> int_l_childstatus <%d> WIF <%d> WIS<%d> WT<%d> errno <%d>\n",
			int_pid_i_msgsch, retval,int_l_childstatus, WIFEXITED(int_l_childstatus),WIFSIGNALED(int_l_childstatus), WTERMSIG(int_l_childstatus),errno);
			fflush(stdout);
                        fflush(chr_logfile);
		}
		else
		{
			pid_arr[0]=int_pid_i_msgschholdg;
			pid_arr[1]=int_pid_i_msgschpendg;
			pid_arr[2]=int_pid_i_msgschtrans;



			while(1)
			{
				sleep(2);
				if(++int_pid_cnt==3)
				{
					int_pid_cnt=0;
					int_temppid=pid_arr[0];
					pid_arr[0]=pid_arr[1];
					pid_arr[1]=pid_arr[2];
					pid_arr[2]=int_temppid;
				}



				int_retval = waitpid(pid_arr[int_pid_cnt],&int_l_childstatus,WNOHANG);


            if ((int_retval <= 0) && (errno==EINTR))
					continue;



				memset(chr_h_msgschexe,APL_NULL_CHAR,40);
				if (pid_arr[int_pid_cnt] == int_pid_i_msgschholdg)
					strcpy(chr_h_msgschexe,S_MSG_SCH_HOLDG);
				else if (pid_arr[int_pid_cnt] == int_pid_i_msgschpendg)
					strcpy(chr_h_msgschexe,S_MSG_SCH_PENDG);
				else if (pid_arr[int_pid_cnt] == int_pid_i_msgschtrans)
					strcpy(chr_h_msgschexe,S_MSG_SCH_TRANS);

				if (  WIFEXITED(int_l_childstatus) != 0  )
				{
					printf("pid %d exitted \n",pid_arr[int_pid_cnt]);
					int_l_exitcode=WEXITSTATUS(int_l_childstatus);
					if(int_l_exitcode!=0)
					{
						fprintf(chr_logfile,"pid %d exitted with failure\n",
																		pid_arr[int_pid_cnt]);
						for(j=0;j<=2;j++)
							if(!int_exit_sig_arr[j])
							{
								
								fprintf(chr_logfile,"Killing process %d\n",pid_arr[j]);
								kill(pid_arr[j],9);
							}
						
						EXEC SQL UPDATE SYS_BATCHPROC
						SET PROC_ENDFLG='Y'
						WHERE PROCESS_NAME IN ('MS_SCHHoldg','MS_SCHPendg',
												'MS_SCHTrans')
						AND 	STATUS='started'
						AND TO_CHAR(TO_DATE(STARTDATE),'ddmmyy')=
													TO_CHAR(TO_DATE(:chr_l_sysdate_a),'ddmmyy')
						AND	PROC_INIT=:chr_p_key_a;
						IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,
																		  "BATCH_IN_PROC",
																		  chr_h_msgschexe,
																		  chr_p_key_a)

						EXEC SQL COMMIT;
						IS_ANY_ORA_ERROR
						fprintf(chr_logfile,"Rolling back: Program %s exitted with exit status_ind %d\n",chr_h_msgschexe,int_l_exitcode);
						APL_GOBACK_FAIL
					}
					else
					{
						if(pid_arr[int_pid_cnt] == int_pid_i_msgschholdg) int_exit_sig_arr[0]=1;
						if(pid_arr[int_pid_cnt] == int_pid_i_msgschpendg) int_exit_sig_arr[1]=1;
						if(pid_arr[int_pid_cnt] == int_pid_i_msgschtrans) int_exit_sig_arr[2]=1;
					}
				}
				if (  WIFSIGNALED(int_l_childstatus)  )
				{
					if(pid_arr[int_pid_cnt] == int_pid_i_msgschholdg)
					{
						int_exit_sig_arr[0]=2;
						int_l_childstatusholdg = int_l_childstatus;
						printf("Process %d signalled\n",pid_arr[int_pid_cnt]);
					}
					if(pid_arr[int_pid_cnt] == int_pid_i_msgschpendg)
					{
						int_exit_sig_arr[1]=2;
						int_l_childstatuspendg = int_l_childstatus;
						printf("Process %d signalled\n",pid_arr[int_pid_cnt]);
					}
					if(pid_arr[int_pid_cnt] == int_pid_i_msgschtrans)
					{
						int_exit_sig_arr[2]=2;
						int_l_childstatustrans = int_l_childstatus;
						printf("Process %d signalled\n",pid_arr[int_pid_cnt]);
					}
				}

				
				if ( 	((int_exit_sig_arr[0] == 1) ||
									(int_exit_sig_arr[0] == 2)) &&
						((int_exit_sig_arr[1] == 1) ||
									(int_exit_sig_arr[1] == 2)) &&
						((int_exit_sig_arr[2] == 1) ||
									(int_exit_sig_arr[2] == 2)) )
					break;
			}
		}

	

		if (strcmp(chr_h_execit,S_MSG_SCH) != 0)
		{
			printf("\n Inside EodFunctions.pc: Checking WIFEXITED...");
			fflush(stdout);
			if(WIFEXITED(int_l_childstatus)) {
			printf("\n Inside EodFunctions.pc: Inside WIFEXITED...");
			fflush(stdout);
				int_l_exitcode=WEXITSTATUS(int_l_childstatus);
				printf("\n Inside EODFincution : Exit status = |%d| \n",int_l_exitcode);
				if(int_l_exitcode!=0){                                
			printf("\n Inside EodFunctions.pc: Inside exitcode...");
			fflush(stdout);
					
					EXEC SQL UPDATE SYS_BATCHPROC
						SET PROC_ENDFLG='Y'
							WHERE PROCESS_NAME=:chr_h_execit
							AND 	STATUS='started'
							AND TO_CHAR(TO_DATE(STARTDATE),'ddmmyy')=TO_CHAR(TO_DATE(:chr_l_sysdate_a),'ddmmyy')
							AND	PROC_INIT=:chr_p_key_a;
					IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,
																	  "BATCH_IN_PROC",
																	  chr_h_execit,
																	  chr_p_key_a)

					EXEC SQL COMMIT;
					IS_ANY_ORA_ERROR
					fprintf(chr_logfile,"Rolling back: Program %s exitted with exit status_ind %d\n",chr_h_execit,int_l_exitcode);
					APL_GOBACK_FAIL
				}
			}
                        /*Linux Fix -kotubabu Start			
			if(WIFSIGNALED(int_l_childstatus)) {
			printf("\n Inside EodFunctions.pc: Inside WIFSIGNALED...");
					
			
			if ( int_max_times_refire == -1 )
			{
				EXEC SQL SELECT to_number(FIELD_VAL)
				INTO :int_max_times_refire
				FROM PRO_GSSPLVAL
				WHERE MAIN_FUN='REFIRE_COUNT'
				and	SUB_PROCESS='EOD'
				and NATION=:g_mt_commonsys_params_struct_h.nation_code;
			
				IS_ANY_ORA_ERROR

				if ( APL_ZERO_RESULT_SET)
				{
				
					EXEC SQL SELECT to_number(FIELD_VAL)
					INTO :int_max_times_refire
					FROM PRO_GSSPLVAL
					WHERE MAIN_FUN='REFIRE_COUNT'
					and   SUB_PROCESS='EOD'
					and NATION='XX';

					IS_ANY_ORA_ERROR
					if (APL_ZERO_RESULT_SET)
					{	

						int_max_times_refire=0; 
						fprintf(chr_logfile,"REFIRE COUNT not set in GSSPLVAL.Default Value of 0 Taken and Aborted Program not refired\n");
					}
				}	
			}
			
			 
			for(int_refire_count = 0 ;int_refire_count<int_max_times_refire;)
			{	
				fprintf(chr_logfile,"Process %s signalled by signal %d\n",chr_h_execit,WTERMSIG(int_l_childstatus));
				fprintf(chr_logfile,"Sleeping for one minute and then refiring\n");
				sleep(S_SLEEP_TIME);
			fprintf(chr_logfile,"To exec %s for the %d time\n",chr_h_execit,int_refire_count+2);
			
			fflush(chr_logfile);
			strcpy(p_intl_env_datastruct_h->processtion,chr_h_prog_function);		
		
			
			int_l_canstart=CO_Pro_BatchRestartLPC(chr_h_execit,
												chr_p_key_a,
												"",
												&int_l_childstatus,
												&int_pid_i_msgsch,
												l_debug_info_ptr,
												p_intl_env_datastruct_h);
			if(int_l_canstart==APL_FAILURE) {
				fprintf(chr_logfile,"Cannot initiate execution of %s\n",chr_h_execit);
				APL_GOBACK_FAIL
				}*/

			
			/* while((wait(&int_l_childstatus)==-1) && (errno==EINTR));  */
			/*while((waitpid(int_pid_i_msgsch,&int_l_childstatus,WNOHANG)==-1) && (errno==EINTR)) ; 

			
			if(WIFEXITED(int_l_childstatus)) {
				int_l_exitcode=WEXITSTATUS(int_l_childstatus);
				if(int_l_exitcode!=0){
				
						EXEC SQL UPDATE SYS_BATCHPROC
						SET PROC_ENDFLG='Y'
							WHERE PROCESS_NAME=:chr_h_execit
							AND 	STATUS='started'
							AND TO_CHAR(TO_DATE(STARTDATE),'ddmmyy')=TO_CHAR(TO_DATE(:chr_l_sysdate_a),'ddmmyy')
							AND	PROC_INIT=:chr_p_key_a;
					IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,
																	  "BATCH_IN_PROC",
																	  chr_h_execit,
																	  chr_p_key_a)

					EXEC SQL COMMIT;
					IS_ANY_ORA_ERROR
					fprintf(chr_logfile,"Rolling back: Program %s exitted with exit status_ind %d\n",chr_h_execit,int_l_exitcode);
					APL_GOBACK_FAIL
				} 
				else
				{
					int_refired_successfully=1;
					int_refire_count = int_max_times_refire;
				}
			}
			
			
			else if(WIFSIGNALED(int_l_childstatus)) 
				{
					int_refire_count++;
				}
			
			
			
				else
				{
					int_refired_successfully = 1;
					int_refire_count = int_max_times_refire;
				}	
		
			}

			
				
			if ( int_refired_successfully == 0 )
			{
			
			
					
					EXEC SQL UPDATE SYS_BATCHPROC
						SET PROC_ENDFLG='Y'
							WHERE PROCESS_NAME=:chr_h_execit
							AND 	STATUS='started'
							AND TO_CHAR(TO_DATE(STARTDATE),'ddmmyy')=TO_CHAR(TO_DATE(:chr_l_sysdate_a),'ddmmyy')
							AND	PROC_INIT=:chr_p_key_a;
					IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,
																	  "BATCH_IN_PROC",
																	  chr_h_execit,
																	  chr_p_key_a)
				EXEC SQL COMMIT;
				IS_ANY_ORA_ERROR
				fprintf(chr_logfile,"Rolling back: Process %s signalled by signal %d",chr_h_execit,WTERMSIG(int_l_childstatus));
				APL_GOBACK_FAIL
			}

		} Linux fix kotubabu-End*/

	}
	else 
	{
                /*Cib_TechUpgrade fix kotubabu-Start
		memset(chr_h_msgschexe,APL_NULL_CHAR,40);




		if(int_exit_sig_arr[0] == 2)
		{
         printf("SIG int_l_childstatusholdg = %d\n",int_l_childstatusholdg);

			
			if ( int_max_times_refire == -1 )
			{
				EXEC SQL SELECT to_number(FIELD_VAL)
				INTO :int_max_times_refire
				FROM PRO_GSSPLVAL
				WHERE MAIN_FUN='REFIRE_COUNT'
				and	SUB_PROCESS='EOD'
				and NATION=:g_mt_commonsys_params_struct_h.nation_code;
			
				IS_ANY_ORA_ERROR

				if ( APL_ZERO_RESULT_SET)
				{
					EXEC SQL SELECT to_number(FIELD_VAL)
					INTO :int_max_times_refire
					FROM PRO_GSSPLVAL
					WHERE MAIN_FUN='REFIRE_COUNT'
					and   SUB_PROCESS='EOD'
					and NATION='XX';

					IS_ANY_ORA_ERROR
					if (APL_ZERO_RESULT_SET)
					{	
						int_max_times_refire=0; 
						fprintf(chr_logfile,"REFIRE COUNT not set in GSSPLVAL.Default Value of 0 Taken and Aborted Program not refired\n");
					}
				}	
			}
			
			 
			for(int_refire_count = 0 ;int_refire_count<int_max_times_refire;)
			{
				fprintf(chr_logfile,"Process %s signalled by signal %d\n",
											S_MSG_SCH_HOLDG,WTERMSIG(int_l_childstatusholdg));
				fprintf(chr_logfile,"Sleeping for one minute and then refiring\n");
				sleep(S_SLEEP_TIME);
				fprintf(chr_logfile,"To exec %s for the %d time\n",S_MSG_SCH_HOLDG,int_refire_count+2);
				
				fflush(chr_logfile);
				strcpy(p_intl_env_datastruct_h->processtion,chr_h_prog_function);		
			
				strcpy(chr_h_msgschexe,S_MSG_SCH_HOLDG);

				
				int_l_canstart=CO_Pro_BatchRestartLPC(S_MSG_SCH_HOLDG,
													chr_p_key_a,
													"",
													&int_l_childstatusholdg,
													&int_pid_i_msgschholdg,
													l_debug_info_ptr,
													p_intl_env_datastruct_h);
				if(int_l_canstart==APL_FAILURE) {
					fprintf(chr_logfile,"Cannot initiate execution of %s\n",S_MSG_SCH_HOLDG);
					APL_GOBACK_FAIL
					}*/

				
		/*		while((wait(&int_l_childstatusholdg)==-1) && (errno==EINTR));  */
			/*while((waitpid(int_pid_i_msgsch,&int_l_childstatus,WNOHANG)==-1) && (errno==EINTR)) ; 

				
				if(WIFEXITED(int_l_childstatusholdg)) {
				int_l_exitcode=WEXITSTATUS(int_l_childstatusholdg);
				if(int_l_exitcode!=0){
				
						EXEC SQL UPDATE SYS_BATCHPROC
						SET PROC_ENDFLG='Y'
							WHERE PROCESS_NAME=:chr_h_msgschexe
							AND 	STATUS='started'
							AND TO_CHAR(TO_DATE(STARTDATE),'ddmmyy')=TO_CHAR(TO_DATE(:chr_l_sysdate_a),'ddmmyy')
							AND	PROC_INIT=:chr_p_key_a;
					IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,
																	  "BATCH_IN_PROC",
																	  S_MSG_SCH_HOLDG,
																	  chr_p_key_a)

					EXEC SQL COMMIT;
					IS_ANY_ORA_ERROR
					fprintf(chr_logfile,"Rolling back: Program %s exitted with exit status_ind %d\n",
																S_MSG_SCH_HOLDG,int_l_exitcode);
					APL_GOBACK_FAIL
				} 
				else
				{
					int_refired_successfully=1;
					int_refire_count = int_max_times_refire;
				}
			}
			
			
			else if(WIFSIGNALED(int_l_childstatusholdg)) 
			{
				int_refire_count++;
			}
			
			
			
				else
				{
					int_refired_successfully = 1;
					int_refire_count = int_max_times_refire;
				}	
		
			}
			
				
			if ( int_refired_successfully == 0 )
			{
			
			
					
					EXEC SQL UPDATE SYS_BATCHPROC
						SET PROC_ENDFLG='Y'
							WHERE PROCESS_NAME=:chr_h_msgschexe
							AND 	STATUS='started'
							AND TO_CHAR(TO_DATE(STARTDATE),'ddmmyy')=TO_CHAR(TO_DATE(:chr_l_sysdate_a),'ddmmyy')
							AND	PROC_INIT=:chr_p_key_a;
					IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,
																	  "BATCH_IN_PROC",
																	  S_MSG_SCH_HOLDG,
																	  chr_p_key_a)
				EXEC SQL COMMIT;
				IS_ANY_ORA_ERROR
				fprintf(chr_logfile,"Rolling back: Process %s signalled by signal %d",
																		chr_h_msgschexe,WTERMSIG(int_l_childstatusholdg));
				APL_GOBACK_FAIL
			}
		}
		if(int_exit_sig_arr[1] == 2)
		{
			
			if ( int_max_times_refire == -1 )
			{
				EXEC SQL SELECT to_number(FIELD_VAL)
				INTO :int_max_times_refire
				FROM PRO_GSSPLVAL
				WHERE MAIN_FUN='REFIRE_COUNT'
				and	SUB_PROCESS='EOD'
				and NATION=:g_mt_commonsys_params_struct_h.nation_code;
			
				IS_ANY_ORA_ERROR

				if ( APL_ZERO_RESULT_SET)
				{
					EXEC SQL SELECT to_number(FIELD_VAL)
					INTO :int_max_times_refire
					FROM PRO_GSSPLVAL
					WHERE MAIN_FUN='REFIRE_COUNT'
					and   SUB_PROCESS='EOD'
					and NATION='XX';

					IS_ANY_ORA_ERROR
					if (APL_ZERO_RESULT_SET)
					{	
						int_max_times_refire=0; 
						fprintf(chr_logfile,"REFIRE COUNT not set in GSSPLVAL.Default Value of 0 Taken and Aborted Program not refired\n");
					}
				}	
			}
			
			 
			for(int_refire_count = 0 ;int_refire_count<int_max_times_refire;)
			{	
				fprintf(chr_logfile,"Process %s signalled by signal %d\n",
											S_MSG_SCH_PENDG,WTERMSIG(int_l_childstatuspendg));
				fprintf(chr_logfile,"Sleeping for one minute and then refiring\n");
				sleep(S_SLEEP_TIME);
				fprintf(chr_logfile,"To exec %s for the %d time\n",S_MSG_SCH_PENDG,int_refire_count+2);
				
				fflush(chr_logfile);
				strcpy(p_intl_env_datastruct_h->processtion,chr_h_prog_function);		
			
				strcpy(chr_h_msgschexe,S_MSG_SCH_PENDG);

				
				int_l_canstart=CO_Pro_BatchRestartLPC(S_MSG_SCH_PENDG,
													chr_p_key_a,
													"",
													&int_l_childstatuspendg,
													&int_pid_i_msgschpendg,
													l_debug_info_ptr,
													p_intl_env_datastruct_h);
				if(int_l_canstart==APL_FAILURE) {
					fprintf(chr_logfile,"Cannot initiate execution of %s\n",S_MSG_SCH_PENDG);
					APL_GOBACK_FAIL
					}*/

				
		/*		while((wait(&int_l_childstatuspendg)==-1) && (errno==EINTR)); */
			/*while((waitpid(int_pid_i_msgsch,&int_l_childstatus,WNOHANG)==-1) && (errno==EINTR)) ; 

				
				if(WIFEXITED(int_l_childstatuspendg)) {
				int_l_exitcode=WEXITSTATUS(int_l_childstatuspendg);
				if(int_l_exitcode!=0){
				
						EXEC SQL UPDATE SYS_BATCHPROC
						SET PROC_ENDFLG='Y'
							WHERE PROCESS_NAME=:chr_h_msgschexe
							AND 	STATUS='started'
							AND TO_CHAR(TO_DATE(STARTDATE),'ddmmyy')=TO_CHAR(TO_DATE(:chr_l_sysdate_a),'ddmmyy')
							AND	PROC_INIT=:chr_p_key_a;
					IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,
																	  "BATCH_IN_PROC",
																	  S_MSG_SCH_PENDG,
																	  chr_p_key_a)

					EXEC SQL COMMIT;
					IS_ANY_ORA_ERROR
					fprintf(chr_logfile,"Rolling back: Program %s exitted with exit status_ind %d\n",
																S_MSG_SCH_PENDG,int_l_exitcode);
					APL_GOBACK_FAIL
				} 
				else
				{
					int_refired_successfully=1;
					int_refire_count = int_max_times_refire;
				}
			}
			
			
			else if(WIFSIGNALED(int_l_childstatuspendg)) 
			{
				int_refire_count++;
			}
			
			
			
				else
				{
					int_refired_successfully = 1;
					int_refire_count = int_max_times_refire;
				}	
		
			}
			
				
			if ( int_refired_successfully == 0 )
			{
			
			
					
					EXEC SQL UPDATE SYS_BATCHPROC
						SET PROC_ENDFLG='Y'
							WHERE PROCESS_NAME=:chr_h_msgschexe
							AND 	STATUS='started'
							AND TO_CHAR(TO_DATE(STARTDATE),'ddmmyy')=TO_CHAR(TO_DATE(:chr_l_sysdate_a),'ddmmyy')
							AND	PROC_INIT=:chr_p_key_a;
					IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,
																	  "BATCH_IN_PROC",
																	  S_MSG_SCH_PENDG,
																	  chr_p_key_a)
				EXEC SQL COMMIT;
				IS_ANY_ORA_ERROR
				fprintf(chr_logfile,"Rolling back: Process %s signalled by signal %d",
																		chr_h_msgschexe,WTERMSIG(int_l_childstatuspendg));
				APL_GOBACK_FAIL
			}
		}
		if(int_exit_sig_arr[2] == 2)
		{
			
			if ( int_max_times_refire == -1 )
			{
				EXEC SQL SELECT to_number(FIELD_VAL)
				INTO :int_max_times_refire
				FROM PRO_GSSPLVAL
				WHERE MAIN_FUN='REFIRE_COUNT'
				and	SUB_PROCESS='EOD'
				and NATION=:g_mt_commonsys_params_struct_h.nation_code;
			
				IS_ANY_ORA_ERROR

				if ( APL_ZERO_RESULT_SET)
				{
					EXEC SQL SELECT to_number(FIELD_VAL)
					INTO :int_max_times_refire
					FROM PRO_GSSPLVAL
					WHERE MAIN_FUN='REFIRE_COUNT'
					and   SUB_PROCESS='EOD'
					and NATION='XX';

					IS_ANY_ORA_ERROR
					if (APL_ZERO_RESULT_SET)
					{	
						int_max_times_refire=0; 
						fprintf(chr_logfile,"REFIRE COUNT not set in GSSPLVAL.Default Value of 0 Taken and Aborted Program not refired\n");
					}
				}	
			}
			
			 
			for(int_refire_count = 0 ;int_refire_count<int_max_times_refire;)
			{	
				fprintf(chr_logfile,"Process %s signalled by signal %d\n",
											S_MSG_SCH_TRANS,WTERMSIG(int_l_childstatustrans));
				fprintf(chr_logfile,"Sleeping for one minute and then refiring\n");
				sleep(S_SLEEP_TIME);
				fprintf(chr_logfile,"To exec %s for the %d time\n",S_MSG_SCH_TRANS,int_refire_count+2);
				
				fflush(chr_logfile);
				strcpy(p_intl_env_datastruct_h->processtion,chr_h_prog_function);		
			
				strcpy(chr_h_msgschexe,S_MSG_SCH_TRANS);

				
				int_l_canstart=CO_Pro_BatchRestartLPC(S_MSG_SCH_TRANS,
													chr_p_key_a,
													"",
													&int_l_childstatustrans,
													&int_pid_i_msgschtrans,
													l_debug_info_ptr,
													p_intl_env_datastruct_h);
				if(int_l_canstart==APL_FAILURE) {
					fprintf(chr_logfile,"Cannot initiate execution of %s\n",S_MSG_SCH_TRANS);
					APL_GOBACK_FAIL
					}*/

				
		/*		while((wait(&int_l_childstatustrans)==-1) && (errno==EINTR));  */
			/*while((waitpid(int_pid_i_msgsch,&int_l_childstatus,WNOHANG)==-1) && (errno==EINTR)) ; 

				
				if(WIFEXITED(int_l_childstatustrans)) {
				int_l_exitcode=WEXITSTATUS(int_l_childstatustrans);
				if(int_l_exitcode!=0){
				
						EXEC SQL UPDATE SYS_BATCHPROC
						SET PROC_ENDFLG='Y'
							WHERE PROCESS_NAME=:chr_h_msgschexe
							AND 	STATUS='started'
							AND TO_CHAR(TO_DATE(STARTDATE),'ddmmyy')=TO_CHAR(TO_DATE(:chr_l_sysdate_a),'ddmmyy')
							AND	PROC_INIT=:chr_p_key_a;
					IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,
																	  "BATCH_IN_PROC",
																	  S_MSG_SCH_TRANS,
																	  chr_p_key_a)

					EXEC SQL COMMIT;
					IS_ANY_ORA_ERROR
					fprintf(chr_logfile,"Rolling back: Program %s exitted with exit status_ind %d\n",
																S_MSG_SCH_TRANS,int_l_exitcode);
					APL_GOBACK_FAIL
				} 
				else
				{
					int_refired_successfully=1;
					int_refire_count = int_max_times_refire;
				}
			}
			
			
			else if(WIFSIGNALED(int_l_childstatustrans)) 
			{
				int_refire_count++;
			}
			
			
			
				else
				{
					int_refired_successfully = 1;
					int_refire_count = int_max_times_refire;
				}	
		
			}
			
				
			if ( int_refired_successfully == 0 )
			{
			
			
					
					EXEC SQL UPDATE SYS_BATCHPROC
						SET PROC_ENDFLG='Y'
							WHERE PROCESS_NAME=:chr_h_msgschexe
							AND 	STATUS='started'
							AND TO_CHAR(TO_DATE(STARTDATE),'ddmmyy')=TO_CHAR(TO_DATE(:chr_l_sysdate_a),'ddmmyy')
							AND	PROC_INIT=:chr_p_key_a;
					IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,
																	  "BATCH_IN_PROC",
																	  S_MSG_SCH_TRANS,
																	  chr_p_key_a)
				EXEC SQL COMMIT;
				IS_ANY_ORA_ERROR
				fprintf(chr_logfile,"Rolling back: Process %s signalled by signal %d",
																		chr_h_msgschexe,WTERMSIG(int_l_childstatustrans));
				APL_GOBACK_FAIL
			}
		}
        Cib_TechUpgrade fix kotubabu-End*/
	} 

	int_l_progno++;

 

	sprintf(chr_h_restartdata,"%d",int_l_progno);
	sprintf(chr_statinfo,"Executed %s",chr_h_execit);
	EXEC SQL UPDATE SYS_BATCHPROC
		SET PROCESSING_STATUS=:chr_h_restartdata,
			 STAT_DET=:chr_statinfo
			WHERE PROCESS_NAME=:p_progname
			AND	PROC_INIT=:chr_p_key_a
			AND	STATUS='started'
			AND   STARTDATE=:chr_l_sysdate_a;
	IS_ANY_ORA_ERROR
	fprintf(chr_logfile,"Commiting : Program %s exitted with exit status_ind %d\n",chr_h_execit,int_l_exitcode);
		fflush(chr_logfile);
		fflush(stdout);

	EXEC SQL COMMIT;
	
/*Start: Check Status of Child Process   - Rahul*/
		fprintf(chr_logfile,"\nCheck Status of Process |%s|\n",chr_h_execit);
		fflush(chr_logfile);
		fflush(stdout);
for ( ; ; )
{
	EXEC SQL SELECT COUNT(*) INTO :l_flg FROM SYS_BATCHPROC
		WHERE PROCESS_NAME=:chr_h_execit
		 AND   PROC_INIT=:chr_p_key_a
		AND   STATUS='started';
	/*	 AND   STARTDATE=:chr_l_sysdate_a;*/
	IS_ANY_ORA_ERROR
	
	if(l_flg == 0)
	{	
		fprintf(chr_logfile,"Process is Completed \n");
		fflush(chr_logfile);
		fflush(stdout);
		break;
	}
}
/*End: Check Status of Child Process   - Rahul*/

	} 
	
	

	

	for(;;)
	{	
		int_no_msgs=0;
		
		EXEC SQL SELECT 1
		INTO :int_no_msgs
		FROM DUAL
		WHERE EXISTS (SELECT 1 FROM MS_MSGENT WHERE status IN ('D', 'R')
			/* and swift_msg_no not in ('548N04','548N03')*/	/* Sana - Condition Added To Exclude 548 Messages for UAT Fix */
		/*and swift_msg_no not in ('548N04','548N03')*/			/*Added For ISKB_6289(Workaround for 535 Generation) on 23092013 */
		/*Changes done for ISKB_6289 commented for ISKB_6456 on 20122013 because ISKB_6289 was a workaround and actual issue got identified*/
		);

		IS_ANY_ORA_ERROR

		if ((int_no_msgs==0) || (APL_ZERO_RESULT_SET))
		{
			break;
		}
		else
		{
			continue;
		}
	}

if (CO_Pro_PurgeMsgEnt(chr_l_msgdatadir,argv,chr_logfile,l_debug_info_ptr) == APL_FAILURE)
	APL_GOBACK_FAIL 

if (CO_Pro_PurgeClientTables(argv,chr_logfile,l_debug_info_ptr) == APL_FAILURE)
	APL_GOBACK_FAIL 

if (CO_Pro_PurgeCCSPendTxn(argv,chr_logfile,l_debug_info_ptr) == APL_FAILURE)
	APL_GOBACK_FAIL 

EXEC SQL SELECT TO_DATE(:chr_l_sysdate_a)+1 INTO :chr_l_nextdate_a
FROM DUAL;
IS_ANY_ORA_ERROR

if(CO_Upd_SToNextBussDt(chr_l_nextdate_a,chr_l_nextoutdate,l_debug_info_ptr)==APL_FAILURE)
	APL_GOBACK_FAIL
else
{
	/* changes by amish -- 27/10*/
		EXEC SQL SELECT PROCESSING_STATUS INTO : chr_h_restartdata :i_restartData
		FROM SYS_BATCHPROC
			WHERE PROCESS_NAME='PROC_EOM'
			AND TRUNC(STARTDATE)=TRUNC(TO_DATE(:chr_l_sysdate_a,'DD/MM/YYYY HH24:MI:SS'))/*Isolve326:01-06-2007 */
			AND STATUS='started'
			AND PROC_INIT='PROC_EOD';
	IS_ANY_ORA_ERROR
	
	printf("\n sqlca.sqlcode is***************|%d|\n",sqlca.sqlcode);
	fflush(stdout);

	if(sqlca.sqlcode == 1403)
	{
		EXEC SQL UPDATE PRO_SYS_DATE
		SET SYS_DATE=:chr_l_nextoutdate,
			 EOD_IND='B';
		IS_ANY_ORA_ERROR
	}
}
APL_GOBACK_SUCCESS
RETURN_SUCCESS:
{
	CO_ProcMonitor(chr_logfile,NULL,l_debug_info_ptr,NULL);
	
	
		memset(chr_l_sysdatetime,APL_NULL_CHAR,APL_DATE_LEN);
			if (CO_RtvSysDtTime(chr_l_sysdatetime, l_debug_info_ptr) != APL_SUCCESS)
						{APL_GOBACK_FAIL }
	fprintf(chr_logfile,"Returning successfully from completing Eod at %s\n",chr_l_sysdatetime);
	EXEC SQL UPDATE SYS_BATCHPROC
		SET STATUS='completed',
			STAT_DET='Completed Eod'
			WHERE PROCESS_NAME=:p_progname
			AND 	STATUS='started'
			AND   STARTDATE=:chr_l_sysdate_a
			AND	PROC_INIT=:chr_p_key_a;
	IS_ANY_ORA_ERROR
	EXEC SQL COMMIT;	
	//fclose(chr_inifile);//TechUpgrade-Fix
	fclose(chr_inifile);
	fflush(chr_logfile);
	fclose(chr_logfile);
	
	/* Added by Amit Nair (Dated 05/06/2006) for automatically stopping and starting application services */
	char l_buf[1000]                    =  APL_NULL_STRING;
	memset(l_buf, APL_NULL_CHAR , 1000);
	sprintf(l_buf,"$INTL_ROOT_PATH/users/EodStartStop.ksh");	
	printf("\n Executing Stop and Start Script\n");
	printf("\nCommand = |%s| ",l_buf);
	system(l_buf);
	/**************/
	return APL_SUCCESS;
}
	
RETURN_FAILURE:
{
	EXEC SQL ROLLBACK ;
	
	EXEC SQL UPDATE SYS_BATCHPROC
		SET PROC_ENDFLG='Y'
			WHERE PROCESS_NAME=:p_progname
			AND 	STATUS='started'
			AND   STARTDATE=:chr_l_sysdate_a
			AND	PROC_INIT=:chr_p_key_a;

	EXEC SQL COMMIT;
	fclose(chr_inifile);
	CO_ProcMonitor(chr_logfile,NULL,l_debug_info_ptr,NULL);
		
		
	memset(chr_l_sysdatetime,APL_NULL_CHAR,APL_DATE_LEN);
		if (CO_RtvSysDtTime(chr_l_sysdatetime, l_debug_info_ptr) != APL_SUCCESS)
					{APL_GOBACK_FAIL }
	fprintf(chr_logfile,"Returning unsuccessfully from Eod at %s\n",chr_l_sysdatetime);
	fflush(chr_logfile);
	fclose(chr_logfile);
	return APL_FAILURE;
}
} 
//AIX - Warnings Removal
int main(int argc,char **argv) {
	CO_Pro_BatchScheduler(argv[0],
							argv[1],
							argv[2],
							argv[3],
							argv[4],
							argv[5],
							argv[6],
							argv[7],
							argv[8],
							argv[9]
							);
	return APL_SUCCESS;
	}




int CO_Pro_DelDataFile(char *p_datafile)
{
char chr_delstring[100] = APL_NULL_STRING;
char chr_teststring[100] = APL_NULL_STRING;

memset(chr_delstring,APL_NULL_CHAR,100);


/*Commented for Linux Migration
 #ifdef OS_UNIX */
 sprintf(chr_teststring,"test -r %s",p_datafile);

if ( !system(chr_teststring) )
{

        if ( !unlink(p_datafile) )
        {
                return APL_SUCCESS;
        }
        else
        {
                return APL_FAILURE;
        }
}

/* Commented for Linux Migration
 #endif */

      RETURN_SUCCESS  :
      {
                        return (APL_SUCCESS);
      }
      RETURN_FAILURE  :
      {
         return (APL_FAILURE);
	}
}

int CO_Pro_PurgeMsgEnt(char *p_msgdatadir,char **argv,FILE *p_logfile,DEBUG_INFO_STRUCT_H   **l_debug_info_ptr)
{
#define BUFFER_LEN_B 100
#define COMMIT_COUNT_MS_ARCH_A 5000
char chr_h_data_file[31],chr_h_imsgent_rowid[APL_ROWID_LEN] = APL_NULL_STRING;
char chr_h_temp_data_file[31] = APL_NULL_STRING;
short i_temp_data_file = 0;
char chr_l_msgdatadir[PATH_LENGTH]   = APL_NULL_STRING;
char chr_l_msgoutfile[100]       = APL_NULL_STRING;
char chr_l_msgarchfile[100]         = APL_NULL_STRING;
char chr_l_msgdatafile[100]                      = APL_NULL_STRING;
char chr_no_data_file[5] = {APL_NO_DATA_FILE};
char chr_l_buf[BUFFER_LEN_B]   = APL_NULL_STRING;
int  int_fetch_cnt_2             = 0;
char l_temp_processing_status[51] = APL_NULL_STRING;

        EXEC SQL VAR chr_h_data_file IS STRING;
        EXEC SQL VAR chr_h_imsgent_rowid IS STRING;

        CO_ProcMonitor(p_logfile, "Started purge for IMSGENT", NULL, NULL);

	EXEC SQL DECLARE iarchmsg_cur CURSOR FOR
        SELECT a.info_file,a.rowid
        FROM MS_MSGENT a
        WHERE a.status = 'P' and
              not exists ( select message_ind from MS_MSGLOG
                                                                where MS_MSGLOG.message_ind = TO_CHAR(swift_msg_seqno) );

	EXEC SQL OPEN iarchmsg_cur;
        IS_ANY_ORA_ERROR
	

        for( ; ; )
        {

                EXEC SQL FETCH iarchmsg_cur INTO :chr_h_data_file,:chr_h_imsgent_rowid;

                if(sqlca.sqlcode == 1403)
                {
                        break;
                }
                IS_ANY_ORA_ERROR

                


                EXEC SQL DELETE MS_MSGENT
                WHERE ROWID = :chr_h_imsgent_rowid;

                IS_ANY_ORA_ERROR

                int_fetch_cnt_2++;

        if ( (int_fetch_cnt_2%COMMITSIZE) == 0 ) /* Bageshri --10GM */
        {
        memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN_B);
        strcpy(chr_l_buf,"Purged");
        strcat(chr_l_buf,ltoa(int_fetch_cnt_2));
        strcat(chr_l_buf," records");

        EXEC SQL UPDATE SYS_BATCHPROC
        SET STAT_DET = :chr_l_buf
   WHERE PROCESS_NAME=:argv[0]
   AND   PROC_INIT=:argv[1]
   AND   STARTDATE=:argv[2]
   AND   STATUS='started';

        

        EXEC SQL COMMIT WORK;
        IS_ANY_ORA_ERROR

        CO_ProcMonitor(p_logfile, chr_l_buf, NULL, NULL);
        CO_ProcMonitor(p_logfile, "COMMITTED ", NULL, NULL);

        

   EXEC SQL SELECT PROCESSING_STATUS into :l_temp_processing_status
        FROM SYS_BATCHPROC
   WHERE PROCESS_NAME=:argv[0]
   AND   PROC_INIT=:argv[1]
   AND   STARTDATE=:argv[2]
   AND   STATUS='started'
   FOR UPDATE OF PROCESSING_STATUS,STATUS;

        IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(  ERR_REC_NOTFND,
                                                "Batch-In-Proc Rec.",
                                                 APL_NULL_STRING,
						APL_NULL_STRING)

        EXEC SQL OPEN iarchmsg_cur;
        IS_ANY_ORA_ERROR

        }


        }

        memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN_B);
        strcpy(chr_l_buf,"Purged ");
        strcat(chr_l_buf,ltoa(int_fetch_cnt_2));
        strcat(chr_l_buf," records");

        EXEC SQL UPDATE SYS_BATCHPROC
        SET STAT_DET = :chr_l_buf
   WHERE PROCESS_NAME=:argv[0]
   AND   PROC_INIT=:argv[1]
   AND   STARTDATE=:argv[2]
   AND   STATUS='started';

        

        EXEC SQL COMMIT WORK;
        IS_ANY_ORA_ERROR

        CO_ProcMonitor(p_logfile, chr_l_buf, NULL, NULL);
        CO_ProcMonitor(p_logfile, "Finished Purge for IMSGENT\n", NULL, NULL);


      RETURN_SUCCESS  :
      {
                        return (APL_SUCCESS);
      }
      RETURN_FAILURE  :
      {
         return (APL_FAILURE);
                }

}

int CO_Pro_PurgeClientTables(char **argv,FILE *p_logfile,DEBUG_INFO_STRUCT_H   **l_debug_info_ptr)
{

	char chr_l_buf[BUFFER_LEN_B]   = APL_NULL_STRING;
	int int_h_commitsize = COMMIT_COUNT_E + 1;
	long l_rowsprocessed = 0L;
	char l_temp_processing_status[51] = APL_NULL_STRING;

	CO_ProcMonitor(p_logfile, "Started purging for client tables", NULL, NULL);

	
	
	l_rowsprocessed = 0L;
	for ( ; ; )
   {
		sqlca.sqlerrd[2] = 0;

		EXEC SQL DELETE PRO_REQUEST_DEAL 
		WHERE (SMP_ID IS NULL OR STATUS ='4') 
		AND STATUS != '5'
		AND ROWNUM < :int_h_commitsize;

		IS_ANY_ORA_ERROR

      if ( sqlca.sqlerrd[2] == 0 )
         break;

      l_rowsprocessed += sqlca.sqlerrd[2];

      memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN_B);
      strcpy(chr_l_buf,"Purged");
      strcat(chr_l_buf,ltoa(l_rowsprocessed));
      strcat(chr_l_buf," records from CLIENT_TRADE table");

      EXEC SQL UPDATE SYS_BATCHPROC
      SET STAT_DET = :chr_l_buf
		WHERE PROCESS_NAME=:argv[0]
   	AND   PROC_INIT=:argv[1]
   	AND   STARTDATE=:argv[2]
   	AND   STATUS='started';

        

        EXEC SQL COMMIT WORK;
        IS_ANY_ORA_ERROR

        CO_ProcMonitor(p_logfile, chr_l_buf, NULL, NULL);

        

	   EXEC SQL SELECT PROCESSING_STATUS into :l_temp_processing_status
      FROM SYS_BATCHPROC
   	WHERE PROCESS_NAME=:argv[0]
	   AND   PROC_INIT=:argv[1]
 		AND   STARTDATE=:argv[2]
  		AND   STATUS='started'
   	FOR UPDATE OF PROCESSING_STATUS,STATUS;

        IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(  ERR_REC_NOTFND,
                                                "Batch-In-Proc Rec.",
                                                 APL_NULL_STRING,
                  									APL_NULL_STRING)
	}

	
	

   l_rowsprocessed = 0L;
   sqlca.sqlerrd[2] = 0;
	
	EXEC SQL UPDATE PRO_REQUEST_DEAL
	SET STATUS = '0'
	WHERE SMP_ID IS NOT NULL
	AND STATUS = '1';

	IS_ANY_ORA_ERROR

   l_rowsprocessed = sqlca.sqlerrd[2];

   memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN_B);
   strcpy(chr_l_buf,"Updated");
   strcat(chr_l_buf,ltoa(l_rowsprocessed));
   strcat(chr_l_buf," SMI records in CLIENT_TRADE table from status_ind 1 to 0");

   EXEC SQL UPDATE SYS_BATCHPROC
   SET STAT_DET = :chr_l_buf
	WHERE PROCESS_NAME=:argv[0]
  	AND   PROC_INIT=:argv[1]
  	AND   STARTDATE=:argv[2]
  	AND   STATUS='started';

   

   EXEC SQL COMMIT WORK;
   IS_ANY_ORA_ERROR

   CO_ProcMonitor(p_logfile, chr_l_buf, NULL, NULL);

	


	
	l_rowsprocessed = 0L;
	for ( ; ; )
   {
		sqlca.sqlerrd[2] = 0;

		EXEC SQL DELETE PRO_REQUEST_MT WHERE 
		STATUS != '5' AND
		ROWNUM < :int_h_commitsize;
		IS_ANY_ORA_ERROR

      if ( sqlca.sqlerrd[2] == 0 )
         break;

      l_rowsprocessed += sqlca.sqlerrd[2];

      memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN_B);
      strcpy(chr_l_buf,"Purged");
      strcat(chr_l_buf,ltoa(l_rowsprocessed));
      strcat(chr_l_buf," records from CLIENT_MNT table");

      EXEC SQL UPDATE SYS_BATCHPROC
      SET STAT_DET = :chr_l_buf
		WHERE PROCESS_NAME=:argv[0]
   	AND   PROC_INIT=:argv[1]
   	AND   STARTDATE=:argv[2]
   	AND   STATUS='started';

        

        EXEC SQL COMMIT WORK;
        IS_ANY_ORA_ERROR

        CO_ProcMonitor(p_logfile, chr_l_buf, NULL, NULL);

        

	   EXEC SQL SELECT PROCESSING_STATUS into :l_temp_processing_status
      FROM SYS_BATCHPROC
   	WHERE PROCESS_NAME=:argv[0]
	   AND   PROC_INIT=:argv[1]
 		AND   STARTDATE=:argv[2]
  		AND   STATUS='started'
   	FOR UPDATE OF PROCESSING_STATUS,STATUS;

        IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(  ERR_REC_NOTFND,
                                                "Batch-In-Proc Rec.",
                                                 APL_NULL_STRING,
                  									APL_NULL_STRING)
	}

	
	l_rowsprocessed = 0L;
	for ( ; ; )
   {
		sqlca.sqlerrd[2] = 0;

		EXEC SQL DELETE PRO_REQUEST_IV WHERE 
		STATUS != '5' AND
		ROWNUM < :int_h_commitsize;
		IS_ANY_ORA_ERROR

      if ( sqlca.sqlerrd[2] == 0 )
         break;

      l_rowsprocessed += sqlca.sqlerrd[2];

      memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN_B);
      strcpy(chr_l_buf,"Purged");
      strcat(chr_l_buf,ltoa(l_rowsprocessed));
      strcat(chr_l_buf," records from CLIENT_BILL table");

      EXEC SQL UPDATE SYS_BATCHPROC
      SET STAT_DET = :chr_l_buf
		WHERE PROCESS_NAME=:argv[0]
   	AND   PROC_INIT=:argv[1]
   	AND   STARTDATE=:argv[2]
   	AND   STATUS='started';

        

        EXEC SQL COMMIT WORK;
        IS_ANY_ORA_ERROR

        CO_ProcMonitor(p_logfile, chr_l_buf, NULL, NULL);

        

	   EXEC SQL SELECT PROCESSING_STATUS into :l_temp_processing_status
      FROM SYS_BATCHPROC
   	WHERE PROCESS_NAME=:argv[0]
	   AND   PROC_INIT=:argv[1]
 		AND   STARTDATE=:argv[2]
  		AND   STATUS='started'
   	FOR UPDATE OF PROCESSING_STATUS,STATUS;

        IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(  ERR_REC_NOTFND,
                                                "Batch-In-Proc Rec.",
                                                 APL_NULL_STRING,
                  									APL_NULL_STRING)
	}

	
	l_rowsprocessed = 0L;
	for ( ; ; )
   {
		sqlca.sqlerrd[2] = 0;

		EXEC SQL DELETE PRO_REQUEST_CA WHERE 
		STATUS != '5' AND
		ROWNUM < :int_h_commitsize;
		IS_ANY_ORA_ERROR

      if ( sqlca.sqlerrd[2] == 0 )
         break;

      l_rowsprocessed += sqlca.sqlerrd[2];

      memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN_B);
      strcpy(chr_l_buf,"Purged");
      strcat(chr_l_buf,ltoa(l_rowsprocessed));
      strcat(chr_l_buf," records from CLIENT_CA table");

      EXEC SQL UPDATE SYS_BATCHPROC
      SET STAT_DET = :chr_l_buf
		WHERE PROCESS_NAME=:argv[0]
   	AND   PROC_INIT=:argv[1]
   	AND   STARTDATE=:argv[2]
   	AND   STATUS='started';

        

        EXEC SQL COMMIT WORK;
        IS_ANY_ORA_ERROR

        CO_ProcMonitor(p_logfile, chr_l_buf, NULL, NULL);

        

	   EXEC SQL SELECT PROCESSING_STATUS into :l_temp_processing_status
      FROM SYS_BATCHPROC
   	WHERE PROCESS_NAME=:argv[0]
	   AND   PROC_INIT=:argv[1]
 		AND   STARTDATE=:argv[2]
  		AND   STATUS='started'
   	FOR UPDATE OF PROCESSING_STATUS,STATUS;

        IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(  ERR_REC_NOTFND,
                                                "Batch-In-Proc Rec.",
                                                 APL_NULL_STRING,
                  									APL_NULL_STRING)
	}


	
        

   EXEC SQL SELECT PROCESSING_STATUS into :l_temp_processing_status
   FROM SYS_BATCHPROC
   WHERE PROCESS_NAME=:argv[0]
   AND   PROC_INIT=:argv[1]
   AND   STARTDATE=:argv[2]
   AND   STATUS='started'
   FOR UPDATE OF PROCESSING_STATUS,STATUS;

	EXEC SQL DELETE PRO_REQUEST_BATCH WHERE STATUS != '5';
	IS_ANY_ORA_ERROR

	EXEC SQL DELETE PRO_REQUEST_UPLOAD;
	IS_ANY_ORA_ERROR

   memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN_B);
   strcpy(chr_l_buf,"Purged BATCH and UPLOAD client tables");

   EXEC SQL UPDATE SYS_BATCHPROC
   SET STAT_DET = :chr_l_buf
   WHERE PROCESS_NAME=:argv[0]
   AND   PROC_INIT=:argv[1]
   AND   STARTDATE=:argv[2]
   AND   STATUS='started';

	EXEC SQL COMMIT WORK;
	IS_ANY_ORA_ERROR


	CO_ProcMonitor(p_logfile, "Finished Purging of client tables\n", NULL, NULL);

	APL_GOBACK_SUCCESS

RETURN_SUCCESS  :
      {
         return (APL_SUCCESS);
      }
RETURN_FAILURE  :
      {
         return (APL_FAILURE);
		}

}


int CO_Pro_PurgeCCSPendTxn(char **argv,FILE *p_logfile,DEBUG_INFO_STRUCT_H   **l_debug_info_ptr)
{

   char chr_l_buf[BUFFER_LEN_B]   = APL_NULL_STRING;
   int int_h_commitsize = COMMIT_COUNT_E + 1;
   long l_rowsprocessed = 0L;
		char l_temp_processing_status[51] = APL_NULL_STRING;

   CO_ProcMonitor(p_logfile, "Started purging for CCSPendTxn", NULL, NULL);

	l_rowsprocessed = 0L;
	for ( ; ; )
   {
		sqlca.sqlerrd[2] = 0;

		EXEC SQL DELETE DL_CCSPENDTXN
		WHERE STATUS ='T' 
		AND ACCESS_STAMP < (select SYS_DATE-4 from pro_sys_date) 
		AND ROWNUM < :int_h_commitsize;

		IS_ANY_ORA_ERROR

      if ( sqlca.sqlerrd[2] == 0 )
         break;

      l_rowsprocessed += sqlca.sqlerrd[2];

      memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN_B);
      strcpy(chr_l_buf,"Purged");
      strcat(chr_l_buf,ltoa(l_rowsprocessed));
      strcat(chr_l_buf," records from CCS_PENDTXN table");

      EXEC SQL UPDATE SYS_BATCHPROC
      SET STAT_DET = :chr_l_buf
		WHERE PROCESS_NAME=:argv[0]
   	AND   PROC_INIT=:argv[1]
   	AND   STARTDATE=:argv[2]
   	AND   STATUS='started';

        

        EXEC SQL COMMIT WORK;
        IS_ANY_ORA_ERROR

        CO_ProcMonitor(p_logfile, chr_l_buf, NULL, NULL);

        

	   EXEC SQL SELECT PROCESSING_STATUS into :l_temp_processing_status
      FROM SYS_BATCHPROC
   	WHERE PROCESS_NAME=:argv[0]
	   AND   PROC_INIT=:argv[1]
 		AND   STARTDATE=:argv[2]
  		AND   STATUS='started'
   	FOR UPDATE OF PROCESSING_STATUS,STATUS;

        IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(  ERR_REC_NOTFND,
                                                "Batch-In-Proc Rec.",
                                                 APL_NULL_STRING,
                  									APL_NULL_STRING)

	}

   CO_ProcMonitor(p_logfile, "Finished Purging of CCSPendTxn\n", NULL, NULL);

	
   CO_ProcMonitor(p_logfile, "Started purging for CCS_FailMsg", NULL, NULL);

	l_rowsprocessed = 0L;
	for ( ; ; )
   {
		sqlca.sqlerrd[2] = 0;

		EXEC SQL DELETE DL_CCSFAILMSG
		WHERE REPORT_IND ='Y' 
		AND ROWNUM < :int_h_commitsize;

		IS_ANY_ORA_ERROR

      if ( sqlca.sqlerrd[2] == 0 )
         break;

      l_rowsprocessed += sqlca.sqlerrd[2];

      memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN_B);
      strcpy(chr_l_buf,"Purged");
      strcat(chr_l_buf,ltoa(l_rowsprocessed));
      strcat(chr_l_buf," records from CCS_FAILMSG table");

      EXEC SQL UPDATE SYS_BATCHPROC
      SET STAT_DET = :chr_l_buf
		WHERE PROCESS_NAME=:argv[0]
   	AND   PROC_INIT=:argv[1]
   	AND   STARTDATE=:argv[2]
   	AND   STATUS='started';

        

        EXEC SQL COMMIT WORK;
        IS_ANY_ORA_ERROR

        CO_ProcMonitor(p_logfile, chr_l_buf, NULL, NULL);

        

	   EXEC SQL SELECT PROCESSING_STATUS into :l_temp_processing_status
      FROM SYS_BATCHPROC
   	WHERE PROCESS_NAME=:argv[0]
	   AND   PROC_INIT=:argv[1]
 		AND   STARTDATE=:argv[2]
  		AND   STATUS='started'
   	FOR UPDATE OF PROCESSING_STATUS,STATUS;

        IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(  ERR_REC_NOTFND,
                                                "Batch-In-Proc Rec.",
                                                 APL_NULL_STRING,
                  									APL_NULL_STRING)

	}

   CO_ProcMonitor(p_logfile, "Finished Purging of CCS_FAILMSG\n", NULL, NULL);

   APL_GOBACK_SUCCESS

RETURN_SUCCESS  :
      {
         return (APL_SUCCESS);
      }
RETURN_FAILURE  :
      {
         return (APL_FAILURE);
      }
}
