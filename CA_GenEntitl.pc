/*
 *    COPYRIGHT NOTICE
 *
 *   Copyright 2005 Polaris Software Lab Limited. All rights reserved.
 *
 *   These materials are confidential and proprietary to
 *    Polaris Software Lab Limited and no part of these materials should
 *    be reproduced, published, transmitted or distributed in any form or
 *    by any means, electronic, mechanical, photocopying, recording or
 *    otherwise, or stored in any information storage or retrieval system
 *    of any nature nor should the materials be disclosed to third parties
 *    or used in any other manner for which this is not authorized, without
 *    the prior express written authorization of Polaris Software Lab Limited.
 */
/*********************************************************************
 *
 * Module Name         :      Corporate Actions
 *
 * File Name           :      CA_GenEntitl.pc
 *
 * Description         :      Contains Functions Related to Entitl Gen
 *
 *
 *
 *            Version Control Block
 *
 * Date        Version     Author           Description                 RFS No.
 * ---------   --------  ---------------  ------------------           ---------
 * 18/01/2006   1.2        Smita Bhat        New File                  Base Version
 * 20/01/2006   1.3    	   Smita Bhat     Added changes related 	HDFCCA_027
 *			       	       	  to Name Change Event	
 * 30/01/2006	 1.4	   Smita Bhat	Added changed related	       HDFCCA_009
 *					   to Buy Back Event
 * 13/04/2011 1.0.1.9     Vilin Patil   changes done for proper         ISKB_4734
 *                                      calculation of entitlement 
 * 28/11/2011             Sana Bhatkar    Retro for event closure and entitlement optimisation[ISAB 108][RBS]
 * 21/09/2015            Anjaneyulu       Swift Message Upgradation     ISKB_1621
 * 28/03/2022   1.1      kotubabu         Linux Migration    Kotak Implementation
 *************************************************************************/

#include	"string.h"
#include	"stdlib.h"
#include	"math.h"
#include "CR_Common.h"
#include "CA_Common.h"
/** Included New File -- Biju **/

#define	RTV_SYSTEM_DATA
#define	S_RESTART_SEP_TOKEN	"|"
#define	S_LEVEL_EVENT			1
#define	S_LEVEL_ENTITL			2

#define	INTEREST_BASE_IND_A	"A"
#define	INTEREST_BASE_IND_B	"B"
#define	INTEREST_BASE_IND_C	"C"
#define	INTEREST_BASE_IND_D	"D"
#define	INTEREST_BASE_IND_E	"E"

#define	S_YEAR_POS				6
#define	S_YEAR_LEN				4
#define	S_MONTH_POS				3
#define	S_DAY_POS				0
#define  S_MONTH_LEN				2
#define  S_DAY_LENGTH			2
#define  S_DEC_LENGTH         4
#define	S_DAYS_IN_YEAR			365
#define	S_LAST_DAY				"31/12/%s 12:00:00"
#define	S_FIRST_DAY				"01/01/%s 12:00:00"

#define  UROUND_EUR_DEC_LEN  	5
#define  EUR_DEC_LEN    		2 

#define  TRUNC_VAL_DEC(x,dec) ((floor((x)*pow(10,(dec))))*pow(10,(-1)*(dec)))



EXEC SQL INCLUDE SQLCA.H;



typedef struct{
	char		h_instr_code[APL_INSTRUMENTCODE_LEN];
	char		h_dl_client[APL_CLIENT_LENGTH];
	double	h_safekeep_pos;
	double	h_nval_rec;
	double	h_nval_del;
	double	h_val_rec;
	double   h_val_del;
	double	h_dp_rec;
	double   h_dp_del;
	}S_POSITION_STRUCT_H;
								  
									
typedef struct{
	short		i_instr_code;
	short		i_dl_client;
	short		i_safekeep_pos;
	short		i_nval_rec;
	short		i_nonval_del;
	short		i_val_rec;
	short		i_val_del;
	short		i_dp_rec;
	short		i_dp_del;
	}S_POSITION_STRUCT_I;


/**FILE*	g_inifile; -- Not used -- Biju **/
/* Added by kotubabu for Linux Migration-START*/
#ifdef OS_LINUX
FILE*	g_logfile;
FILE*	g_failurefile;
#else
FILE*	g_logfile = APL_OUT_FILE; /** Lets print comments until the logfile is created **/
FILE*	g_failurefile= APL_OUT_FILE; /** Lets failure print comments until the logfile is created*Sana [ISAB 108][RBS][30-12-2010]**/
#endif  /* Added by kotubabu for Linux Migration-END*/
char	chr_g_progname[APL_BATCH_PROGNAME_LEN]				=	APL_NULL_STRING;
char	chr_g_key[APL_BATCH_KEY_LEN]							=	APL_NULL_STRING;
char	chr_g_start_date[APL_DATE_LEN]						=	APL_NULL_STRING;
char	chr_g_restart_ca_id[CORP_ID_LEN + 2]						=	APL_NULL_STRING;
char	chr_g_restart_client[APL_CLIENT_LENGTH]			=	APL_NULL_STRING;
char	chr_g_restart_data_h[APL_RESTARTDATA_LENGTH + 2]		=	APL_NULL_STRING;
short	g_restart_data_i											=	0;
char	chr_g_tmp_restart_data[APL_RESTARTDATA_LENGTH]	=	APL_NULL_STRING;
char	chr_g_log_buff[500]								=	APL_NULL_STRING;
char	chr_g_fail_buff[500]				=	APL_NULL_STRING;	/**Buffer for failure statements*Sana [ISAB 108][RBS][30-12-2010]**/
char	chr_g_sys_date[APL_DATE_LEN]							=	APL_NULL_STRING;
char	chr_g_sys_date_time[APL_DATE_LEN]					=	APL_NULL_STRING;
char	chr_g_funccode[CA_FUNC_CD_LEN]						= 	APL_NULL_STRING;
char	chr_g_client[APL_CLIENT_LENGTH]						=	APL_NULL_STRING;
char 	chr_custody_id_b[APL_USERID_LEN]						=	APL_NULL_STRING;
char  chr_g_splacc[APL_CLIENT_LENGTH] 						= 	APL_NULL_STRING;	
/*Retro from ICICI for filters on Entitlement Generation - Nitya - Starts*/
char g_instr_code_t [22];
char g_event_type [3];
char g_ex_dt [11];
short l_cond_exists_ca_pay = 0;
int   flag_g_instr_code_t=0;
int   flag_g_event_type=0;
int   flag_g_ex_dt=0;
char g_ex_dt_f [23];
char g_ex_dt_s [23];
/*Retro from ICICI for filters on Entitlement Generation - Nitya - Ends*/
CA_CASECEVENT_STRUCT_H   *q_ca_caseceventstruct_h		=	(CA_CASECEVENT_STRUCT_H *)NULL;
CA_CASECEVENT_STRUCT_I   *l_ca_casecevent_struct_i		=	(CA_CASECEVENT_STRUCT_I *)NULL;
CA_CAEVENT_STRUCT_H	g_ca_caevent_struct_h;
CA_CAEVENT_STRUCT_I	g_ca_caevent_struct_i;
S_POSITION_STRUCT_H	g_position_h;
S_POSITION_STRUCT_I	g_position_i;
MT_INSTRUMENT_STRUCT_H	l_mt_instrument_struct_h;
MT_INSTRUMENT_STRUCT_H	l_mt_resinstrument_struct_h;
MT_COMPANY_STRUCT_H	l_mt_company_struct_h;
DL_CURRENCY_STRUCT_H	l_dl_currency_struct_h;
//CA_CANOTIFY_STRUCT_H	l_ca_canotify_struct_h;  	/* Commented by Swapnil for Entitlement Optimization Changes	*/	
char	chr_g_prev_rec_dt_new[APL_DATE_LEN]					=	APL_NULL_STRING;
char	chr_g_curr_business_dt[APL_DATE_LEN]				=	APL_NULL_STRING;
char 	chr_g_eventint_cutover_dt[APL_DATE_LEN] 			= 	APL_NULL_STRING;
char 	chr_g_sys_dt[APL_DATE_LEN] 			= 	APL_NULL_STRING;	/* Swapnil for Entitlement Optimization Changes */
int	int_g_flg_mod_event 	=	0;		
int	int_resacl				=	0;
int   int_g_date_diff		=	0;
int   int_g_splacc_flg 		=	0; 
int g_priority = 0;

/* Added By Santhoshi for PEG-CA-ENH-2.3 - retro by Sana Bhatkar */
char  chr_g_closure_dt[APL_DATE_LEN]           = APL_NULL_STRING;
int int_date_diff_cp = 0;
short i_date_diff_cp = 0;
/* End of Santhoshi Changes */
int	CA_Proc_GenUpdEntitl( CA_CAENTITLEMENT_STRUCT_H *p_ca_caentitlement_struct_h,
								CA_CAENTITLEMENT_STRUCT_I *l_ca_caentitlement_struct_i,
								CA_CAENTITLEMENT_STRUCT_H *l_ca_caentitlement_struct_h,
								char					 *p_ora_rowid,
                     	INTL_ENV_DATA_STRUCT_H 	 *p_intlenv_data_struct_h,
                     	DEBUG_INFO_STRUCT_H 		 **l_debug_info_ptr);

static	int CA_Commit ( int				p_commit_status,
								int				p_commit_level,
								DEBUG_INFO_STRUCT_H	**l_debug_info_ptr);

static int CA_CalcEntitlPos(	short						p_safek_flg,
									CA_CASECEVENT_STRUCT_H   *p_ca_casecevent_struct_h,
									char						*p_rec_date_h,
									char						*chr_p_client,
									double					*p_entpos,
									DEBUG_INFO_STRUCT_H			**l_debug_info_ptr);

static int 	CA_CalcEntitlement( CA_CAEVENT_STRUCT_H		*p_ca_caevent_struct_h,
										CA_CAENTITLEMENT_STRUCT_H	*p_ca_caentitlement_struct_h,
										CA_CASECEVENT_STRUCT_H   *p_ca_casecevent_struct_h,
										double					p_ent_pos,
										double					p_nomval,
										char						*p_lst_pay_date,
										char						*p_basis,
										DEBUG_INFO_STRUCT_H			**l_debug_info_ptr );

static int	CA_CalcInterest(double					p_nom_val,
									double					p_rate,
									double					*p_calc_value,  
									char						*p_from_date,
									char						*p_to_date,
									char						*p_basis,
									DEBUG_INFO_STRUCT_H			**l_debug_info_ptr);


static int	CA_CalcDaysInAYear(int						chr_p_year,
										int						*p_no_days,
										DEBUG_INFO_STRUCT_H			**l_debug_info_ptr);


static int 		CA_CalcPosnAdj(	char						*p_from_date,
										char						*p_to_date,
										char						*chr_p_client,
										char						*p_instr_code,
										double					*p_posn_adj,
										DEBUG_INFO_STRUCT_H         **l_debug_info_ptr);

static int     CA_CalcPosnAdj_Tr( char                 *p_from_date,
                              char                 *p_to_date,
                              char                 *chr_p_client,
                              char                 *p_instr_code,
                              double               *p_posn_adj,
                              DEBUG_INFO_STRUCT_H         **l_debug_info_ptr);

static int 		CA_HuPosnAdj(char						*p_from_date,
									char						*p_instr_code,
									char						*chr_p_client,
									double					*p_posn_adj,
									DEBUG_INFO_STRUCT_H			**l_debug_info_ptr);
static int		CA_SendEntitlMsg(	char 					*p_event_type,
										char 					*p_msg_key1,
										char 					*p_msg_key2,
										DEBUG_INFO_STRUCT_H 		** l_debug_info_ptr);


static int CA_RedenomCalcEnt(  short                p_safek_flg,
                               CA_CASECEVENT_STRUCT_H   *p_ca_casecevent_struct_h,
                               char                 *p_rec_date_h,
                               char                 *chr_p_client,
                               INTL_ENV_DATA_STRUCT_H    *p_intlenv_data_struct_h,
                               DEBUG_INFO_STRUCT_H         **l_debug_info_ptr);

extern int Process_AttCorpAdj( char *,char *,char *,char *,int , double , double *, DEBUG_INFO_STRUCT_H  **);

int main(int argc, char ** argv)  // AIX -Warnings Reaoval
{
    /* Added kotubabu for Linux Migration-START*/
        #ifdef OS_LINUX 
        g_logfile=APL_OUT_FILE;
		g_failurefile=APL_OUT_FILE;
        #endif
    /* Added by kotubabu for Linux Migration-END*/
	struct sqlca sqlca;
	/**DEBUG_INFO_STRUCT_H		*l_debug_infolist = (DEBUG_INFO_STRUCT_H *)NULL, 
									**l_debug_info_ptr= (DEBUG_INFO_STRUCT_H **)NULL;
									Only one variable is required **/
	DEBUG_INFO_STRUCT_H		**l_debug_info_ptr = (DEBUG_INFO_STRUCT_H **)NULL; 
	INTL_ENV_DATA_STRUCT_H	p_intlenv_data_struct_h;
	/**
	 * char							chr_inifile[PATH_LENGTH];
		char							chr_logfile[PATH_LENGTH];
		int							int_retval=0; 
   	char                 	chr_custody_id_b[APL_USERID_LEN]; Not Required -- Biju **/
	char 							chr_warn_cd_eventfrz[CA_ALERT_CODE_LEN] ={ALERT_EVT_FRZ};

/**
	EXEC SQL BEGIN DECLARE SECTION;
		char chr_uname[APL_USERID_LEN];
		char chr_passwd[APL_PASSWD_LEN];
	EXEC SQL END DECLARE SECTION; 

	EXEC SQL VAR chr_uname IS STRING;
	EXEC SQL VAR chr_passwd IS STRING; Taken Cared in makefile **/

	/**l_debug_info_ptr = &l_debug_infolist; Now Memory allocation should be done **/
	l_debug_info_ptr = (DEBUG_INFO_STRUCT_H **)calloc(1,sizeof(DEBUG_INFO_STRUCT_H *));
	
	/**strcpy(chr_inifile,getenv("INTL_ROOT_PATH"));
	strcat(chr_inifile,"/intl_sun.cfg");
	if ( ( g_inifile=fopen(chr_inifile,"r") ) == NULL)
		exit(-1);
	
   APL_FETCH_DB_LOGIN_DETAILS(g_inifile,chr_custody_id_b,chr_uname,chr_passwd,APL_OUT_FILE,l_debug_info_ptr)
   EXEC SQL CONNECT :chr_uname IDENTIFIED BY :chr_passwd;
   IS_ANY_ORA_ERROR -- Will be done in below function **/

	if(CO_Get_DBConnect(l_debug_info_ptr) == APL_FAILURE)
	{
		/* Added by kotubabu for Linux Migration-START*/
        #ifdef OS_LINUX
		CO_ProcMonitor(g_logfile,"EntitleMent Generation :Failed To Get Connection",NULL,NULL);
		/**Sana [ISAB 108][RBS][30-12-2010]**/
		#else
		CO_ProcMonitor(g_failurefile,"\nInternal Error Occured. Contact Support team",NULL,NULL);
		/**End**/
		#endif  /* Added by kotubabu for Linux Migration-END*/
		APL_GOBACK_FAIL
	}
	
   if ( CO_Rtv_RptFileName("2C",
								APL_LOGFILE_DESC,
								100,
								argv[5],
								argv,
								&g_logfile,
								l_debug_info_ptr) == APL_FAILURE) 
	{
		CO_ProcMonitor(g_logfile,"EntitleMent Generation :Failed To Create Log File",NULL,NULL);
		/**Sana [ISAB 108][RBS][30-12-2010]**/
		CO_ProcMonitor(g_failurefile,"\nInternal Error Occured. Contact Support team.",NULL,NULL);
		/**End**/
		APL_GOBACK_FAIL
	}
/**Sana [ISAB 108][RBS][30-12-2010]**/
if ( CO_Rtv_RptFileName("ENF",
                                                                "FAILURE LOG",
                                                                100,
                                                                argv[5],
                                                                argv,
                                                                &g_failurefile,
                                                                l_debug_info_ptr) == APL_FAILURE)
        {
                CO_ProcMonitor(g_failurefile,"\nInternal Error Occured. Log Creation Failed. Contact Support Team",NULL,NULL);
		APL_GOBACK_FAIL
	}
/**End**/
	EXEC SQL COMMIT;
	IS_ANY_ORA_ERROR
	

	if ( argc < 4)
	{
		/**sprintf(chr_g_log_buff,"E:Incorrect number of arguments");
		CO_ProcMonitor(g_logfile,chr_g_log_buff,l_debug_info_ptr,NULL); Directly propt the message **/
		CO_ProcMonitor(g_logfile,"EntitleMent Generation : Incorrect number of arguments",NULL,NULL);
		/**Sana [ISAB 108][RBS][30-12-2010]**/
        CO_ProcMonitor(g_failurefile,"\nInternal Error Occured. Contact Support team.",NULL,NULL);
		/**End**/
		APL_GOBACK_FAIL
	}

/*Retro from ICICI for filters on Entitlement Generation - Nitya - Starts*/
	memset(g_ex_dt,NULL,sizeof(g_ex_dt));
	memset(g_ex_dt_f,NULL,sizeof(g_ex_dt_f));
	memset(g_ex_dt_s,NULL,sizeof(g_ex_dt_s));
	memset(g_event_type,NULL,sizeof(g_event_type));
	memset(g_instr_code_t,NULL,sizeof(g_instr_code_t));

		CO_Rtv_DataString(argv[9],"INSTR_CODE",g_instr_code_t);
		CO_Rtv_DataString(argv[9],"CA_EVENT",g_event_type);
		CO_Rtv_DataString(argv[9],"EX_DATE",g_ex_dt);

		printf("\n\n\n g_instr_code_t:::|%s|",g_instr_code_t);
		printf("\n g_event_type:::|%s|",g_event_type);
		printf("\n g_ex_dt:::|%s|\n\n",g_ex_dt);





		if(strcmp(g_instr_code_t,APL_NULL_STRING))
		{
			flag_g_instr_code_t=1;
		}
		if(strcmp(g_event_type,APL_NULL_STRING))
		{
			flag_g_event_type=1;
		}
		if(strcmp(g_ex_dt,APL_NULL_STRING))
		{
			flag_g_ex_dt=1;
		}

		printf("\n\n\n flag_g_instr_code_t:::|%d|",flag_g_instr_code_t);
		printf("\n flag_g_event_type:::|%d|",flag_g_event_type);
		printf("\n flag_g_ex_dt:::|%d|\n\n",flag_g_ex_dt);

		strcpy(g_ex_dt_f,g_ex_dt);
		strcat(g_ex_dt_f," 00:00:00");

		strcpy(g_ex_dt_s,g_ex_dt);
		strcat(g_ex_dt_s," 23:59:59");	

/*Retro from ICICI for filters on Entitlement Generation - Nitya - Ends*/
	strcpy(chr_g_progname,	argv[0]);
	strcpy(chr_g_key,			argv[1]);
	strcpy(chr_g_start_date,	argv[2]);
	strcpy(p_intlenv_data_struct_h.usr, argv[3]);
	strcpy(chr_g_funccode,argv[5]);

	if ( CO_RtvSysParams(l_debug_info_ptr) == APL_FAILURE)
	{
		CO_ProcMonitor(g_logfile,"EntitleMent Generation :Failed in CO_RtvSysParams",NULL,NULL);
		/**Sana [ISAB 108][RBS][30-12-2010]**/
		CO_ProcMonitor(g_failurefile,"\nInternal Error Occured. Contact Support team.",NULL,NULL);
		/**End**/
		APL_GOBACK_FAIL
	}

	if ( CA_Proc_EntitlGen(	&p_intlenv_data_struct_h,
									argv, 
									l_debug_info_ptr) == APL_FAILURE)
	{
		CO_ProcMonitor(g_logfile,"EntitleMent Generation :Failed in CA_Proc_EntitlGen",NULL,NULL);
		/**Sana [ISAB 108][RBS][30-12-2010]**/
		CO_ProcMonitor(g_failurefile,"\nInternal Error Occured. Contact Support team.",NULL,NULL);
		/**End**/
		APL_GOBACK_FAIL
	}

	
	APL_GOBACK_SUCCESS
	RETURN_SUCCESS:
	{
		/**sprintf(chr_g_log_buff,"T:Entitlement Generation exiting successfully\n");
		CO_ProcMonitor(g_logfile,chr_g_log_buff,l_debug_info_ptr,NULL); Can be directly propt the message **/
			
		/* Commented and rewritten by sana as below for query optimization EXEC SQL DELETE CABACKSETTLE
					WHERE INSTR_CODE IN ( SELECT 	INSTR_CODE 
															FROM MT_INSTRUMENT
															WHERE STATUS='AA');*/
		EXEC SQL DELETE CABACKSETTLE a
					WHERE exists (select 1 from MT_INSTRUMENT b where b.INSTR_CODE = a.INSTR_CODE and b.STATUS='AA');
		IS_ANY_ORA_ERROR
		
	/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/
	/*	EXEC SQL INSERT /*+APPEND*/ /*INTO CANOTIFY
					(SELECT	:chr_g_sys_date_time,
								:chr_g_funccode,
								:chr_warn_cd_eventfrz,
								CORP_ID,
								NULL,
								INSTR_CODE,
								NULL,
								NULL
					FROM CAEVENT WHERE STATUS IN  ('FS','FI','FE'));

		IS_ANY_ORA_ERROR */
	/* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/

		EXEC SQL UPDATE /*+FIRST_ROWS(10)*/ SYS_BATCHPROC
		SET status 			= 'completed'
		WHERE process_name		=	RTRIM(:argv[0])
		AND	proc_init			=	RTRIM(:argv[1])
		AND	STARTDATE	=	:argv[2]
		AND	usr		=	RTRIM(:argv[3])
		AND	status		=	'started';
		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(	ERR_REC_NOTFND,
															"SYS_BATCHPROC",
															chr_g_progname,
															chr_g_key )
			/**
															It wil be done in below function 
		if(BT_Status_Completed(	argv[0],
										argv[1],
										argv[2],
										l_debug_info_ptr) == APL_FAILURE)
		{
   		CO_ProcMonitor(g_logfile,"EntitleMent Generation : Failed in BT_Status_Completed",NULL,NULL);
			APL_GOBACK_FAIL
		}**/
		EXEC SQL COMMIT;
		IS_ANY_ORA_ERROR
   	CO_ProcMonitor(g_logfile,"RECORD COMMITTED \n",NULL,NULL);
		CO_ProcMonitor(g_logfile,"EntitleMent Generation : Process Completed\n",NULL,NULL);
		/**Sana [ISAB 108][RBS][30-12-2010]**/
		CO_ProcMonitor(g_failurefile,"EntitleMent Generation : Process Completed",NULL,NULL);
		/**End**/
		APL_CLOSE_FILE(g_logfile);
		APL_CLOSE_FILE(g_failurefile);
		exit(0);
	}

	RETURN_FAILURE:
	{
		EXEC SQL ROLLBACK;

		if ( sqlca.sqlcode < 0 )
		{
			/** sprintf(chr_g_log_buff,"T:Could Not Rollback\n"); -- Biju **/
			CO_ProcMonitor(g_logfile,"EntitleMent Generation : Could Not RollBack\n",NULL,NULL);
			/**Sana [ISAB 108][RBS][30-12-2010]**/
			CO_ProcMonitor(g_failurefile,"\nInternal Error Occured. Contact Support team.",NULL,NULL);
			/**End**/
		}

/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/	
	/*	EXEC SQL INSERT /*+APPEND*/ /* INTO CANOTIFY
					(SELECT	(:chr_g_sys_date_time),
								:chr_g_funccode,
								:chr_warn_cd_eventfrz,
								CORP_ID,
								NULL,
								INSTR_CODE,
								NULL,
								NULL
					FROM CAEVENT 
					WHERE STATUS IN  ('FS','FI','FE'));
	*/
/* Commented by Swapnil for Entitlement Optimization Changes Ends */
		if (sqlca.sqlcode < 0)
		{
			/**sprintf(chr_g_log_buff,"T:Could Not Log Alert For  Entitlement Generation\n");**/
			CO_ProcMonitor(g_logfile,"EntitleMent Generation : Could Not Log Alert",NULL,NULL);
			/**Sana [ISAB 108][RBS][30-12-2010]**/
			CO_ProcMonitor(g_failurefile,"\nInternal Error Occured. Contact Support team.",NULL,NULL);
			/**End**/
		}
		else
		{
			EXEC SQL COMMIT;
			if (sqlca.sqlcode !=0)
			{
				/**sprintf(chr_g_log_buff,"T:Could Not Commit The Record\n");**/
				CO_ProcMonitor(g_logfile,"EntitleMent Generation :Could Not Commit The Record",NULL,NULL);
				/**Sana [ISAB 108][RBS][30-12-2010]**/
				CO_ProcMonitor(g_failurefile,"\nInternal Error Occured. Contact Support team.",NULL,NULL);
				/**End**/
			}
		}
		
		/**sprintf(chr_g_log_buff,"T:Entitlement Generation exiting with failure\n"); **/
		/**Sana [ISAB 108][RBS][30-12-2010]**/
		CO_ProcMonitor(g_logfile,"EntitleMent Generation :Exiting With Failure",l_debug_info_ptr,NULL);
		CO_ProcMonitor(g_failurefile,"Entitlement Generation :Exiting With Failure",l_debug_info_ptr,NULL);
		/**End**/
		if(g_logfile != APL_OUT_FILE)
			APL_CLOSE_FILE(g_logfile);
		/**Sana [ISAB 108][RBS][30-12-2010]**/
		if(g_failurefile != APL_OUT_FILE)
			APL_CLOSE_FILE(g_failurefile);
		/**End**/
		exit(-1);
	}
}

int CA_Proc_EntitlGen(	INTL_ENV_DATA_STRUCT_H	*p_intlenv_data_struct_h,
								char							**argv,
								DEBUG_INFO_STRUCT_H 		**l_debug_info_ptr)
{
	struct sqlca sqlca;
	char	chr_mainfuncarea_h	[APL_MAINFUNCAREA_LEN]	=	APL_NULL_STRING;
	char	chr_condid_h			[APL_CONDID_LEN]			=	APL_NULL_STRING;
	char 	chr_warn_cd_instrunauth[CA_ALERT_CODE_LEN] =	{ALERT_INSTR_UAUTH};
	char 	chr_warn_cd_instrnf[CA_ALERT_CODE_LEN] 		=	{ALERT_INSTR_NOTFND};
	/*Smita - HDFCCA_027 - Name Change Event*/
	char 	chr_warn_cd_cmpunauth[CA_ALERT_CODE_LEN] 	=	{ALERT_CMP_UAUTH};
	char 	chr_warn_cd_cmpnf[CA_ALERT_CODE_LEN] 		=	{ALERT_CMP_NOTFND};
	/*Smita - HDFCCA_027 - Name Change Event*/

	/*Smita - HDFCCA_009 - Buy Back Event*/
	char 	chr_warn_cd_DPunauth[CA_ALERT_CODE_LEN] 	=	{ALERT_DP_UAUTH};
	char 	chr_warn_cd_DPnf[CA_ALERT_CODE_LEN] 			=	{ALERT_DP_NOTFND};
	char  chr_warn_cd_InvalidCD[CA_ALERT_CODE_LEN] 	=	{ALERT_DEPO_INVALID};
	int   int_p_result=APL_SUCCESS; // AIX Warning
	/*Smita - HDFCCA_009 - Buy Back Event*/

	char 	chr_warn_cd_pstrecdt[CA_ALERT_CODE_LEN] 	=	{ALERT_PAST_RECDT};
	char 	chr_warn_cd_noposn[CA_ALERT_CODE_LEN] 		=	{BIDS_CONF_FILES_MAX};
	char 	chr_warn_cd_negposn[CA_ALERT_CODE_LEN] 		=	{AMENDHSN};
	char 	chr_warn_cd_norecman[CA_ALERT_CODE_LEN] 	=	{BIDS_OTHR_FILES_MAX};
	char 	chr_warn_cd_nordypmt[CA_ALERT_CODE_LEN] 	=	{BIDS_OTHR_FILE_START};
	short Cond_exists_h 	=	0;
	int	int_result 		=	0;
	int	int_curflg		=	0;
	int	int_init_flg	=	1;
	//Commented by sana short	i_dl_client		=	0;
	short i_dl_client[10000];
	
	short l_cond_gr 		= 	0; 
	
	int	int_h_count		=	0;
	int	int_period_flg1 =	0;		
	short	Trunc_Cond_exists_h	=	0;	
	
	FILE 	*l_repfile   	=  (FILE *)NULL;

	CA_CAENTITLEMENT_STRUCT_H	*l_ca_caentitlement_struct_h		=	(CA_CAENTITLEMENT_STRUCT_H *)NULL;
	CA_CAENTITLEMENT_STRUCT_I	*l_ca_caentitlement_struct_i		=	(CA_CAENTITLEMENT_STRUCT_I *)NULL;

	CA_CAENTITLEMENT_STRUCT_H	*l_ca_tbcaentitlement_struct_h	=	(CA_CAENTITLEMENT_STRUCT_H *)NULL;
	CA_CAENTITLEMENT_STRUCT_I	*l_ca_tbcaentitlement_struct_i	=	(CA_CAENTITLEMENT_STRUCT_I *)NULL;
	
	char	chr_sys_date_time[APL_DATE_LEN]	=	APL_NULL_STRING;
	char  h_evt_stat[APL_STATUS_LEN]			=	APL_NULL_STRING;
	char	h_instr_code[APL_INSTRUMENTCODE_LEN]	=	APL_NULL_STRING;
	char	typeofinstr[APL_INSTRU_TYPE_LEN]	=	APL_NULL_STRING;
	char	chr_reg_brind[APL_STATUS_LEN]		=	APL_NULL_STRING;
	char	last_pymt_date[APL_DATE_LEN]		=	APL_NULL_STRING;
	char	dateof_payment[APL_DATE_LEN]		=	APL_NULL_STRING;
	double	elig_entitl_pos=0.00;
	double	tot_elig_entitl_pos=0.0;	/* Added by Gouse for Prod Issue - ISKB_5945 */
	int	int_noacs 		=	0;
	int	entl_msg_cnt 	= 	0;
	
	char	chr_l_entstrpos[25]		=	APL_NULL_STRING;
 	char	chr_l_incstrdue[25]		=	APL_NULL_STRING;
	char	chr_l_qtystrdue[25]		=	APL_NULL_STRING;
   char  chr_l_oldentstrpos[25] 	=  APL_NULL_STRING;
   char  chr_l_oldincstrdue[25] 	=  APL_NULL_STRING;
   char  chr_l_oldqtystrdue[25] 	=  APL_NULL_STRING;
	char	chr_l_client_a[APL_CLIENT_LENGTH]			=	APL_NULL_STRING;
	char	chr_l_instrcode_a[APL_INSTRUMENTCODE_LEN]	=	APL_NULL_STRING;
	char	chr_stat[5]					=	APL_NULL_STRING;

	double	totquantity_bal 	= 	0.00;
	double	totamount_bal 		= 	0.00;
	double	round_val 			= 	0.00;
	int		int_date_diff		=	0;
	short		i_date_diff			=	0;	
	int		int_flg_entpos_negative = 0;
	int 		int_l_dummy			= 0;		
 double   totfract_due   =  0.00;

	double   l_custodytax_rate = 0.00;
	short    i_whtax_rate  		= 0;
	char		chr_tbl_ent_rowid[APL_ROWID_LEN] =  APL_NULL_STRING;

	if ( CO_RtvSysDt(chr_g_sys_date,l_debug_info_ptr)	== APL_FAILURE )
		APL_GOBACK_FAIL
	if ( CO_RtvSysDtTime(chr_g_sys_date_time,l_debug_info_ptr)	== APL_FAILURE )
		APL_GOBACK_FAIL

	sprintf(chr_g_log_buff,"T:Entitlement Generation Started on %s\n",chr_g_sys_date_time);
	CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
	/**Sana [ISAB 108][RBS][30-12-2010]**/
	CO_ProcMonitor(g_failurefile,chr_g_log_buff,NULL,NULL);
	/**End**/

	l_ca_caentitlement_struct_h	=	(CA_CAENTITLEMENT_STRUCT_H *)calloc(1,sizeof(CA_CAENTITLEMENT_STRUCT_H));
	APL_MALLOC_FAIL(l_ca_caentitlement_struct_h)

	l_ca_caentitlement_struct_i	=	(CA_CAENTITLEMENT_STRUCT_I *)calloc(1,sizeof(CA_CAENTITLEMENT_STRUCT_I));
	APL_MALLOC_FAIL(l_ca_caentitlement_struct_i)

	q_ca_caseceventstruct_h	=	(CA_CASECEVENT_STRUCT_H *)calloc(1,sizeof(CA_CASECEVENT_STRUCT_H));
	APL_MALLOC_FAIL(q_ca_caseceventstruct_h)

	l_ca_casecevent_struct_i	=	(CA_CASECEVENT_STRUCT_I *)calloc(1,sizeof(CA_CASECEVENT_STRUCT_I));
	APL_MALLOC_FAIL(l_ca_casecevent_struct_i)

	l_ca_tbcaentitlement_struct_h	=	(CA_CAENTITLEMENT_STRUCT_H *)calloc(1,sizeof(CA_CAENTITLEMENT_STRUCT_H));
	APL_MALLOC_FAIL(l_ca_tbcaentitlement_struct_h)

	l_ca_tbcaentitlement_struct_i	=	(CA_CAENTITLEMENT_STRUCT_I *)calloc(1,sizeof(CA_CAENTITLEMENT_STRUCT_I));
	APL_MALLOC_FAIL(l_ca_tbcaentitlement_struct_i)
	
	/**EXEC SQL VAR g_ca_caevent_struct_h.h_corp_id is string;
	EXEC SQL VAR g_ca_caevent_struct_h.h_instr_code is string;
	EXEC SQL VAR g_ca_caevent_struct_h.h_res_instr_code is string;
	EXEC SQL VAR g_position_h.h_dl_client is string;
	EXEC SQL VAR g_position_h.h_instr_code is string;
	EXEC SQL VAR l_ca_caentitlement_struct_h->h_maker is string;
	EXEC SQL VAR l_ca_caentitlement_struct_h->h_checker is string;
	EXEC SQL VAR chr_g_client is string;
	EXEC SQL VAR chr_g_splacc is string;
	EXEC SQL VAR chr_g_restart_data_h is string;

	EXEC SQL VAR g_ca_caevent_struct_h.h_start_date is string;
	EXEC SQL VAR g_ca_caevent_struct_h.h_rec_date is string; 
	EXEC SQL VAR g_ca_caevent_struct_h.h_effect_date is string;
	EXEC SQL VAR g_ca_caevent_struct_h.h_op_evt_class is string;
	EXEC SQL VAR l_ca_tbcaentitlement_struct_h->h_maker is string;
	EXEC SQL VAR l_ca_tbcaentitlement_struct_h->h_checker is string;
	EXEC SQL VAR l_ca_tbcaentitlement_struct_h->h_corp_id is string;
	EXEC SQL VAR l_ca_tbcaentitlement_struct_h->h_dl_client is string;
   EXEC SQL VAR chr_g_eventint_cutover_dt is string;
	EXEC SQL VAR chr_stat IS STRING;

	Its Done in Makefile -- Biju
	**/

	/* Added By Sana for entitlement opt -- start */
	int l_int_res_1 = 0;
	int l_int_res_2 = 0;
	EXEC SQL BEGIN DECLARE SECTION;
	int fetch_rows=0;
	int tot_rows=0;
	int break_flg=0;
	int temp_x=0;
	int i = 0;
	VARCHAR l_chr_client[50][APL_CLIENT_LENGTH];
	EXEC SQL END DECLARE SECTION;
	/* Added By Sana for entitlement opt -- end */

	EXEC SQL VAR g_ca_caevent_struct_h.h_instr_code is string;/*Smita - Entitlement Mnt*/
	#ifdef EMU_PROCESSING
         EXEC SQL SELECT FIELD_VAL
         INTO  :chr_g_splacc
         FROM PRO_GSSPLVAL
         WHERE MAIN_FUN='EMUCONV'
         AND   SUB_PROCESS='SPLACC'
         AND NATION=:g_mt_commonsys_params_struct_h.nation_code;
			
		 	IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,"SPECIAL A/C","FOR DIFF TRADE",APL_NULL_STRING)
		
			int_g_splacc_flg = 1; 
	#endif

   if(APL_FAILURE ==CO_Rtv_RptFileName("EN",
													"Entitlement Generation Report",
               								100,
               								argv[5],
               								argv,
               								&l_repfile,
               								l_debug_info_ptr))
   {
      CO_ProcMonitor(g_logfile,"Failure in opening the report h_file ",NULL,NULL);
      /**Sana [ISAB 108][RBS][30-12-2010]**/
      CO_ProcMonitor(g_failurefile,"\nInternal Error Occured. Contact Support team.",NULL,NULL);
      /**End**/
      APL_GOBACK_FAIL
   }
	else
	{
		EXEC SQL COMMIT;
		IS_ANY_ORA_ERROR
		CO_ProcMonitor(g_logfile,"Created Report ",NULL,NULL);
	}

   
fprintf(l_repfile,"\n");
fprintf(l_repfile,"Indicator   Instrode    Event Type    Sr No    Account              Old Ent Position          New Ent Position      Old Income/Qty Due         New-Income/Qty Due\n");
	fprintf(l_repfile,"-------------------------------------------------------------------------------------------------------------------------------------------------------------\n");

	
   if(APL_FAILURE == CO_Chk_CntryEnabled(	"EVNT_INIT",
                                          "EX_REC",
                                          &l_cond_gr,
                                          l_debug_info_ptr ))
   {
		CO_ProcMonitor(g_logfile,"Failed in CO_Chk_CntryEnabled ",NULL,NULL);
		/**Sana [ISAB 108][RBS][30-12-2010]**/
		CO_ProcMonitor(g_failurefile,"\nInternal Error Occured. Contact Support team.",NULL,NULL);
		/**End**/
   	APL_GOBACK_FAIL
   } 


 	EXEC SQL SELECT FIELD_VAL 
				INTO :chr_g_eventint_cutover_dt
 				FROM PRO_GSSPLVAL
 				WHERE MAIN_FUN 	= 'EVNT_INIT'
 				AND 	SUB_PROCESS = 'EVNTINT_CUTOVER_DT'
 				AND 	NATION 		= :g_mt_commonsys_params_struct_h.nation_code;

 	IS_ANY_ORA_ERROR

	fprintf(g_logfile,"Entitlement Generation :Cut over Date is |%s|\n",chr_g_eventint_cutover_dt);
	/* PJ Removed TO from cursor */
	/*Chirag Redemption - Put Option Event should not be picked up for Entitlement Generation Chk is put in to cursor */
		  
	  EXEC SQL SELECT SYS_DATE INTO :chr_g_sys_dt FROM PRO_SYS_DATE;
	  IS_ANY_ORA_ERROR

	if (l_cond_gr)
	{
		printf("entering AevntCur_ge_gr \n");
	/* Commented and rewritten By Sana for entitlement optimisation    EXEC SQL DECLARE AevntCur_ge_gr CURSOR FOR
   	SELECT * FROM CAEVENT
   	WHERE
   	(
      	 status  =  'RE'
   	OR
      	(corp_id IN (SELECT DISTINCT corp_id FROM CAEVENT,CABACKSETTLE WHERE
         	CABACKSETTLE.INSTRUMENT_DT <= CAEVENT.REC_DATE AND
         	CABACKSETTLE.instr_code = CAEVENT.instr_code AND
         	status in ('RP','PP') AND CAEVENT.CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO')))
   	OR
         (corp_id IN (SELECT DISTINCT corp_id FROM CAEVENT,dl_deal where
						  CAEVENT.MAKER_DT>= to_date(rtrim(:chr_g_eventint_cutover_dt))
                     and
                    (dl_deal.deal_date <= CAEVENT.REC_DATE OR
                  to_date(to_char(dl_deal.maker_dt,'DD/MM/YYYY')) >=
                  to_date(to_char(CAEVENT.REC_DATE,'DD/MM/YYYY')) )		
                  AND dl_deal.instr_code = CAEVENT.instr_code AND
                  CAEVENT.STATUS in ('RP','PP') AND CAEVENT.CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO')) )
		OR
			(
				corp_id IN (SELECT corp_id FROM CACHGEVENT WHERE CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO'))
			)
   	)
   	AND   (priority||corp_id   >= :chr_g_restart_ca_id)
   	FOR UPDATE NOWAIT
   	ORDER BY PRIORITY||corp_id ;*/
/*Retro from ICICI for filters on Entitlement Generation - Nitya - Starts*/

/*Retro from HDFC for Entitlement Generation Optimization - Swapnil - Starts*/
	EXEC SQL DECLARE AevntCur_ge_gr CURSOR FOR
	SELECT ca.* FROM CAEVENT ca
	WHERE ca.MAKER_DT      >= to_date(:chr_g_eventint_cutover_dt,'dd/mm/yyyy hh24:mi:ss') and 
	(
		(
			(status = 'RE' AND to_date(:chr_g_sys_dt,'dd/mm/yyyy hh24:mi:ss') >= REC_DATE )
		OR
			(exists (SELECT 1 FROM CABACKSETTLE 
						  WHERE CABACKSETTLE.INSTRUMENT_DT <= ca.REC_DATE AND
						  CABACKSETTLE.instr_code = ca.instr_code AND
						  ca.status in ('RP','PP') AND 
						  (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO')))
		OR
			 (exists (SELECT 1  FROM dl_deal 
					where (dl_deal.deal_date <= ca.REC_DATE //OR dl_deal.maker_dt >= ca.REC_DATE
					and (dl_deal.maker_dt = Get_Prv_BussinessDate(:chr_g_sys_dt,1) OR 
					trunc(dl_deal.maker_dt) = :chr_g_sys_dt ))	/* Added by Pravin for SNOW -  CS0119164 */				
					and ca.CA_EVENT !='OP' 
					and dl_deal.dl_class not in ('18','19')
                    and dl_deal.instr_code = ca.instr_code 
					and ca.STATUS in ('RP','PP') 
					and (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO')) )
			OR
				(
					exists (SELECT 1 FROM CACHGEVENT where CACHGEVENT.corp_id = ca.corp_id and (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO') )
				)
		)
		AND   (priority||corp_id   >= :chr_g_restart_ca_id) 
		//Added by Sudhir K. ON 01/10/2015 for ISBK_8537 (reverse CD event should not be picked up in Entitelmetn generation process)- START
		AND status != 'RV'
		AND	preliminary_flag='N')
		//Added by Sudhir K. ON 01/10/2015 for ISBK_8537 (reverse CD event should not be picked up in Entitelmetn generation process)- END
		//Commented and Rewritten for ISKB_6221(CA_GenEntitl process is not getting completed)-START
		AND CA_EVENT = DECODE(0,:flag_g_event_type,CA_EVENT,:g_event_type)
		AND INSTR_CODE= DECODE(0,:flag_g_instr_code_t,INSTR_CODE,:g_instr_code_t)
		AND EX_DATE >= DECODE(0,:flag_g_ex_dt,EX_DATE,to_date(:g_ex_dt_f,'dd/mm/yyyy hh24:mi:ss'))
		AND EX_DATE <= DECODE(0,:flag_g_ex_dt,EX_DATE,to_date(:g_ex_dt_s,'dd/mm/yyyy hh24:mi:ss'))

		//FOR UPDATE NOWAIT
		FOR UPDATE
		//Commented and Rewritten for ISKB_6221(CA_GenEntitl process is not getting completed)-END
		
   	ORDER BY PRIORITY||corp_id ;
/*Retro from HDFC for Entitlement Generation Optimization - Swapnil - Ends*/
/*Retro from ICICI for filters on Entitlement Generation - Nitya - Ends*/
	   IS_ANY_ORA_ERROR
	}
	else
	{
		APL_IF_DEBUG
		{
			printf("Entering Cursor AevntCur_ge\n");
		}
		/*Commented and rewritten by Sana for entitlement opt EXEC SQL DECLARE AevntCur_ge CURSOR FOR 
		SELECT * FROM CAEVENT 
		WHERE 	
		(
			 status       			=	'RE' 
		OR
			(corp_id IN (SELECT DISTINCT corp_id FROM CAEVENT,CABACKSETTLE WHERE
				CABACKSETTLE.INSTRUMENT_DT <= CAEVENT.REC_DATE AND
				CABACKSETTLE.instr_code = CAEVENT.instr_code AND
				status in ('RP','PP') AND CAEVENT.CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO')))
		OR
			(corp_id IN (SELECT DISTINCT corp_id FROM CAEVENT,dl_deal where
						CAEVENT.MAKER_DT>= to_date(rtrim(:chr_g_eventint_cutover_dt))
                  and
                  (dl_deal.deal_date <= CAEVENT.EX_DATE OR
                  to_date(to_char(dl_deal.maker_dt,'DD/MM/YYYY')) >=
                  to_date(to_char(CAEVENT.EX_DATE,'DD/MM/YYYY')) )
						AND dl_deal.instr_code = CAEVENT.instr_code AND
						CAEVENT.CA_EVENT!='OP' and 
						CAEVENT.STATUS in ('RP','PP') AND CAEVENT.CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO')) )
      OR
         (corp_id IN (SELECT DISTINCT corp_id FROM CAEVENT,dl_deal where
						CAEVENT.MAKER_DT>= to_date(rtrim(:chr_g_eventint_cutover_dt))
                  and
                  (dl_deal.deal_date <= CAEVENT.REC_DATE OR
                  to_date(to_char(dl_deal.maker_dt,'DD/MM/YYYY')) >=
                  to_date(to_char(CAEVENT.REC_DATE,'DD/MM/YYYY')) )
                  and CAEVENT.CA_EVENT='OP'
                  AND dl_deal.instr_code = CAEVENT.instr_code AND
                  CAEVENT.STATUS in ('RP','PP') AND CAEVENT.CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO')) )
		OR
			(
				corp_id IN (SELECT corp_id FROM CACHGEVENT WHERE CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO'))
			)
		)
		AND	(priority||corp_id	>= :chr_g_restart_ca_id)
		FOR UPDATE NOWAIT
		ORDER BY PRIORITY||corp_id ;*/
/*Retro from ICICI for filters on Entitlement Generation - Nitya - Starts*/
/*Retro from HDFC for Entitlement Generation Optimization - Swapnil - Starts*/
		EXEC SQL DECLARE AevntCur_ge CURSOR FOR 
		SELECT ca.* FROM CAEVENT ca
		WHERE ca.MAKER_DT >= to_date(:chr_g_eventint_cutover_dt,'dd/mm/yyyy hh24:mi:ss') and 
		((
				 (status = 'RE' AND to_date(:chr_g_sys_dt,'dd/mm/yyyy hh24:mi:ss') >= EX_DATE )
			OR
				(exists (SELECT 1 FROM CABACKSETTLE 
							  WHERE CABACKSETTLE.INSTRUMENT_DT <= ca.EX_DATE AND
							  CABACKSETTLE.instr_code = ca.instr_code AND
							  ca.status in ('RP','PP') AND 
							  (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO')))
			OR
				 (exists (SELECT 1  FROM dl_deal 
					where (dl_deal.deal_date <= ca.EX_DATE 
					AND ( dl_deal.maker_dt = Get_Prv_BussinessDate(:chr_g_sys_dt,1)
					OR dl_deal.maker_dt = to_date(:chr_g_sys_dt,'dd/mm/yyyy hh24:mi:ss') ) )
					AND ca.CA_EVENT !='OP' 
					AND dl_deal.dl_class not in ('18','19')
                    AND dl_deal.instr_code = ca.instr_code 
					AND ca.STATUS in ('RP','PP') 
					AND (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO') ) )
			OR
				/* (exists (SELECT 1 FROM dl_deal where 
						
					(dl_deal.deal_date <= ca.REC_DATE 
					OR to_date(to_char(dl_deal.maker_dt,'DD/MM/YYYY')) >= to_date(to_char(ca.REC_DATE,'DD/MM/YYYY')) 
					AND (dl_deal.maker_dt = Get_Prv_BussinessDate(:chr_g_sys_dt,1)  
					OR dl_deal.maker_dt = to_date(:chr_g_sys_dt,'dd/mm/yyyy hh24:mi:ss') ))
					AND dl_deal.dl_class not in ('18','19')	
					AND ca.CA_EVENT ='OP' 								
					AND dl_deal.instr_code = ca.instr_code 
					AND ca.STATUS in ('RP','PP') 
				  AND (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO')))
			OR */
					(
						exists (SELECT 1 FROM CACHGEVENT where CACHGEVENT.corp_id = ca.corp_id and (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO') )
					)
		)
		AND   (priority||corp_id   >= :chr_g_restart_ca_id) 
		//Added by Sudhir K. ON 01/10/2015 for ISBK_8537 (reverse CD event should not be picked up in Entitelmetn generation process)- START
		AND status != 'RV'
		AND	preliminary_flag='N')
		//Added by Sudhir K. ON 01/10/2015 for ISBK_8537 (reverse CD event should not be picked up in Entitelmetn generation process)- END
		//Commented and Rewritten for ISKB_6221(CA_GenEntitl process is not getting completed)-START

		AND CA_EVENT = DECODE(0,:flag_g_event_type,CA_EVENT,:g_event_type)
		AND INSTR_CODE= DECODE(0,:flag_g_instr_code_t,INSTR_CODE,:g_instr_code_t)
		AND EX_DATE >= DECODE(0,:flag_g_ex_dt,EX_DATE,to_date(:g_ex_dt_f,'dd/mm/yyyy hh24:mi:ss'))
		AND EX_DATE <= DECODE(0,:flag_g_ex_dt,EX_DATE,to_date(:g_ex_dt_s,'dd/mm/yyyy hh24:mi:ss'))

		//FOR UPDATE NOWAIT
		FOR UPDATE
		//Commented and Rewritten for ISKB_6221(CA_GenEntitl process is not getting completed)-END							
		ORDER BY PRIORITY||corp_id ;

		IS_ANY_ORA_ERROR
/*Retro from HDFC for Entitlement Generation Optimization - Swapnil - Ends*/		
/*Retro from ICICI for filters on Entitlement Generation - Nitya - Ends*/
	}

if (l_cond_gr)
	{
	printf("entering AevntCur_gt_gr \n");

   /*Commented and rewitten by sana for ent optimization EXEC SQL DECLARE AevntCur_gt_gr CURSOR FOR
   	SELECT * FROM CAEVENT
   	WHERE
   	(
      	 status       =  'RE'
   	OR
      	(corp_id IN (SELECT DISTINCT corp_id FROM CAEVENT,CABACKSETTLE WHERE
         	CABACKSETTLE.INSTRUMENT_DT <= CAEVENT.REC_DATE AND
         	CABACKSETTLE.instr_code = CAEVENT.instr_code AND
         	status in ('RP','PP') AND CAEVENT.CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO')))  
   	OR
         (corp_id IN (SELECT DISTINCT corp_id FROM CAEVENT,dl_deal where
						CAEVENT.MAKER_DT>= to_date(rtrim(:chr_g_eventint_cutover_dt))
                  and
						(dl_deal.deal_date <= CAEVENT.REC_DATE OR
                  to_date(to_char(dl_deal.maker_dt,'DD/MM/YYYY')) >=
                  to_date(to_char(CAEVENT.REC_DATE,'DD/MM/YYYY')) )
                  AND dl_deal.instr_code = CAEVENT.instr_code AND
                  CAEVENT.STATUS in ('RP','PP') AND CAEVENT.CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO')) )
		OR
         (
            corp_id IN (SELECT corp_id FROM CACHGEVENT WHERE CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO'))
         )	
   	)
   	AND   (priority||corp_id   > :chr_g_restart_ca_id)
   	FOR UPDATE NOWAIT
   	ORDER BY priority||corp_id ;*/
/*Retro from ICICI for filters on Entitlement Generation - Nitya - Starts*/
/*Retro from HDFC for Entitlement Generation Optimization - Swapnil - Starts*/
	EXEC SQL DECLARE AevntCur_gt_gr CURSOR FOR
	SELECT ca.* FROM CAEVENT ca
	WHERE ca.MAKER_DT >= to_date(:chr_g_eventint_cutover_dt,'dd/mm/yyyy hh24:mi:ss') and 
	((
			 (status = 'RE' AND to_date(:chr_g_sys_dt,'dd/mm/yyyy hh24:mi:ss') >= REC_DATE ) 
		OR
			(exists (SELECT 1 FROM CABACKSETTLE 
						  WHERE CABACKSETTLE.INSTRUMENT_DT <= ca.REC_DATE AND
						  CABACKSETTLE.instr_code = ca.instr_code AND
						  ca.status in ('RP','PP') AND 
						  (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO')))
		OR
			 (exists (SELECT 1  FROM dl_deal 
						  where 
							(dl_deal.deal_date <= ca.REC_DATE //OR dl_deal.maker_dt >= ca.REC_DATE	
							AND (dl_deal.maker_dt = Get_Prv_BussinessDate(:chr_g_sys_dt,1) 
							OR trunc(dl_deal.maker_dt) = :chr_g_sys_dt ))	/* Added by Pravin for SNOW -  CS0119164 */
							AND ca.CA_EVENT !='OP'
							AND dl_deal.dl_class not in ('18','19')
							AND dl_deal.instr_code = ca.instr_code 
							AND ca.STATUS in ('RP','PP') 
						  AND (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO')) )
			OR
				(
					exists (SELECT 1 FROM CACHGEVENT where CACHGEVENT.corp_id = ca.corp_id and (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO') )
				)
		)
		AND   (priority||corp_id   > :chr_g_restart_ca_id) 
		//Added by Sudhir K. ON 01/10/2015 for ISBK_8537 (reverse CD event should not be picked up in Entitelmetn generation process)- START
		AND status != 'RV'
		AND	preliminary_flag='N')
		//Added by Sudhir K. ON 01/10/2015 for ISBK_8537 (reverse CD event should not be picked up in Entitelmetn generation process)- END

		//Commented and Rewritten for ISKB_6221(CA_GenEntitl process is not getting completed)-START

		AND CA_EVENT = DECODE(0,:flag_g_event_type,CA_EVENT,:g_event_type)
		AND INSTR_CODE= DECODE(0,:flag_g_instr_code_t,INSTR_CODE,:g_instr_code_t)
		AND EX_DATE >= DECODE(0,:flag_g_ex_dt,EX_DATE,to_date(:g_ex_dt_f,'dd/mm/yyyy hh24:mi:ss'))
		AND EX_DATE <= DECODE(0,:flag_g_ex_dt,EX_DATE,to_date(:g_ex_dt_s,'dd/mm/yyyy hh24:mi:ss'))
		//FOR UPDATE NOWAIT
		FOR UPDATE
		//Commented and Rewritten for ISKB_6221(CA_GenEntitl process is not getting completed)-END	
   		ORDER BY PRIORITY||corp_id;


	   IS_ANY_ORA_ERROR
/*Retro from HDFC for Entitlement Generation Optimization - Swapnil - Ends */	   
/*Retro from ICICI for filters on Entitlement Generation - Nitya - Ends*/
	}
else
	{
	/*Commented and rewitten by Sana for entitlement opt EXEC SQL DECLARE AevntCur_gt CURSOR FOR 
	SELECT * FROM CAEVENT 
	WHERE 	
	(
		 status       =	'RE' 
	OR
		(corp_id IN (SELECT DISTINCT corp_id FROM CAEVENT,CABACKSETTLE WHERE
			CABACKSETTLE.INSTRUMENT_DT <= CAEVENT.REC_DATE AND
			CABACKSETTLE.instr_code = CAEVENT.instr_code AND
			status in ('RP','PP') AND CAEVENT.CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO')))  
   OR
         (corp_id IN (SELECT DISTINCT corp_id FROM CAEVENT,dl_deal where
							CAEVENT.MAKER_DT>= to_date(rtrim(:chr_g_eventint_cutover_dt))
                  and
							(dl_deal.deal_date <= CAEVENT.EX_DATE OR
                  to_date(to_char(dl_deal.maker_dt,'DD/MM/YYYY')) >=
                  to_date(to_char(CAEVENT.EX_DATE,'DD/MM/YYYY')) )
						and CAEVENT.CA_EVENT!='OP'
                  AND dl_deal.instr_code = CAEVENT.instr_code AND
                  CAEVENT.STATUS in ('RP','PP') AND CAEVENT.CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO')) )
   OR
         (corp_id IN (SELECT DISTINCT corp_id FROM CAEVENT,dl_deal where
						  CAEVENT.MAKER_DT>= to_date(rtrim(:chr_g_eventint_cutover_dt))
                  and
                     (dl_deal.deal_date <= CAEVENT.REC_DATE OR
                  to_date(to_char(dl_deal.maker_dt,'DD/MM/YYYY')) >=
                  to_date(to_char(CAEVENT.REC_DATE,'DD/MM/YYYY')) )
                  and CAEVENT.CA_EVENT='OP'
                  AND dl_deal.instr_code = CAEVENT.instr_code AND
                  CAEVENT.STATUS in ('RP','PP') AND CAEVENT.CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO')) )
	OR
      (
         corp_id IN (SELECT corp_id FROM CACHGEVENT WHERE CORP_ID NOT IN (SELECT CORP_ID FROM CAEVENT WHERE OP_EVT_CLASS = 'PO'))
      )
	)
	AND	(priority||corp_id	> :chr_g_restart_ca_id)
	FOR UPDATE NOWAIT
	ORDER BY priority||corp_id ;*/
/*Retro from ICICI for filters on Entitlement Generation - Nitya - Starts*/
/*Retro from HDFC for Entitlement Generation Optimization - Swapnil - Starts*/

		EXEC SQL DECLARE AevntCur_gt CURSOR FOR 
		SELECT ca.* FROM CAEVENT ca
		WHERE ca.MAKER_DT >= to_date(:chr_g_eventint_cutover_dt,'dd/mm/yyyy hh24:mi:ss') and 
		((
				 (status = 'RE' AND to_date(:chr_g_sys_dt,'dd/mm/yyyy hh24:mi:ss') >= EX_DATE )
			OR
				(exists (SELECT 1 FROM CABACKSETTLE 
							  WHERE CABACKSETTLE.INSTRUMENT_DT <= ca.EX_DATE AND
							  CABACKSETTLE.instr_code = ca.instr_code AND
							  ca.status in ('RP','PP') AND 
							  (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO')))
			OR
				(exists (SELECT 1  FROM dl_deal 
					where (dl_deal.deal_date <= ca.EX_DATE 
					AND ( dl_deal.maker_dt = Get_Prv_BussinessDate(:chr_g_sys_dt,1)
					OR dl_deal.maker_dt = to_date(:chr_g_sys_dt,'dd/mm/yyyy hh24:mi:ss') ) )
					AND ca.CA_EVENT !='OP' 
					AND dl_deal.dl_class not in ('18','19')
                    AND dl_deal.instr_code = ca.instr_code 
					AND ca.STATUS in ('RP','PP') 
					AND (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO') ) )
			/* OR
				(exists (SELECT 1 FROM dl_deal where 
				  (dl_deal.deal_date <= ca.REC_DATE OR
				  to_date(to_char(dl_deal.maker_dt,'DD/MM/YYYY')) >=
					to_date(to_char(ca.REC_DATE,'DD/MM/YYYY')) 	
					AND (dl_deal.maker_dt = Get_Prv_BussinessDate(:chr_g_sys_dt,1)  
					OR dl_deal.maker_dt = to_date(:chr_g_sys_dt,'dd/mm/yyyy hh24:mi:ss') ))
					AND dl_deal.dl_class not in ('18','19')	  				  				  
				  and ca.CA_EVENT='OP'
				  AND dl_deal.instr_code = ca.instr_code AND
				  ca.STATUS in ('RP','PP') 
					AND (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO'))) */
			OR
					(
						exists (SELECT 1 FROM CACHGEVENT where CACHGEVENT.corp_id = ca.corp_id and (ca.OP_EVT_CLASS IS NULL OR ca.OP_EVT_CLASS <> 'PO') )
					)
			)
			AND   (priority||corp_id   > :chr_g_restart_ca_id) 
			//Added by Sudhir K. ON 01/10/2015 for ISBK_8537 (reverse CD event should not be picked up in Entitelmetn generation process)- START
			AND status != 'RV'
			AND	preliminary_flag='N')
			//Added by Sudhir K. ON 01/10/2015 for ISBK_8537 (reverse CD event should not be picked up in Entitelmetn generation process)- END
			//Commented and Rewritten for ISKB_6221(CA_GenEntitl process is not getting completed)-START
			AND CA_EVENT = DECODE(0,:flag_g_event_type,CA_EVENT,:g_event_type)
			AND INSTR_CODE= DECODE(0,:flag_g_instr_code_t,INSTR_CODE,:g_instr_code_t)
			AND EX_DATE >= DECODE(0,:flag_g_ex_dt,EX_DATE,to_date(:g_ex_dt_f,'dd/mm/yyyy hh24:mi:ss'))
			AND EX_DATE <= DECODE(0,:flag_g_ex_dt,EX_DATE,to_date(:g_ex_dt_s,'dd/mm/yyyy hh24:mi:ss'))
			//FOR UPDATE NOWAIT
			FOR UPDATE
			//Commented and Rewritten for ISKB_6221(CA_GenEntitl process is not getting completed)-END		  
			ORDER BY PRIORITY||corp_id;
/*Retro from HDFC for Entitlement Generation Optimization - Swapnil - Ends */			
/*Retro from ICICI for filters on Entitlement Generation - Nitya - Starts*/

	IS_ANY_ORA_ERROR

		printf(" Post HM : AevntCur_ge_gr : %s \n",chr_g_sys_dt);
	}

	 

	IS_ANY_ORA_ERROR
/**
	EXEC SQL SELECT RESTART_DATA 
				INTO :chr_g_restart_data_h:g_restart_data_i
				FROM BT_PROCESS_STATUS
				WHERE PROCESS_NAME	=:chr_g_progname
				AND	PROCESS_KEY		=:chr_g_key
				AND	START_DATE		=:chr_g_start_date
				AND 	STATUS			='started'
	FOR UPDATE OF STATUS_INFO,STATUS;

	IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,"BT_PROCESS_STATUS",chr_g_progname,chr_g_key)
	**/
	
	EXEC SQL SELECT /*+FIRST_ROWS(10)*/ processing_status INTO :chr_g_restart_data_h:g_restart_data_i
		FROM SYS_BATCHPROC
		WHERE process_name	=:chr_g_progname
		AND	proc_init		=:chr_g_key
		AND	STARTDATE=:chr_g_start_date
		AND 	status	='started'
		FOR UPDATE OF processing_status,status;
	IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,"SYS_BATCHPROC",chr_g_progname,chr_g_key)

	if (g_restart_data_i == -1)
	{
		strcpy(chr_g_restart_ca_id,	" ");
		strcpy(chr_g_restart_client,	" ");
	}
	else
	{
		strcpy(chr_g_tmp_restart_data,	chr_g_restart_data_h);
		strcpy(chr_g_restart_ca_id,		strtok(chr_g_tmp_restart_data,S_RESTART_SEP_TOKEN));
		strcpy(chr_g_restart_client, 	strtok(NULL,S_RESTART_SEP_TOKEN));
	}

	if (l_cond_gr)
	{
		printf("opeing AevntCur_ge_gr \n");
		EXEC SQL OPEN AevntCur_ge_gr;
		IS_ANY_ORA_ERROR
	}
	else
	{
		EXEC SQL OPEN AevntCur_ge;
		IS_ANY_ORA_ERROR
	}

	for(;;)
	{  
		memset(&g_ca_caevent_struct_h,NULL,sizeof(CA_CAEVENT_STRUCT_H)); /* UAT Fix */
		if ( int_init_flg == 1 )
		{
			if (l_cond_gr)
			{
			printf(" fetching AevntCur_ge_gr\n");
			EXEC SQL FETCH AevntCur_ge_gr INTO 
			:g_ca_caevent_struct_h:g_ca_caevent_struct_i;

			IS_ANY_ORA_ERROR_CURSOR
			int_init_flg = 0;
			}
			else
			{
				Alert("Fetching Qual Cursor");
			EXEC SQL FETCH AevntCur_ge INTO
			:g_ca_caevent_struct_h:g_ca_caevent_struct_i;
			
			if (sqlca.sqlcode==1403)
				Alert("No records in fetch of AevtCur_ge\n");
			IS_ANY_ORA_ERROR_CURSOR
			int_init_flg = 0;
			} 
		}
		else
		{
			if (l_cond_gr)
			{
			printf(" fetching AevntCur_gt_gr\n");
			EXEC SQL FETCH AevntCur_gt_gr INTO 
			:g_ca_caevent_struct_h:g_ca_caevent_struct_i;
			Alert("Sqlca |%d|",sqlca.sqlcode);
			IS_ANY_ORA_ERROR_CURSOR
			}
			else
			{
					Alert("Fetching Gt Cursor. Restart value is : |%s|",chr_g_restart_ca_id);
			EXEC SQL FETCH AevntCur_gt INTO
			:g_ca_caevent_struct_h:g_ca_caevent_struct_i;

			Alert("Sqlca |%d|",sqlca.sqlcode);
			IS_ANY_ORA_ERROR_CURSOR
			}		
		}
		tot_elig_entitl_pos=0.0; //Added by Gouse for Prod Issue ISKB_5945
		
				Alert("Selecting from cachgevent");
		int_g_flg_mod_event = 0;
      EXEC SQL SELECT nvl(count(*),0) INTO :int_g_flg_mod_event FROM CACHGEVENT
               WHERE corp_id = :g_ca_caevent_struct_h.h_corp_id;
      IS_ANY_ORA_ERROR
		
				Alert("before chkinstrument");

      if ( CA_ChkInstrument( g_ca_caevent_struct_h.h_instr_code,
                     &l_mt_instrument_struct_h,
                     &int_result,
                     l_debug_info_ptr) == APL_FAILURE)
         APL_GOBACK_FAIL
		printf("Nominal val After chk instrument is |%lf| *******************\n",l_mt_instrument_struct_h.h_nominal_value);		
      CO_FreeErrLst(l_debug_info_ptr);
      if ( int_result == ERR_INSTR_NOTFND )
      {
         EXEC SQL ROLLBACK;
		/* Commented by Swapnil for Entitlement Optimization Changes Starts 
         CA_WriteAlert((&l_ca_canotify_struct_h),
                        chr_g_funccode,
                        chr_warn_cd_instrnf,
                        g_ca_caevent_struct_h.h_corp_id,
                        APL_NULL_STRING,
                        g_ca_caevent_struct_h.h_instr_code)
         EXEC SQL COMMIT;
		 */
				 /* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,
         "  E:Instrument %s does not exist,skipping event\n",g_ca_caevent_struct_h.h_instr_code);
				 CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
				/**Sana [ISAB 108][RBS][30-12-2010]**/
				sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Instrument %s does not exist\n",g_ca_caevent_struct_h.h_corp_id,g_ca_caevent_struct_h.h_instr_code);
				CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				/**End**/
         if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
            APL_GOBACK_FAIL
         else
            continue;
      }
      if ( int_result == ERR_UNAUTH_INSTR )
      {
         	/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/	
         EXEC SQL ROLLBACK;
        /* CA_WriteAlert((&l_ca_canotify_struct_h),
                        chr_g_funccode,
                        chr_warn_cd_instrunauth,
                        g_ca_caevent_struct_h.h_corp_id,
                        APL_NULL_STRING,
                        g_ca_caevent_struct_h.h_instr_code)
         EXEC SQL COMMIT;
		 */	 
				 /* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,
         "  E:Instrument %s unauthorised ,skipping event\n",l_mt_instrument_struct_h.h_instr_code);
				 CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
				/**Sana [ISAB 108][RBS][30-12-2010]**/
				sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Instrument %s unauthorised \n",g_ca_caevent_struct_h.h_corp_id,l_mt_instrument_struct_h.h_instr_code);
				CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				/**End**/
         if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
            APL_GOBACK_FAIL
         else
            continue;
      }


		memset(q_ca_caseceventstruct_h,NULL,sizeof(CA_CASECEVENT_STRUCT_H));
		memset(l_ca_casecevent_struct_i,NULL,sizeof(CA_CASECEVENT_STRUCT_I));
		
		if (strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_BOND) == 0)
		{
			printf("Printing INCOME %lf\n",g_ca_caevent_struct_h.h_earnings);
			printf("Printing INCOME_RT %lf\n",g_ca_caevent_struct_h.h_earnings_rt);
			if (g_ca_caevent_struct_h.h_earnings_rt > 0)
			{
				if ( CA_RtvInstrEvnt("FMT",
                             g_ca_caevent_struct_h.h_evt_class,
                             q_ca_caseceventstruct_h,
                             l_debug_info_ptr) == APL_FAILURE)
              APL_GOBACK_FAIL
              CO_FreeErrLst(l_debug_info_ptr);
              int_result = 0;
			}
			else 
			{
				           if ( CA_RtvInstrEvnt("FMT",
                             g_ca_caevent_struct_h.h_evt_class,
                             q_ca_caseceventstruct_h,
                             l_debug_info_ptr) == APL_FAILURE)
              APL_GOBACK_FAIL
              CO_FreeErrLst(l_debug_info_ptr);
              int_result = 0;
			}
		}
		else
		{
			   if ( CA_RtvInstrEvnt( l_mt_instrument_struct_h.h_instr_type,
   			                  g_ca_caevent_struct_h.h_evt_class,
      	   		            q_ca_caseceventstruct_h,
         	      		      l_debug_info_ptr) == APL_FAILURE)
      			APL_GOBACK_FAIL
   				CO_FreeErrLst(l_debug_info_ptr);
   				int_result = 0;
		}
/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/
	/*	if ( (strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_OFFER) == 0) &&
			  (strcmp(g_ca_caevent_struct_h.h_op_evt_class,"TO") == 0) )
		{
      
         if (strcmp(g_ca_caevent_struct_h.h_rec_date,APL_NULL_STRING) != 0)
         {
            EXEC SQL SELECT TO_DATE(:chr_g_sys_date) - TO_DATE(:g_ca_caevent_struct_h.h_rec_date)
            INTO :int_date_diff :i_date_diff from dual;
            IS_ANY_ORA_ERROR
         }
			else if (strcmp(g_ca_caevent_struct_h.h_start_date,APL_NULL_STRING) != 0)
			{
				EXEC SQL SELECT TO_DATE(:chr_g_sys_date) - TO_DATE(:g_ca_caevent_struct_h.h_start_date)
				INTO :int_date_diff :i_date_diff from dual;
				IS_ANY_ORA_ERROR
			}
			else
			{
				EXEC SQL SELECT TO_DATE(:chr_g_sys_date) - TO_DATE(:g_ca_caevent_struct_h.h_effect_date)
				INTO :int_date_diff :i_date_diff from dual;
				IS_ANY_ORA_ERROR
			}
		}
		else  */
			/* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/
		if ( (!strcmp(q_ca_caseceventstruct_h->h_entitl_base, ENTL_BASE_DL)) && 
						(strcmp(g_ca_caevent_struct_h.h_evt_class,"OP")))
		{
			if (l_cond_gr)
			{
				printf("record chr_date for this record is %s\n",g_ca_caevent_struct_h.h_rec_date);
				EXEC SQL SELECT TO_DATE(:chr_g_sys_date) - TO_DATE(:g_ca_caevent_struct_h.h_rec_date)
				INTO :int_date_diff :i_date_diff from dual;
				IS_ANY_ORA_ERROR
			}
			else
			{
				printf("ex chr_date for this record is %s\n",g_ca_caevent_struct_h.h_ex_date);
				printf("sys date is %s\n",chr_g_sys_date);
				printf("int_date_diff is %d\n",int_date_diff );
				printf("i_date_diff is %d\n",i_date_diff );
				printf("g_ca_caevent_struct_h.h_corp_id id %s\n",g_ca_caevent_struct_h.h_corp_id);
            EXEC SQL SELECT TO_DATE(:chr_g_sys_date) - TO_DATE(:g_ca_caevent_struct_h.h_ex_date)
            INTO :int_date_diff :i_date_diff from dual;
            IS_ANY_ORA_ERROR
			}
		}
		/*Smita - HDFCCA_027 - Check Effective Date*/
		/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/
	/*	else if (strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_NM_CHNG) == 0)
		{
			APL_IF_DEBUG
			{
				printf("Effective Date Required for Name Change = |%s|\n",g_ca_caevent_struct_h.h_effect_date);
			}
			EXEC SQL SELECT TO_DATE(:chr_g_sys_date) - TO_DATE(:g_ca_caevent_struct_h.h_effect_date)
				INTO :int_date_diff :i_date_diff from dual;
			IS_ANY_ORA_ERROR
		}
		*/
		/* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/
		/*Smita - HDFCCA_027 - Check Effective Date*/
		/*Smita - HDFCCA_009 - Check Ex Date*/
		else if (strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_BUY_BACK) == 0)
		{
			APL_IF_DEBUG
			{
				printf("Corp ID = |%s|\n",g_ca_caevent_struct_h.h_corp_id);
				printf("Ex-Date for Buy Back Event = |%s|\n",g_ca_caevent_struct_h.h_ex_date);
				printf("EX-Date BSE for Buy Back Event = |%s|\n",g_ca_caevent_struct_h.h_ex_dt_bse);
			}
			EXEC SQL SELECT TO_DATE(:chr_g_sys_date) - TO_DATE(:g_ca_caevent_struct_h.h_ex_date)
					INTO :int_date_diff :i_date_diff from dual;
			IS_ANY_ORA_ERROR
		}
		/*Smita - HDFCCA_009 - Check Ex Date*/
		else 
		{
			EXEC SQL SELECT TO_DATE(:chr_g_sys_date) - TO_DATE(:g_ca_caevent_struct_h.h_rec_date)
			INTO :int_date_diff :i_date_diff from dual;
			IS_ANY_ORA_ERROR
		}
		int_g_date_diff=0;
		int_g_date_diff=int_date_diff;
		if(int_date_diff > 0)
		{
		/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/	
			EXEC SQL ROLLBACK;
		/*	CA_WriteAlert((&l_ca_canotify_struct_h),
								chr_g_funccode,
								chr_warn_cd_pstrecdt,
								g_ca_caevent_struct_h.h_corp_id,
								APL_NULL_STRING,
								g_ca_caevent_struct_h.h_instr_code)
			EXEC SQL COMMIT;
			*/
				 /* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/
		}
		else if (int_date_diff < 0)
		{
			/*Smita - HDFCCA_027 - Added Effective Date*/
				 /* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,
         "  E:Ex Date/Rec Date/Effctive Date is greater than system chr_date  for %s  for event %s,skipping event\n",l_mt_instrument_struct_h.h_instr_code,g_ca_caevent_struct_h.h_corp_id);
				 CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
					/**Sana [ISAB 108][RBS][30-12-2010]**/
				 sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason :  Ex Date/Rec Date/Effctive Date is greater than system date for %s\n",g_ca_caevent_struct_h.h_corp_id,l_mt_instrument_struct_h.h_instr_code);
				 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);	
					/**End**/
         if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
            APL_GOBACK_FAIL
         else
            continue;
		}
		
		sprintf(chr_g_log_buff,"T:Processing event %s",g_ca_caevent_struct_h.h_corp_id);
	 	CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
		int_result = 0;
/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/	
 	/*	if ( CA_ChkInstrument(	g_ca_caevent_struct_h.h_instr_code,
					 		&l_mt_instrument_struct_h,
					 		&int_result,
					 		l_debug_info_ptr) == APL_FAILURE)
	 		APL_GOBACK_FAIL
 		CO_FreeErrLst(l_debug_info_ptr);
 		if ( int_result == ERR_INSTR_NOTFND )
 		{
			
			EXEC SQL ROLLBACK;
			CA_WriteAlert((&l_ca_canotify_struct_h),
								chr_g_funccode,
								chr_warn_cd_instrnf,
								g_ca_caevent_struct_h.h_corp_id,
								APL_NULL_STRING,
								g_ca_caevent_struct_h.h_instr_code)
			EXEC SQL COMMIT;
			*/				
					/* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,
	 		"	E:Instrument %s does not exist,skipping event\n",g_ca_caevent_struct_h.h_instr_code);
					CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
		/*			/**Sana [ISAB 108][RBS][30-12-2010]**/
	/*				sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Instrument %s does not exist\n",g_ca_caevent_struct_h.h_corp_id,g_ca_caevent_struct_h.h_instr_code);
					CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
					/**End**/
	/* 		if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
		 		APL_GOBACK_FAIL
			else
				continue;
 		}	
 		if ( int_result == ERR_UNAUTH_INSTR )
 		{
			
			EXEC SQL ROLLBACK;
			CA_WriteAlert((&l_ca_canotify_struct_h),
								chr_g_funccode,
								chr_warn_cd_instrunauth,
								g_ca_caevent_struct_h.h_corp_id,
								APL_NULL_STRING,
								g_ca_caevent_struct_h.h_instr_code)
			EXEC SQL COMMIT;
				*/
					/* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,
	 		"	E:Instrument %s unauthorised ,skipping event\n",l_mt_instrument_struct_h.h_instr_code);
					CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
					/**Sana [ISAB 108][RBS][30-12-2010]**/
	/*				sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Instrument %s unauthorised \n",g_ca_caevent_struct_h.h_corp_id,l_mt_instrument_struct_h.h_instr_code);
					CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
					/**End**/
	/* 		if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
		 		APL_GOBACK_FAIL
			else
				continue;
 		}
		*/
/* Commented by Swapnil for Entitlement Optimization Changes End */
	if( CA_RtvCCY( l_mt_instrument_struct_h.h_currency_cd,
						  	 &l_dl_currency_struct_h,
							 l_debug_info_ptr) == APL_FAILURE)
		APL_GOBACK_FAIL
	CO_FreeErrLst(l_debug_info_ptr);
	
 	if( (g_ca_caevent_struct_i.i_res_instr_code != -1) && 
			strcmp(g_ca_caevent_struct_h.h_instr_code, g_ca_caevent_struct_h.h_res_instr_code))
 	{
	 	if ( CA_ChkInstrument(	g_ca_caevent_struct_h.h_res_instr_code,
						 	&l_mt_resinstrument_struct_h,
						 	&int_result,
						 	l_debug_info_ptr) == APL_FAILURE)
		 	APL_GOBACK_FAIL
	 	CO_FreeErrLst(l_debug_info_ptr);
	 	if ( int_result == ERR_INSTR_NOTFND )
	 	{
				/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/	
			EXEC SQL ROLLBACK;
			/* CA_WriteAlert((&l_ca_canotify_struct_h),
								chr_g_funccode,
								chr_warn_cd_instrnf,
								g_ca_caevent_struct_h.h_corp_id,
								APL_NULL_STRING,
								g_ca_caevent_struct_h.h_res_instr_code)
			EXEC SQL COMMIT;
			*/	 /* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/	
					/* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,
		 	"	E:Instrument %s does not exist,skipping event\n",
											 	g_ca_caevent_struct_h.h_res_instr_code);
					CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
					/**Sana [ISAB 108][RBS][30-12-2010]**/
					sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Resultant Instrument %s does not exist\n",g_ca_caevent_struct_h.h_corp_id,g_ca_caevent_struct_h.h_res_instr_code);
					CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
					/**End**/
		 	if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
			 	APL_GOBACK_FAIL
		 	else
			 	continue;
	 	}	
	 	if ( int_result == ERR_UNAUTH_INSTR )
	 	{
			/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/
			EXEC SQL ROLLBACK;
		/* 	CA_WriteAlert((&l_ca_canotify_struct_h),
								chr_g_funccode,
								chr_warn_cd_instrunauth,
								g_ca_caevent_struct_h.h_corp_id,
								APL_NULL_STRING,
								g_ca_caevent_struct_h.h_res_instr_code)
			EXEC SQL COMMIT;
			*/
				/* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/
					/* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,
		 	"	E:Instrument %s unauthorised ,skipping event\n",
											 	l_mt_resinstrument_struct_h.h_instr_code);
					CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
					/**Sana [ISAB 108][RBS][30-12-2010]**/
					sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Resultant Instrument %s unauthorised \n",g_ca_caevent_struct_h.h_corp_id,g_ca_caevent_struct_h.h_res_instr_code);
					CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
					/**End**/
		 	if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
			 	APL_GOBACK_FAIL
		 	else
			 	continue;
	 	}
 	}
			/*Smita - HDFCCA_009 - Buy Back Event Checks*/
      if (strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_BUY_BACK) == 0)
      {
			APL_IF_DEBUG
			{
				printf("Check Buy Back Details\n");
				printf("Depo Part Code = |%s|\n",g_ca_caevent_struct_h.h_depo_part_code);
				printf("Depo Code = |%s|\n",g_ca_caevent_struct_h.h_depo_code);
			}
			if (CA_ChkEventDetails(	g_ca_caevent_struct_h,
								       	&int_p_result,
			       						p_intlenv_data_struct_h,
				 							l_debug_info_ptr) == APL_FAILURE)
	  			APL_GOBACK_FAIL 
      	CO_FreeErrLst(l_debug_info_ptr);
      	if ( int_p_result == ERR_DEPO_PART_NOTFND )
      	{
				/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/
         	EXEC SQL ROLLBACK;
         /* 	CA_WriteAlert((	&l_ca_canotify_struct_h),
            		            chr_g_funccode,
                        		chr_warn_cd_DPnf,
                        		g_ca_caevent_struct_h.h_corp_id,
                        		APL_NULL_STRING,
                        		g_ca_caevent_struct_h.h_instr_code)
         	EXEC SQL COMMIT;
			*/
				/* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/
							/* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,"E:Depo Part %s does not exist for Event |%s|,skipping event\n",g_ca_caevent_struct_h.h_depo_part_code,g_ca_caevent_struct_h.h_corp_id);
							CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
							/**Sana [ISAB 108][RBS][30-12-2010]**/
							sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Depo Part %s does not exist\n",g_ca_caevent_struct_h.h_corp_id,g_ca_caevent_struct_h.h_depo_part_code);
							CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
							/**End**/
         	if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
            	APL_GOBACK_FAIL
         	else
           		continue;
      	}
      	if ( int_p_result == ERR_DEPO_PART_UNAUTH )
      	{
         	/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/
         	EXEC SQL ROLLBACK;
         	/* CA_WriteAlert((	&l_ca_canotify_struct_h),
                        		chr_g_funccode,
                        		chr_warn_cd_DPunauth,
                        		g_ca_caevent_struct_h.h_corp_id,
                        		APL_NULL_STRING,
                        		g_ca_caevent_struct_h.h_instr_code)
         	EXEC SQL COMMIT;
			*/
				/* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/
							/* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,"E:Depo Part %s unauthorised for Event |%s|,skipping event\n",g_ca_caevent_struct_h.h_depo_part_code,g_ca_caevent_struct_h.h_corp_id);
							CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
							/**Sana [ISAB 108][RBS][30-12-2010]**/
							sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Depo Part %s unauthorised\n",g_ca_caevent_struct_h.h_corp_id,g_ca_caevent_struct_h.h_depo_part_code);
							CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
							/**End**/
         	if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
            	APL_GOBACK_FAIL
         	else
            	continue;
      	}
			if ( int_p_result == ERR_INVALID_CODE)
			{
				/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/	
				EXEC SQL ROLLBACK;
			/* 	CA_WriteAlert((   &l_ca_canotify_struct_h),
										chr_g_funccode,
										chr_warn_cd_InvalidCD,
										g_ca_caevent_struct_h.h_corp_id,
										APL_NULL_STRING,
										g_ca_caevent_struct_h.h_instr_code)
				EXEC SQL COMMIT;
				*/
					 /* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/
							/* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,"E:Depository Code |%s| Invalid for Event |%s|,skipping Event\n",g_ca_caevent_struct_h.h_depo_code,g_ca_caevent_struct_h.h_corp_id);
							CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
							/**Sana [ISAB 108][RBS][30-12-2010]**/
							sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Depository Code %s Invalid\n",g_ca_caevent_struct_h.h_corp_id,g_ca_caevent_struct_h.h_depo_code);
							CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
							/**End**/
				if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
					APL_GOBACK_FAIL
				else
					continue;
			}
      }
	/*Smita - HDFCCA_009 - Buy Back Event Checks*/


	if	(	!strcmp(q_ca_caseceventstruct_h->h_entitl_base, ENTL_BASE_REG)
		&& (!strcmp(l_mt_core_sys_params_struct_h.proc_reg_ind,"N")))
	{	
		sprintf(chr_g_log_buff,"Site does not support registration processing\n");
		CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
				/**Sana [ISAB 108][RBS][30-12-2010]**/
				sprintf(chr_g_fail_buff,"Internal Error Occured. Contact Support team.\n");
				CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				/**End**/
		CO_FreeErrLst(l_debug_info_ptr);
		if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
			APL_GOBACK_FAIL
		else
			continue;
	}	
	
		printf("g_event_h.h_corp_id is %s\n",g_ca_caevent_struct_h.h_corp_id);
		printf("g_event_h.h_rec_date is %s\n",g_ca_caevent_struct_h.h_rec_date);
		printf("g_event_h.h_ex_date is %s\n",g_ca_caevent_struct_h.h_ex_date);
		printf("g_event_h.h_effect_date is %s\n",g_ca_caevent_struct_h.h_effect_date);
/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/
      /*   if ( (strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_OFFER) == 0) &&
              (strcmp(g_ca_caevent_struct_h.h_op_evt_class,"TO") == 0) )
			{
				memset(chr_g_curr_business_dt,APL_NULL_CHAR,APL_DATE_LEN);
				if (strcmp(g_ca_caevent_struct_h.h_rec_date,APL_NULL_STRING) != 0)
				{
					strcpy(chr_g_curr_business_dt,g_ca_caevent_struct_h.h_rec_date);
				}
            else if (strcmp(g_ca_caevent_struct_h.h_start_date,APL_NULL_STRING) != 0)
            {
					strcpy(chr_g_curr_business_dt,g_ca_caevent_struct_h.h_start_date);
				}
				else
				{
					strcpy(chr_g_curr_business_dt,g_ca_caevent_struct_h.h_effect_date);
				}
			}
			else 
				*/
				/* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/
			if ((!strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)) &&
                  (strcmp(g_ca_caevent_struct_h.h_evt_class,"OP")))
			{
				memset(chr_g_curr_business_dt,APL_NULL_CHAR,APL_DATE_LEN);
				if(l_cond_gr)
				{
					strcpy(chr_g_curr_business_dt,g_ca_caevent_struct_h.h_rec_date);
				}
				else
				{
					strcpy(chr_g_curr_business_dt,g_ca_caevent_struct_h.h_ex_date);
				}
			}
			else
			{
				memset(chr_g_curr_business_dt,APL_NULL_CHAR,APL_DATE_LEN);
				strcpy(chr_g_curr_business_dt,g_ca_caevent_struct_h.h_rec_date);
			}
			if (  !strcmp(q_ca_caseceventstruct_h->h_entitl_base, ENTL_BASE_SETL)   )
			{
		
      		EXEC SQL SELECT count(*) into :int_h_count
      		FROM MT_HOLIDAY
      		WHERE H_DATE = :chr_g_curr_business_dt
      		AND   STATUS = 'AA'/*Smita - HDFCCA_Base Ver - Changed Col Names*/
				AND BANK_IND = 'Y';
      		IS_ANY_ORA_ERROR

      		if(int_h_count == 1)
      		{
        			memset(chr_g_prev_rec_dt_new,NULL,APL_DATE_LEN);
        			if(CA_GetPrevBusinessDay(   chr_g_curr_business_dt,
               		                    chr_g_prev_rec_dt_new,
                     		              l_debug_info_ptr)==APL_FAILURE)
        			APL_GOBACK_FAIL

 		      }
      		else
       		{
         		memset(chr_g_prev_rec_dt_new,NULL,APL_DATE_LEN);
         		strcpy(chr_g_prev_rec_dt_new,chr_g_curr_business_dt);
       		}
			}
			else if (!strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL))
			{
				memset(chr_g_prev_rec_dt_new,NULL,APL_DATE_LEN);
				strcpy(chr_g_prev_rec_dt_new,chr_g_curr_business_dt);
			}
   
		if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0) 
				&& (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0)
				&&(int_date_diff==0)) 
		{
				printf("Entered loop for Accountcur1\n");

				printf("1 = |%s|\n",chr_g_restart_client);
				printf("2 = |%s|\n",chr_g_splacc);
				printf("3 = |%d|\n",int_g_splacc_flg);
				printf("4 = |%s|\n",g_ca_caevent_struct_h.h_instr_code);
                              /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 started*/
				EXEC SQL DECLARE AaccountCur1 CURSOR FOR
					SELECT /*+leading(a,b)*/ a.cln_code client_code FROM MT_CLIENT a,DL_SAFEK b
					WHERE a.cln_code > :chr_g_restart_client
					and a.CLN_BRK_ALL != 'B'
					and a.STATUS != 'CA'
					and  ((a.cln_code != :chr_g_splacc) OR (:int_g_splacc_flg = 0))
					and a.cln_code = b.client
					and b.instr_code = :g_ca_caevent_struct_h.h_instr_code
					and b.safekeep_pos > 0
				UNION
					select /*+ALL_ROWS*/ client client_code from caentitlement ent
			        where ent.client > :chr_g_restart_client 
					and ent.corp_id = :g_ca_caevent_struct_h.h_attach_corp_id
			        and not exists ( select 1 
			        from DL_SAFEK where client = ent.client and instr_code = :g_ca_caevent_struct_h.h_instr_code )
				//order by a.cln_code;
				order by 1;
				printf("\n sql error after declaring AaccountCur1 is %d",sqlca.sqlcode);
                                /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 Ended*/
				IS_ANY_ORA_ERROR
		}
		else if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0) 
						&& (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0)
					&&(int_date_diff==0))
		{
                                /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 started*/
				EXEC SQL DECLARE AaccountCur2 CURSOR FOR
					SELECT /*+leading(a,b)*/ a.cln_code client_code FROM MT_CLIENT a,DL_SAFEK b
					WHERE a.cln_code > :chr_g_restart_client
					and a.CLN_BRK_ALL != 'B'
					and a.STATUS != 'CA'
					and  ((a.cln_code != :chr_g_splacc) OR (:int_g_splacc_flg = 0))
					and a.cln_code = b.client
					and b.instr_code = :g_ca_caevent_struct_h.h_instr_code
					and (nvl(b.safekeep_pos,0)>0
			 				OR nvl(b.VAL_REC,0)>0
			 				OR nvl(b.NVALRECEIVE,0)>0
			 				OR nvl(b.VAL_DEL,0)>0
			 				OR nvl(b.NVALDELIVER,0) > 0
			 				OR nvl(b.DP_REC,0) > 0
			 				OR nvl(b.DP_DEL,0) > 0)
				UNION
					select /*+ALL_ROWS*/ client client_code from caentitlement ent
				    where ent.client > :chr_g_restart_client 
					and ent.corp_id = :g_ca_caevent_struct_h.h_attach_corp_id
				    and not exists (select 1 from DL_SAFEK where client = ent.client and instr_code = :g_ca_caevent_struct_h.h_instr_code)
					//order by a.cln_code;
					order by 1;

				printf("\n sql error after declaring AaccountCur2 is %d",sqlca.sqlcode);
                                /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 Ended*/
				IS_ANY_ORA_ERROR
		}
		else if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
					&&(int_date_diff > 0)
					&& (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0))
		{
                                /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 started*/
   				EXEC SQL DECLARE AaccountCur3 CURSOR FOR
   					SELECT /*+leading(a,c)*/ a.client client_code FROM DL_HISSAFEK A,MT_LOCATION B,MT_CLIENT c
							where c.cln_code=a.client
            			AND   A.INSTR_CODE    =  :g_ca_caevent_struct_h.h_instr_code
            			AND INSTR(NVL(B.STATUS_POS,' '),'Y')!=0
            			AND A.LOCATION_CD=B.LOCATION_CD
							and c.cln_code > :chr_g_restart_client
		      			and c.CLN_BRK_ALL != 'B'
  			   			and c.STATUS != 'CA'
      					and  ((a.client != :chr_g_splacc) OR (:int_g_splacc_flg = 0))
							and a.safekeep_pos>0 and a.POSIT_DATE= :chr_g_prev_rec_dt_new
				UNION
				select /*+ALL_ROWS*/ client client_code from caentitlement ent
				    where ent.client > :chr_g_restart_client 
					and ent.corp_id = :g_ca_caevent_struct_h.h_attach_corp_id
				    and not exists ( select 1
				    from DL_SAFEK where client = ent.client and instr_code = :g_ca_caevent_struct_h.h_instr_code )
					//order by a.cln_code;
					order by 1;
				
			printf("\n sql error after declaring AaccountCur3 is %d",sqlca.sqlcode);
                        /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 Ended*/
            IS_ANY_ORA_ERROR
		}
		else if((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
               &&(int_date_diff > 0)
               && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0))
		{
         printf("\n in the AaccountCur6 loop\n");
        fflush(stdout);
         /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 started*/
         EXEC SQL DECLARE AaccountCur6 CURSOR FOR
         select distinct(cln_code) client_code from MT_CLIENT cln
         where exists
			(select /*+leading(a,b)*/ 1 from  MT_CLIENT a,dl_deal b
				where cln.cln_code = b.client
				and a.cln_code=b.client
				and a.CLN_BRK_ALL!='B'
				and a.STATUS != 'CA'
				and a.cln_code>:chr_g_restart_client
				and ((a.cln_code != :chr_g_splacc) OR (:int_g_splacc_flg = 0))
				and b.instr_code=:g_ca_caevent_struct_h.h_instr_code
				and (b.deal_date<= to_date(:chr_g_curr_business_dt,'dd/mm/yyyy hh24:mi:ss')
						OR b.maker_dt >= to_date(:chr_g_curr_business_dt,'DD/MM/YYYY hh24:mi:ss')))
						OR
      		exists (
            		SELECT /*+leading(p,q)*/ 1 FROM MT_CLIENT p,DL_SAFEK q
               		WHERE p.cln_code = cln.cln_code
			and p.cln_code > :chr_g_restart_client
               		and p.CLN_BRK_ALL != 'B'
               		and p.STATUS != 'CA'
               		and p.cln_code = q.client
               		and  ((p.cln_code != :chr_g_splacc) OR (:int_g_splacc_flg = 0))
               		and q.instr_code = :g_ca_caevent_struct_h.h_instr_code
               		and (nvl(q.safekeep_pos,0)>0
                  		OR nvl(q.VAL_REC,0)>0
                  		OR nvl(q.NVALRECEIVE,0)>0
                  		OR nvl(q.VAL_DEL,0)>0
                  		OR nvl(q.NVALDELIVER,0) > 0
			 				OR nvl(q.DP_REC,0) > 0
			 				OR nvl(q.DP_DEL,0) > 0))
   		OR
			exists(
				select /*+leading(DL_HISDEAL,MT_CLIENT)*/ 1 from DL_HISDEAL,MT_CLIENT 
						where DL_HISDEAL.client = cln.cln_code
						and DL_HISDEAL.client=MT_CLIENT.cln_code
						and DL_HISDEAL.instr_code=:g_ca_caevent_struct_h.h_instr_code
						and MT_CLIENT.CLN_BRK_ALL != 'B'
						and MT_CLIENT.STATUS != 'CA'
						AND DL_HISDEAL.client > :chr_g_restart_client
						and  ((DL_HISDEAL.client != :chr_g_splacc) OR (:int_g_splacc_flg = 0))
						and DL_HISDEAL.deal_date> to_date(:chr_g_curr_business_dt,'dd/mm/yyyy hh24:mi:ss')
						and deal_date<= to_date(to_char(to_date(:chr_g_sys_date,'dd/mm/yyyy hh24:mi:ss'),'dd/mm/yyyy'),'dd/mm/yyyy')
						and DL_HISDEAL.DEAL_STAT!='DD')
		OR
               exists
			(select /*+ALL_ROWS*/ 1 from caentitlement ent
					    where ent.client = cln.cln_code
					        and client > :chr_g_restart_client 
						and corp_id = :g_ca_caevent_struct_h.h_attach_corp_id
					    and not exists ( select 1 
					    from DL_SAFEK where client = ent.client and instr_code = :g_ca_caevent_struct_h.h_instr_code )
					);
			//order by a.cln_code;
			/*order by 1;  Commented by Ram for CS0113805 FOC  */

			printf("\n sql error after declaring AaccountCur6 is %d",sqlca.sqlcode);
                        /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 Ended*/
			IS_ANY_ORA_ERROR
		}
		else  if ((strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0)  && (int_g_flg_mod_event == 0))
		{
                /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 started*/
      		EXEC SQL DECLARE AaccountCur4 CURSOR FOR
					SELECT /*+leading(a,b)*/ distinct(b.client) client_code from MT_CLIENT a,dl_deal b
					where a.CLN_BRK_ALL != 'B'
					and a.STATUS != 'CA'
					and  ((a.cln_code != :chr_g_splacc) OR (:int_g_splacc_flg = 0))
					and a.cln_code = b.client
					AND b.client > :chr_g_restart_client
					and b.instr_code = :g_ca_caevent_struct_h.h_instr_code
					and (b.deal_date<= to_date(:chr_g_curr_business_dt,'dd/mm/yyyy hh24:mi:ss')
						 OR b.maker_dt >= to_date(:chr_g_curr_business_dt,'DD/MM/YYYY hh24:mi:ss'))
             UNION
				select /*+ALL_ROWS*/ client client_code from caentitlement ent
				where ent.client > :chr_g_restart_client 
				and ent.corp_id = :g_ca_caevent_struct_h.h_attach_corp_id
				and not exists ( select 1
				from DL_SAFEK where client = ent.client and instr_code = :g_ca_caevent_struct_h.h_instr_code )
				//order by a.cln_code;
				order by 1;

				printf("\n sql error after declaring AaccountCur4 is %d",sqlca.sqlcode);
				Alert("Instrument code passed = |%s|",g_ca_caevent_struct_h.h_instr_code);
                /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 Ended*/
				IS_ANY_ORA_ERROR
		}
		else if ((strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0) && (int_g_flg_mod_event == 0))
		{ 
                      /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 started*/
			EXEC SQL DECLARE AaccountCur5 CURSOR FOR
				SELECT DISTINCT CLIENT client_code FROM CABACKSETTLE
					WHERE INSTRUMENT_DT <= :chr_g_prev_rec_dt_new
					AND INSTR_CODE = :g_ca_caevent_struct_h.h_instr_code
					AND client > :chr_g_restart_client
					AND ((client != :chr_g_splacc) OR (:int_g_splacc_flg = 0))
             UNION
				select /*+ALL_ROWS*/ client client_code from caentitlement ent
				where ent.client > :chr_g_restart_client 
				and ent.corp_id = :g_ca_caevent_struct_h.h_attach_corp_id
				and not exists ( select 1
				from DL_SAFEK where client = ent.client and instr_code = :g_ca_caevent_struct_h.h_instr_code )
				//order by CLIENT;
				order by 1;

			printf("\n sql error after declaring AaccountCur5 is %d",sqlca.sqlcode);
                       /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 Ended*/
			IS_ANY_ORA_ERROR
		}
		else if (int_g_flg_mod_event == 1)
      {
	/*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 Started*/		
         EXEC SQL DECLARE AaccountCur7 CURSOR FOR
            SELECT DISTINCT client client_code FROM DL_SAFEK WHERE
						 client > :chr_g_restart_client AND
						 instr_code = (SELECT instr_code FROM CAEVENT
               			//STATUS AND PRELIMINARY_FLAG CONDITION ADDED BY SUDHIR K. ON 01/10/2015 FOR ISBK_8537- START
               					WHERE corp_id = :g_ca_caevent_struct_h.h_corp_id AND STATUS !='RV' AND PRELIMINARY_FLAG='N') AND
   		//STATUS AND PRELIMINARY_FLAG CONDITION ADDED BY SUDHIR K. ON 01/10/2015 FOR ISBK_8537- END
						 client > (SELECT nvl(CURR_CLT,-1) FROM CACHGEVENT WHERE corp_id = :g_ca_caevent_struct_h.h_corp_id) 
             UNION
				select client from caentitlement ent
				where ent.client > :chr_g_restart_client 
				and ent.corp_id = :g_ca_caevent_struct_h.h_attach_corp_id
				and not exists (select 1
				from DL_SAFEK where client = ent.client and instr_code = :g_ca_caevent_struct_h.h_instr_code)
				//order by a.cln_code;
				order by 1;

			printf("\n sql error after declaring AaccountCur7 is %d",sqlca.sqlcode);
         /*Changed by siva.ganapathi for ISKB_3300 on 12/01/2009 Ended*/		

         IS_ANY_ORA_ERROR
      }

      if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
            && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0)
            &&(int_date_diff==0))
      {
			APL_IF_DEBUG
			{
				printf("Opening AccountCur1\n");
			}
		EXEC SQL OPEN AaccountCur1;
		IS_ANY_ORA_ERROR
      }
      else if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
                  && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0)
               &&(int_date_diff==0))
      {
		EXEC SQL OPEN AaccountCur2;
		IS_ANY_ORA_ERROR
      }
      else if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
               &&(int_date_diff > 0)
					&& (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0))
      {
		EXEC SQL OPEN AaccountCur3;
		IS_ANY_ORA_ERROR
      }
      else if((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
               &&(int_date_diff > 0)
               && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0))
		{
         printf("\n in the AaccountCur6 OPENloop\n");
        fflush(stdout);
		EXEC SQL OPEN AaccountCur6;
		IS_ANY_ORA_ERROR
		}
      else  if ((strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0)  && (int_g_flg_mod_event == 0))
      {
		Alert("Opening cursor AaccountCur4");
		EXEC SQL OPEN AaccountCur4;
		IS_ANY_ORA_ERROR
      }
      else if ((strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0) && (int_g_flg_mod_event == 0))
      {
		EXEC SQL OPEN AaccountCur5;
		IS_ANY_ORA_ERROR
      }
      else if  (int_g_flg_mod_event == 1)
      {
		EXEC SQL OPEN AaccountCur7;
		IS_ANY_ORA_ERROR
      }

	
	if	(!strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_REG)
		&& (!strcmp(l_mt_instrument_struct_h.h_reg_br_ind,APL_INSTRU_REGD))	)
	{ 
		strcpy(chr_mainfuncarea_h,	"CA_REGN_PROC");
		strcpy(chr_condid_h,			"ALL_STATUSES");
		Cond_exists_h = 0;

		if(CO_Chk_CntryEnabled(	chr_mainfuncarea_h,
										chr_condid_h,
										&Cond_exists_h,
										l_debug_info_ptr)==APL_FAILURE)
			APL_GOBACK_FAIL
		if(Cond_exists_h>0)
			int_curflg=1;
		else
			int_curflg=2;
	}
   else if (!strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL))
   {
   
      int_curflg=3;
   }
   else if(!strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL))
   {
      int_curflg=4;
   }
   /* Added By Sana for entitlement opt - start */
	for(;;)
	{
		
		printf("\n\nInside for loop of client cursor......");
		fflush(stdout);

		elig_entitl_pos = 0.0;		/* Added for UAT Fix for flushing the variable */

		for(i=0;i<50;i++)
	{
			memset(l_chr_client[i].arr,APL_NULL_CHAR,APL_CLIENT_LENGTH);
		}

		int_flg_entpos_negative = 0;
		fetch_rows = 0;
		tot_rows = 0;
		break_flg=0;
		temp_x=0;
		i = 0;

		sprintf(chr_g_log_buff,"datediff is |%d|",int_date_diff);
		CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
		sprintf(chr_g_log_buff,"evtstat is |%s|",g_ca_caevent_struct_h.h_evt_stat);
		CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
		sprintf(chr_g_log_buff,"entitlbase is |%s|",q_ca_caseceventstruct_h->h_entitl_base);
		CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);

		if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0) && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0)
            &&(int_date_diff==0))
      {
		sprintf(chr_g_log_buff,"E:Accountcur1");
		CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
				EXEC SQL FETCH AaccountCur1 INTO :l_chr_client;
		APL_IF_DEBUG
		{
			printf("Fetched ACCOUNTCUR1\n");
		}
				
			printf("Came out aftre Fetch successfully..\n");
      }
      else if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
                  && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0)
               &&(int_date_diff==0))
      {
		sprintf(chr_g_log_buff,"E:Accountcur2");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
				EXEC SQL FETCH AaccountCur2 INTO :l_chr_client;
				
      }
      else if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
               &&(int_date_diff > 0)
					&& (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0))
      {
		sprintf(chr_g_log_buff,"E:Accountcur3");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
				EXEC SQL FETCH AaccountCur3 INTO :l_chr_client;
				
      }
      else if((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
               &&(int_date_diff > 0)
               && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0))
		{
		sprintf(chr_g_log_buff,"E:Accountcur6");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
				EXEC SQL FETCH AaccountCur6 INTO :l_chr_client;
				
		}
      else  if ((strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0) && (int_g_flg_mod_event == 0))
      {
				printf("\nFetched cursor Accountcur4");
		sprintf(chr_g_log_buff,"E:Accountcur4");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
				EXEC SQL FETCH AaccountCur4 INTO :l_chr_client;
				printf("\nSQLCA.SQLCODE after fetch is |%d|",sqlca.sqlcode);
				
      }
      else if ((strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0) && (int_g_flg_mod_event == 0))
      {
		sprintf(chr_g_log_buff,"E:Accountcur5");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
				EXEC SQL FETCH AaccountCur5 INTO :l_chr_client;
				
      }
      else if (int_g_flg_mod_event == 1)
      {
		sprintf(chr_g_log_buff,"E:Accountcur7");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
				EXEC SQL FETCH AaccountCur7 INTO :l_chr_client;

      }
		else
		{
			sprintf(chr_g_log_buff,"E:No Cursor");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
		}
		fflush(g_logfile);
		printf("** sqlca.sqlcode is |%d|\n",sqlca.sqlcode);
		if (sqlca.sqlcode == 1403)
		{
			break_flg = 1 ;
			/* Commented by Sana printf("sqlca.sqlcode is 1403... breaking\n");
			break;*/
		}

		fetch_rows = sqlca.sqlerrd[2] - tot_rows ;
		tot_rows   = sqlca.sqlerrd[2] ;

		printf("\nfetched rows are |%d|",fetch_rows);
		printf("\ntotal rows are |%d|",tot_rows);

		for( temp_x = 0 ; temp_x < fetch_rows ; temp_x++ )
		{
				memset(chr_g_client,APL_NULL_CHAR,APL_CLIENT_LENGTH);
				int_flg_entpos_negative = 0;

				l_chr_client[temp_x].arr[l_chr_client[temp_x].len] = '\0';

				strcpy(chr_g_client,l_chr_client[temp_x].arr);
				
		printf("client is |%s|\n",chr_g_client);

		int_l_dummy=0;
		if (APL_FAILURE == CO_Chk_SplVal("EUROCLEAR",
												  "DUMMY_ACC",
												  chr_g_client,
												  &int_l_dummy,
												  l_debug_info_ptr))
		{
			APL_GOBACK_FAIL
		}
		if (int_l_dummy)
			continue;
		
		elig_entitl_pos	= 0.0;	
		int_noacs = 0;
		entl_msg_cnt = 0;
		totquantity_bal = 0.00;
		totfract_due = 0.00;
		totamount_bal = 0.00;
		round_val = 0.00;

		APL_IF_DEBUG
		{
			printf("Now Checking Evet Details............Line No 1610\n");
		}	
		if ( !strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_REDOM) )
		{
			if(	CA_RedenomCalcEnt(	int_curflg,
									 q_ca_caseceventstruct_h,
									 g_ca_caevent_struct_h.h_rec_date,
									 chr_g_client,
										p_intlenv_data_struct_h,
									 l_debug_info_ptr) ==APL_FAILURE	)
			APL_GOBACK_FAIL
		}	
		else 
		{
			if ( (strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_OFFER) == 0) &&
				  (strcmp(g_ca_caevent_struct_h.h_op_evt_class,"TO") == 0) )
			{
				APL_IF_DEBUG
				{
					printf("Entered now to check Rec_Date,Start_Date,and Calc Entitlements...\n");
				}
            if(strcmp(g_ca_caevent_struct_h.h_rec_date,APL_NULL_STRING) != 0)
            {
					APL_IF_DEBUG
					{
						printf("Within RecDate Check\n");
					}
               if(   CA_CalcEntitlPos(  int_curflg,
                                  q_ca_caseceventstruct_h,
                                  g_ca_caevent_struct_h.h_rec_date,
                                  chr_g_client,
                                  &elig_entitl_pos,
                                  l_debug_info_ptr) ==APL_FAILURE  )
               APL_GOBACK_FAIL
            }
				else if (strcmp(g_ca_caevent_struct_h.h_start_date,APL_NULL_STRING) != 0)
				{
					APL_IF_DEBUG
					{
						printf("Within StartDate Check\n");
					}
					if(	CA_CalcEntitlPos(	int_curflg,
											 q_ca_caseceventstruct_h,
											 g_ca_caevent_struct_h.h_start_date,
											 chr_g_client,
											 &elig_entitl_pos,
											 l_debug_info_ptr) ==APL_FAILURE	)
					APL_GOBACK_FAIL
				}
				else
				{
					APL_IF_DEBUG
					{
						printf("Outside Checks...Calc Entitlements...\n");
					}
					if(	CA_CalcEntitlPos(	int_curflg,
											 q_ca_caseceventstruct_h,
											 g_ca_caevent_struct_h.h_effect_date,
											 chr_g_client,
											 &elig_entitl_pos,
											 l_debug_info_ptr) ==APL_FAILURE	)
					APL_GOBACK_FAIL
				}
			}
			
			else if ((!strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)) && 
						(strcmp(g_ca_caevent_struct_h.h_evt_class,"OP")))
			{
				if (l_cond_gr)
				{
					printf("value of recdt before CA_CalcEntitlPos is %s\n",g_ca_caevent_struct_h.h_rec_date);
            	if(   CA_CalcEntitlPos(  int_curflg,
               	                  q_ca_caseceventstruct_h,
                  	               g_ca_caevent_struct_h.h_rec_date,
                     	            chr_g_client,
                        	         &elig_entitl_pos,
                           	      l_debug_info_ptr) ==APL_FAILURE  )
            	APL_GOBACK_FAIL
				}
				else
				{
					printf("value of ex datebefore CA_CalcEntitlPos is %s\n",g_ca_caevent_struct_h.h_ex_date);
					if(   CA_CalcEntitlPos(  int_curflg,
												q_ca_caseceventstruct_h,
												g_ca_caevent_struct_h.h_ex_date,
												chr_g_client,
												&elig_entitl_pos,
												l_debug_info_ptr) ==APL_FAILURE  )
					APL_GOBACK_FAIL
				}
			}
			else
			{	
				printf("Now Calling CA_CalcEntitlPos ......................\n");
				if(	CA_CalcEntitlPos(	int_curflg,
										 q_ca_caseceventstruct_h,
										 g_ca_caevent_struct_h.h_rec_date,
										 chr_g_client,
										 &elig_entitl_pos,
										 l_debug_info_ptr) ==APL_FAILURE	)
				APL_GOBACK_FAIL
			}

			printf("elig entitl pos is |%f|\n",elig_entitl_pos);  // AIX -Warnings Reaoval

		if( (elig_entitl_pos <= 0) && (!strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)) )
		{
			if(elig_entitl_pos == 0)
			{
			if ( CA_Commit(APL_FAILURE,S_LEVEL_ENTITL,l_debug_info_ptr) == APL_FAILURE )
				APL_GOBACK_FAIL
			else
				continue;
			}
			else
			{  	/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/ 	
				/*CA_WriteAlert((&l_ca_canotify_struct_h),
									chr_g_funccode,
									chr_warn_cd_negposn,
									g_ca_caevent_struct_h.h_corp_id,
									chr_g_client,
									g_ca_caevent_struct_h.h_instr_code)
				*/
				/* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/
			}
		}
		tot_elig_entitl_pos=tot_elig_entitl_pos+elig_entitl_pos;//Added by Gouse for Prod Issue - ISKB_5945
		printf("tot_elig_entitl_pos is |%lf|\n",tot_elig_entitl_pos);
					
		Alert("\n Dnyanesh:before Copy:last_pymt_date=|%s|,old=|%s|,issue=|%s| instr last pymt date= %s \n",last_pymt_date,l_mt_instrument_struct_h.h_old_lst_paydt,l_mt_instrument_struct_h.h_issue_date,l_mt_instrument_struct_h.h_last_pymt_date);

       /* Changes done by Vilin for ISKB_4734 */

	      /* 	if (strlen(l_mt_instrument_struct_h.h_old_lst_paydt))
			strcpy(last_pymt_date, l_mt_instrument_struct_h.h_old_lst_paydt); */

       if(strlen(l_mt_instrument_struct_h.h_last_pymt_date)) 
             strcpy(last_pymt_date, l_mt_instrument_struct_h.h_last_pymt_date);
		   else
		      	strcpy(last_pymt_date, l_mt_instrument_struct_h.h_issue_date);

		Alert("\n Dnyanesh:after Copy:last_pymt_date=|%s|,old=|%s|,issue=|%s| \n",last_pymt_date,l_mt_instrument_struct_h.h_old_lst_paydt,l_mt_instrument_struct_h.h_issue_date);

	      /* Changes end  by Vilin for ISKB_4734 */		
		
		if ( elig_entitl_pos < 0 )
		{
			int_flg_entpos_negative = 1;
			elig_entitl_pos = -elig_entitl_pos;
		}
		Alert("\n Amit:before CA_CalcEntitlement:QtyBal=|%lf| \n",l_ca_caentitlement_struct_h->h_quantity_due);
  		if(	CA_CalcEntitlement(
						  		&g_ca_caevent_struct_h,
						  		l_ca_caentitlement_struct_h,
						  		q_ca_caseceventstruct_h,
						  		elig_entitl_pos,
						  		l_mt_instrument_struct_h.h_nominal_value,
						  		last_pymt_date,
						  		l_mt_instrument_struct_h.h_int_acctyp,
								l_debug_info_ptr )==APL_FAILURE)
			APL_GOBACK_FAIL

		fflush(stdout);

		//Alert("\n Amit:After CA_CalcEntitlement:QtyBal=|%lf| \n",l_ca_caentitlement_struct_h->h_quantity_due);
		//Alert("h_instr_inc_bal is |%lf|\n",l_ca_caentitlement_struct_h->h_instr_inc_bal);

		if ( int_flg_entpos_negative )
			elig_entitl_pos = -elig_entitl_pos;
		

	strcpy(chr_mainfuncarea_h,	"CA_ENTITL");
	strcpy(chr_condid_h,			"NO_TRUNC_ENT_QTY");
	Trunc_Cond_exists_h = 0;

	if(CO_Chk_CntryEnabled(	chr_mainfuncarea_h,
									chr_condid_h,
									&Trunc_Cond_exists_h,
									l_debug_info_ptr)==APL_FAILURE)
		APL_GOBACK_FAIL

	int_period_flg1=0;
	if ( CO_Chk_CcyConvDt("",&int_period_flg1,l_debug_info_ptr) == APL_FAILURE )
		APL_GOBACK_FAIL

	if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
	{
		EXEC SQL SELECT TRUNC(:l_ca_caentitlement_struct_h->h_instr_inc_bal,:l_mt_core_sys_params_struct_h.amount_decimal_len) INTO :round_val FROM DUAL;
		IS_ANY_ORA_ERROR

	}
	else
	{
		round_val = 0.00;
		CO_Round(	l_ca_caentitlement_struct_h->h_instr_inc_bal,
					l_dl_currency_struct_h.h_dec_len,
					&round_val);
	}
		l_ca_caentitlement_struct_h->h_instr_inc_bal = round_val;
		Alert("after rounding h_instr_inc_bal is |%lf|\n",l_ca_caentitlement_struct_h->h_instr_inc_bal);
		if ( int_flg_entpos_negative ) 
		{
			l_ca_caentitlement_struct_h->h_instr_inc_bal = -l_ca_caentitlement_struct_h->h_instr_inc_bal;
			l_ca_caentitlement_struct_h->h_quantity_due = -l_ca_caentitlement_struct_h->h_quantity_due;
		}
		strcpy(l_ca_caentitlement_struct_h->h_corp_id,		g_ca_caevent_struct_h.h_corp_id);
		strcpy(l_ca_caentitlement_struct_h->h_dl_client,	chr_g_client);
		strcpy(l_ca_caentitlement_struct_h->h_entitl_ccy,	g_ca_caevent_struct_h.h_ca_currency);

		
		if(!strcmp(g_ca_caevent_struct_h.h_evt_class, EVT_OFFER) && (g_ca_caevent_struct_i.i_res_instr_code == -1))
		{
			strcpy(l_ca_caentitlement_struct_h->h_entitl_stat,	STATUS_MSG_PAID_CLSD); 
		}
		else
		{
			if (elig_entitl_pos < 0)
				strcpy(l_ca_caentitlement_struct_h->h_entitl_stat,	STATUS_PENDING);
			else 
				strcpy(l_ca_caentitlement_struct_h->h_entitl_stat,	STATUS_RDY_PYMT);
		}
		strcpy(l_ca_caentitlement_struct_h->h_stat_date,	chr_g_sys_date);
		strcpy(l_ca_caentitlement_struct_h->h_maker,		APL_USER_SYSTEM);
		strcpy(l_ca_caentitlement_struct_h->h_maker_dt,	chr_g_sys_date);
		strcpy(l_ca_caentitlement_struct_h->h_checker,	APL_USER_SYSTEM);
		strcpy(l_ca_caentitlement_struct_h->h_checker_dt,	chr_g_sys_date);

		l_ca_caentitlement_struct_h->h_entitl_pos = elig_entitl_pos;
		l_ca_caentitlement_struct_h->h_amount_recd	=	0;
		l_ca_caentitlement_struct_h->h_quantity_recd	=	0;

		

		l_ca_caentitlement_struct_i->i_nrepdate2 = 	-1;
		l_ca_caentitlement_struct_i->i_nrepdate3 = 	-1;
		if (strlen(l_ca_caentitlement_struct_h->h_sent550date)==0)	
			l_ca_caentitlement_struct_i->i_sent550date = -1;

				EXEC SQL SELECT /*+ALL_ROWS */ CAENTITLEMENT.*,rowid
		INTO :l_ca_tbcaentitlement_struct_h:l_ca_tbcaentitlement_struct_i,:chr_tbl_ent_rowid
		FROM CAENTITLEMENT
		WHERE  corp_id=:g_ca_caevent_struct_h.h_corp_id
		AND client=:l_ca_caentitlement_struct_h->h_dl_client
		//Commented and Rewritten for ISKB_6221(CA_GenEntitl process is not getting completed)-START
		//FOR UPDATE NOWAIT;
		  FOR UPDATE;
		//Commented and Rewritten for ISKB_6221(CA_GenEntitl process is not getting completed)-END

		IS_ANY_ORA_ERROR				

		strcpy(chr_stat, STATUS_AUTH);
		printf("\n\n\t ************* |||||the chr_value of chr_stat in CA_Proc_EntitlGen.pc is ---------> %s \n\n",chr_stat);
		if (APL_ZERO_RESULT_SET)
		{
			Alert("ZERO Result Set condition\n");
			if (elig_entitl_pos !=0 )
			{
		    
			printf("\n got inside the if loop and hence takes records       from CWHTRATE\n");

			 if((strcmp(g_ca_caevent_struct_h.h_evt_class, EVT_BOND) == 0 )||
			   (strcmp(g_ca_caevent_struct_h.h_evt_class, EVT_CASH_DIV) == 0 ) || 
				(strcmp(g_ca_caevent_struct_h.h_evt_class, EVT_DECR_VAL) == 0 ))    
          {
		/* 22-02-07 Changed NATION_CD in foll code to Country*/
		      EXEC SQL SELECT  NVL(CUSTODYTAXRT,0) INTO :l_custodytax_rate:i_whtax_rate
			     FROM MT_WHTRATE 
			     WHERE NATION_CD = (SELECT COUNTRY FROM MT_CLIENT WHERE cln_code = :l_ca_caentitlement_struct_h->h_dl_client)
			     AND   prod_class  = (SELECT prod_class FROM MT_INSTRUMENT WHERE instr_code = :g_ca_caevent_struct_h.h_instr_code)
					AND STATUS = :chr_stat;

				  if(APL_ZERO_RESULT_SET)
				  {
					  l_custodytax_rate = 0;
              }

          }
			 else
			 {
				 l_custodytax_rate = 0;
			 }
			 l_ca_caentitlement_struct_h->h_tax_rate = l_custodytax_rate;

						EXEC SQL INSERT /*+APPEND_VALUES*/ INTO CAENTITLEMENT 
				VALUES (:l_ca_caentitlement_struct_h:l_ca_caentitlement_struct_i);
				IS_ANY_ORA_ERROR

				int_noacs = 1;
				if (elig_entitl_pos < 0) 
				{
					totquantity_bal = 0;
					totamount_bal = 0;
					totfract_due = 0;
				}
				else
				{
					totquantity_bal = l_ca_caentitlement_struct_h->h_quantity_due;  
					totamount_bal = l_ca_caentitlement_struct_h->h_instr_inc_bal;  
					totfract_due = l_ca_caentitlement_struct_h->h_fract_due;
				}

				sprintf(chr_g_log_buff,"T:Create Entitlement for %s",l_ca_caentitlement_struct_h->h_dl_client);
				CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
				
				if(!strcmp(g_ca_caevent_struct_h.h_entl_send_msg_ind,APL_YES_IND))
				{
					if ( (CA_SendEntitlMsg(	g_ca_caevent_struct_h.h_evt_class,
												g_ca_caevent_struct_h.h_corp_id,
												l_ca_caentitlement_struct_h->h_dl_client,
												l_debug_info_ptr) == APL_FAILURE) )
						APL_GOBACK_FAIL
					entl_msg_cnt = 1;
				}


	strcpy(chr_l_entstrpos,APL_NULL_STRING);
	strcpy(chr_l_incstrdue,APL_NULL_STRING);
	strcpy(chr_l_qtystrdue,APL_NULL_STRING);

	strcpy(chr_l_client_a,l_ca_caentitlement_struct_h->h_dl_client);
	strcpy(chr_l_instrcode_a,g_ca_caevent_struct_h.h_instr_code);

   if(APL_FAILURE == CO_PadString(chr_l_client_a,'R',10," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);

			 /**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2160|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
			 /**End**/
     APL_GOBACK_FAIL
   }

   if(APL_FAILURE == CO_PadString(chr_l_instrcode_a,'R',8," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);
			 /**Sana [ISAB 108][RBS][30-12-2010]**/
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2170|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
			 /**End**/
     APL_GOBACK_FAIL
   }

     if(APL_FAILURE == CO_ToStr(l_ca_caentitlement_struct_h->h_entitl_pos,25,4,chr_l_entstrpos))
      {
				 /**Sana [ISAB 108][RBS][30-12-2010]**/
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc Line|2179|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				 /**End**/
         APL_GOBACK_FAIL
      }

   if(APL_FAILURE == CO_PadString(chr_l_entstrpos,'R',25," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);
			 /**Sana [ISAB 108][RBS][30-12-2010]**/
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2189|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
			 /**End**/
     APL_GOBACK_FAIL
   }
		if(APL_FAILURE == CO_ToStr(l_ca_caentitlement_struct_h->h_instr_inc_bal,25,4,chr_l_incstrdue))
		{
						/**Sana [ISAB 108][RBS][30-12-2010]**/
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2197|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
						/**End**/
			APL_GOBACK_FAIL
		}

   if(APL_FAILURE == CO_PadString(chr_l_incstrdue,'R',25," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);
			 /**Sana [ISAB 108][RBS][30-12-2010]**/
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2207|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
			 /**End**/
     APL_GOBACK_FAIL
   }
		if(APL_FAILURE == CO_ToStr(l_ca_caentitlement_struct_h->h_quantity_due,25,4,chr_l_qtystrdue))
		{
						/**Sana [ISAB 108][RBS][30-12-2010]**/
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2216|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
						/**End**/
			APL_GOBACK_FAIL
		}

   if(APL_FAILURE == CO_PadString(chr_l_qtystrdue,'R',18," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);
			 /**Sana [ISAB 108][RBS][30-12-2010]**/
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2225|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
			 /**End**/
     APL_GOBACK_FAIL
   }

	fprintf(l_repfile,"NEW         %s%6s",chr_l_instrcode_a," "); 	
	fprintf(l_repfile,"%s%11s",g_ca_caevent_struct_h.h_evt_class," ");
	
   if (strlen(ltoa(g_ca_caevent_struct_h.h_evt_nbr)) == 1 )
      fprintf(l_repfile,"%d%5s",g_ca_caevent_struct_h.h_evt_nbr," ");
   else
      fprintf(l_repfile,"%d%4s",g_ca_caevent_struct_h.h_evt_nbr," ");
	fprintf(l_repfile,"%s%1s",chr_l_client_a," "); 
	fprintf(l_repfile,"%26s"," ");
	fprintf(l_repfile,"%s%1s",chr_l_entstrpos," ");
		if ( (!strcmp(g_ca_caevent_struct_h.h_evt_class,"CD")) || (!strcmp(g_ca_caevent_struct_h.h_evt_class,"BI")) || (!strcmp(g_ca_caevent_struct_h.h_evt_class,"RD")))
				{
				fprintf(l_repfile,"%26s"," ");
				fprintf(l_repfile,"%s\n",chr_l_incstrdue);
				}
				else
				{
					fprintf(l_repfile,"%26s"," ");
					fprintf(l_repfile,"%s\n",chr_l_qtystrdue);
				} 
			}
			else
			{
				if ( CA_Commit(APL_FAILURE,S_LEVEL_ENTITL,l_debug_info_ptr) == APL_FAILURE )
					APL_GOBACK_FAIL
				else
					continue;
			}
		}
		else 
		{
			Alert("Inside else of zero result set\n");
			if ((APL_DOUBLE_EQUAL(l_ca_tbcaentitlement_struct_h->h_entitl_pos,l_ca_caentitlement_struct_h->h_entitl_pos)) && (int_g_flg_mod_event == 0))
			{
					Alert("No change in entitlement position\n");
					sprintf(chr_g_log_buff,"T:HERE FOR TRADED BASIS");
               CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
				if ( CA_Commit(APL_FAILURE,S_LEVEL_ENTITL,l_debug_info_ptr) == APL_FAILURE )
					APL_GOBACK_FAIL
				else
					continue;
			}
			else
			{
				if (l_ca_tbcaentitlement_struct_i->i_sent550date == -1)	
					l_ca_caentitlement_struct_i->i_sent550date = -1;
	
				l_ca_caentitlement_struct_h->h_tax_rate= l_ca_tbcaentitlement_struct_h->h_tax_rate;

				if ( strcmp(l_ca_tbcaentitlement_struct_h->h_maker,APL_USER_SYSTEM) || 
						strcmp(l_ca_tbcaentitlement_struct_h->h_checker,APL_USER_SYSTEM) )				
				{
					
					
					sprintf(chr_g_log_buff,"T:Not recalculating Entitlement for %s as it is manually entered.", l_ca_caentitlement_struct_h->h_dl_client);
					CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
				
					sprintf(chr_g_log_buff,"T:Calculated values were : ENT POS =(%f)", elig_entitl_pos);
					CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);

					sprintf(chr_g_log_buff,"T:INC DUE =(%f) QTY DUE =(%f)\n ",l_ca_caentitlement_struct_h->h_instr_inc_bal,
								l_ca_caentitlement_struct_h->h_quantity_due);
					CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
						/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/ 	
					/*CA_WriteAlert((&l_ca_canotify_struct_h),
										chr_g_funccode,
										chr_warn_cd_norecman,
										g_ca_caevent_struct_h.h_corp_id,
										chr_g_client,
										g_ca_caevent_struct_h.h_instr_code)
					*/
					/* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/						
	 				if (CA_Commit(APL_SUCCESS,S_LEVEL_ENTITL,l_debug_info_ptr) == APL_FAILURE)
		 				APL_GOBACK_FAIL
					else
						continue;
				}
				else if ( strcmp(l_ca_tbcaentitlement_struct_h->h_entitl_stat,STATUS_RDY_PYMT) )
				{
					sprintf(chr_g_log_buff,"T:Not updating Entitlement for %s as it is not in READY FOR PAYMENT status_ind - status_ind is :[%s] ", l_ca_caentitlement_struct_h->h_dl_client,l_ca_tbcaentitlement_struct_h->h_entitl_stat);
					CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
					
					sprintf(chr_g_log_buff,"T:Calculated values were : ENT POS =(%f)", elig_entitl_pos);
					CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);

					sprintf(chr_g_log_buff,"T:INC DUE =(%f) QTY DUE =(%f)\n ", l_ca_caentitlement_struct_h->h_instr_inc_bal,
					l_ca_caentitlement_struct_h->h_quantity_due);
					CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
					/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/ 	
					/* CA_WriteAlert((&l_ca_canotify_struct_h),
										chr_g_funccode,
										chr_warn_cd_nordypmt,
										g_ca_caevent_struct_h.h_corp_id,
										chr_g_client,
										g_ca_caevent_struct_h.h_instr_code)
					*/
					/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/				
					if (CA_Commit(APL_SUCCESS,S_LEVEL_ENTITL,l_debug_info_ptr) 
																			== APL_FAILURE)
		 				APL_GOBACK_FAIL
					else
						continue;
				}
				else
				{
					  CO_FreeErrLst(l_debug_info_ptr);
					  if (	CA_Proc_GenUpdEntitl( l_ca_caentitlement_struct_h,
													  l_ca_caentitlement_struct_i,
													  l_ca_tbcaentitlement_struct_h,
													  chr_tbl_ent_rowid,
													  p_intlenv_data_struct_h,
													  l_debug_info_ptr) == APL_FAILURE
						  )
					  {
						  IS_ANY_ERROR_FATAL
						  sprintf(chr_g_log_buff,"T:Encountered l_debuglist - could not  update Entitlement for %s ",l_ca_caentitlement_struct_h->h_dl_client);
						  CO_ProcMonitor(g_logfile,chr_g_log_buff,l_debug_info_ptr,NULL);
								  /**Sana [ISAB 108][RBS][30-12-2010]**/
								  sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Entitlement Not Generated, Reason : Failed in CA_Proc_GenUpdEntitl.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
								  CO_ProcMonitor(g_failurefile,chr_g_fail_buff,l_debug_info_ptr,NULL);
								  /**End**/
							  
						  sprintf(chr_g_log_buff,"T:Calculated values were : ENT POS =(%f)", elig_entitl_pos);
						  CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);

						sprintf(chr_g_log_buff,"T:INC DUE =(%f) QTY DUE =(%f)\n ", l_ca_caentitlement_struct_h->h_instr_inc_bal,
							l_ca_caentitlement_struct_h->h_quantity_due);
					  		CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);

							  if (CA_Commit(APL_FAILURE,S_LEVEL_ENTITL,l_debug_info_ptr) == APL_FAILURE)
									 APL_GOBACK_FAIL
								else
									 continue;
					  }	

				  sprintf(chr_g_log_buff,"T:Recalculated Entitlement for %s",l_ca_caentitlement_struct_h->h_dl_client);
				  CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
				  
					if ( !strcmp(l_ca_caentitlement_struct_h->h_entitl_stat,STATUS_FROZ_RP))
					{
						if ( l_ca_caentitlement_struct_h->h_entitl_pos < 0 )
						{
									/* Commented By Sana as same is getting printed in failure log CO_ProcMonitor(g_logfile,"Entitlement frozen as positions were calculated to be negative and Pymt Records exist for this entitlment",NULL,NULL); 
									CO_ProcMonitor(g_logfile,"Unfreeze and Delete the pymt records to proceed",NULL,NULL); */
									/**Sana [ISAB 108][RBS][30-12-2010]**/
									sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Entitlement frozen as positions were calculated to be negative and Pymt Records exist for this entitlment.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
									CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL); 
									/**End**/
						}
						else
						{
									/* Commented By Sana as same is getting printed in failure log CO_ProcMonitor(g_logfile,"Entitlement frozen as positions were calculated to be less then sum of existing payment records",NULL,NULL); 
									CO_ProcMonitor(g_logfile,"Unfreeze and then Delete/Modify the pymt records to proceed",NULL,NULL); */
									/**Sana [ISAB 108][RBS][30-12-2010]**/
									sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s| Entitlement frozen as positions were calculated to be be less than sum of existing payment records.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
									CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL); 
									/**End**/
						}	
		
					}
					else 
					{
						if ( l_ca_caentitlement_struct_h->h_entitl_pos < 0 )
						{
									/* Commented By Sana as same is getting printed in failure log CO_ProcMonitor(g_logfile,"Entitlement  positions were calculated to be negative",NULL,NULL); */
									/**Sana [ISAB 108][RBS][30-12-2010]**/
									sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s| Entitlement positions were calculated to be negative.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
									CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL); 
									/**End**/
						}
					}
				  
				  if((!strcmp(g_ca_caevent_struct_h.h_entl_send_msg_ind,APL_YES_IND))&&(elig_entitl_pos >=0 ))//Added by Anjaneyulu on 21/05/2015 for ISKB_1621 entitl_pos>=0
				  {
					  if ( (CA_SendEntitlChgMsg(	g_ca_caevent_struct_h.h_evt_class,
												  g_ca_caevent_struct_h.h_corp_id,
												  l_ca_caentitlement_struct_h->h_dl_client,
												  l_debug_info_ptr) == APL_FAILURE) )
						  APL_GOBACK_FAIL
				  }	
				
				if (elig_entitl_pos >=0 )
				{
					totquantity_bal =l_ca_caentitlement_struct_h->h_quantity_due - l_ca_tbcaentitlement_struct_h->h_quantity_due;
					totamount_bal =l_ca_caentitlement_struct_h->h_instr_inc_bal - l_ca_tbcaentitlement_struct_h->h_instr_inc_bal;
					totfract_due = l_ca_caentitlement_struct_h->h_fract_due - l_ca_tbcaentitlement_struct_h->h_fract_due;
			   }
				else
				{
					totquantity_bal = (-1 * l_ca_tbcaentitlement_struct_h->h_quantity_due); 
					totamount_bal = (-1 * l_ca_tbcaentitlement_struct_h->h_instr_inc_bal);
					totfract_due =(-1 *l_ca_caentitlement_struct_h->h_fract_due);
				}
				int_noacs =0;				
				entl_msg_cnt =0;
			}

   strcpy(chr_l_entstrpos,APL_NULL_STRING);
   strcpy(chr_l_incstrdue,APL_NULL_STRING);
   strcpy(chr_l_qtystrdue,APL_NULL_STRING);
   strcpy(chr_l_oldentstrpos,APL_NULL_STRING);
   strcpy(chr_l_oldincstrdue,APL_NULL_STRING);
   strcpy(chr_l_oldqtystrdue,APL_NULL_STRING);

   strcpy(chr_l_client_a,l_ca_caentitlement_struct_h->h_dl_client);
   strcpy(chr_l_instrcode_a,g_ca_caevent_struct_h.h_instr_code);

   if(APL_FAILURE == CO_PadString(chr_l_client_a,'R',10," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);
				/**Sana [ISAB 108][RBS][30-12-2010]**/
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2437|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				/**End**/
     APL_GOBACK_FAIL
   }

   if(APL_FAILURE == CO_PadString(chr_l_instrcode_a,'R',8," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);
			 /**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2448|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
			 /**End**/
     APL_GOBACK_FAIL
   }

   if(APL_FAILURE == CO_ToStr(l_ca_tbcaentitlement_struct_h->h_entitl_pos,25,4,chr_l_oldentstrpos))
   {
				/**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2457|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				/**End**/
         APL_GOBACK_FAIL
   }

   if(APL_FAILURE == CO_PadString(chr_l_oldentstrpos,'R',25," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);
			 /**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2467|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
			 /**End**/
     APL_GOBACK_FAIL
   }
   if(APL_FAILURE == CO_ToStr(l_ca_tbcaentitlement_struct_h->h_instr_inc_bal,25,4,chr_l_oldincstrdue))
   {
				/**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2475|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				/**End**/
      APL_GOBACK_FAIL
   }
   if(APL_FAILURE == CO_PadString(chr_l_oldincstrdue,'R',25," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);
			 /**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2484|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
			 /**End**/
     APL_GOBACK_FAIL
   }
      if(APL_FAILURE == CO_ToStr(l_ca_tbcaentitlement_struct_h->h_quantity_due,25,4,chr_l_oldqtystrdue))
      {
				/**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2492|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				/**End**/
         APL_GOBACK_FAIL
      }
   if(APL_FAILURE == CO_PadString(chr_l_oldqtystrdue,'R',25," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);
			 /**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2501|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
			 /**End**/
     APL_GOBACK_FAIL
   }

     if(APL_FAILURE == CO_ToStr(l_ca_caentitlement_struct_h->h_entitl_pos,25,4,chr_l_entstrpos))
      {
				/**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2511|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				/**End**/
         APL_GOBACK_FAIL
      }
   if(APL_FAILURE == CO_PadString(chr_l_entstrpos,'R',25," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);
			 /**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2519|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
			 /**End**/
     APL_GOBACK_FAIL
   }
      if(APL_FAILURE == CO_ToStr(l_ca_caentitlement_struct_h->h_instr_inc_bal,25,4,chr_l_incstrdue))
      {
				/**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2527|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				/**End**/
         APL_GOBACK_FAIL
      }
   if(APL_FAILURE == CO_PadString(chr_l_incstrdue,'R',25," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);
				/**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2536|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				/**End**/
     APL_GOBACK_FAIL
   }
      if(APL_FAILURE == CO_ToStr(l_ca_caentitlement_struct_h->h_quantity_due,25,4,chr_l_qtystrdue))
      {
				/**Sana [ISAB 108][RBS][30-12-2010]**/	
			 sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2544|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
			 CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				/**End**/
         APL_GOBACK_FAIL
      }
   if(APL_FAILURE == CO_PadString(chr_l_qtystrdue,'R',25," ",l_debug_info_ptr))
   {
     CO_ProcMonitor(g_logfile,"Failure in CO_PadString Function for l_account",NULL,NULL);
				/**Sana [ISAB 108][RBS][30-12-2010]**/	
				sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Error during Entitlement Generation, Reason : Failure in CA_GenEntitl.pc|2553|Internal Error Occured. Contact Support team.\n",g_ca_caevent_struct_h.h_corp_id,l_ca_caentitlement_struct_h->h_dl_client);
				CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
				/**End**/
     APL_GOBACK_FAIL
   }
   fprintf(l_repfile,"MODIFIED    %s%6s",chr_l_instrcode_a," ");
   fprintf(l_repfile,"%s%11s",g_ca_caevent_struct_h.h_evt_class," ");
	
	if (strlen(ltoa(g_ca_caevent_struct_h.h_evt_nbr)) == 1 )
  		fprintf(l_repfile,"%d%5s",g_ca_caevent_struct_h.h_evt_nbr," ");
	else
		fprintf(l_repfile,"%d%4s",g_ca_caevent_struct_h.h_evt_nbr," ");
   /* fprintf(l_repfile,"%s%1s",chr_l_client_a);  ** Fix Given for Log No: ISKB_3095 - Naren V - Dec2009 **/ 
   fprintf(l_repfile,"%s%1s",chr_l_client_a, " "); 
   fprintf(l_repfile,"%s%1s",chr_l_oldentstrpos," ");
   fprintf(l_repfile,"%s%1s",chr_l_entstrpos," ");
      if ( (!strcmp(g_ca_caevent_struct_h.h_evt_class,"CD")) || (!strcmp(g_ca_caevent_struct_h.h_evt_class,"BI")) || (!strcmp(g_ca_caevent_struct_h.h_evt_class,"RD")))
   	   	{
					fprintf(l_repfile,"%s%1s",chr_l_oldincstrdue," ");
					fprintf(l_repfile,"%s\n",chr_l_incstrdue);
      		}
      		else
				{
					fprintf(l_repfile,"%s%1s",chr_l_oldqtystrdue," ");
         		fprintf(l_repfile,"%s\n",chr_l_qtystrdue);
				}
         }
		}
	} 
	 	memset(chr_sys_date_time,NULL,APL_DATE_LEN);
	 	if ( CO_RtvSysDtTime(	chr_sys_date_time,l_debug_info_ptr)== APL_FAILURE )
		 	APL_GOBACK_FAIL

	 	EXEC SQL UPDATE CAEVENT SET 
	 	amount_bal		=	amount_bal + :totamount_bal,
	 	quantity_bal		=	quantity_bal + :totquantity_bal ,
	 	ENTL_CLT_CNT		=	ENTL_CLT_CNT+ :int_noacs,
		FRACT_QTY_BAL         =  FRACT_QTY_BAL +:totfract_due,
	 	entl_msg_cnt	=	entl_msg_cnt+ :entl_msg_cnt,
	 	PROCESSED_DATE		=	:chr_g_sys_date,
	 	access_stamp=	:chr_sys_date_time
	 	WHERE corp_id =	:g_ca_caevent_struct_h.h_corp_id; 	

	 	IS_ANY_ORA_ERROR

		
		APL_IF_DEBUG
		{
			printf("Updated CAEVENT Details...\n");
		}	

		if ( CA_Commit(APL_SUCCESS,S_LEVEL_ENTITL,l_debug_info_ptr) == APL_FAILURE )
			APL_GOBACK_FAIL
	}
		if ( break_flg == 1 )
		 {
			break;
		 }
	}
	printf("\nClosing cursors....");
      if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
            && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0)
            &&(int_date_diff==0))
      {
      sprintf(chr_g_log_buff,"E:CLOSE Accountcur1");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
      EXEC SQL CLOSE AaccountCur1;
      IS_ANY_ORA_ERROR
      }
      else if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
                  && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0)
               &&(int_date_diff==0))
      {
      sprintf(chr_g_log_buff,"E:CLOSE Accountcur2");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
      EXEC SQL CLOSE AaccountCur2;
      IS_ANY_ORA_ERROR
      }
      else if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
               &&(int_date_diff > 0)
					&& (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0))
      {
      sprintf(chr_g_log_buff,"E:CLOSE Accountcur3");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
      EXEC SQL CLOSE AaccountCur3;
      IS_ANY_ORA_ERROR
      }
      else if((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
               &&(int_date_diff > 0)
               && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0))
		{
      sprintf(chr_g_log_buff,"E:CLOSE Accountcur6");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
      EXEC SQL CLOSE AaccountCur6;
      IS_ANY_ORA_ERROR
		}
      else  if ((strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0)  && (int_g_flg_mod_event == 0)
					 &&(int_date_diff >=0))
      {
      sprintf(chr_g_log_buff,"E:CLOSE Accountcur4");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
      EXEC SQL CLOSE AaccountCur4;
      IS_ANY_ORA_ERROR
      }
      else if ((strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0) && (int_g_flg_mod_event == 0)
					&&(int_date_diff >=0))
      {
      sprintf(chr_g_log_buff,"E:CLOSE Accountcur5");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
      EXEC SQL CLOSE AaccountCur5;
      IS_ANY_ORA_ERROR
      }
      else if  (int_g_flg_mod_event == 1)
      {
      sprintf(chr_g_log_buff,"E:CLOSE Accountcur7");
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
      EXEC SQL CLOSE AaccountCur7;
      IS_ANY_ORA_ERROR
      }
	/* Added By Sana for entitlement opt - end */
	
      /*Commented by Sana for entitlement opt if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
            && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0)
            &&(int_date_diff==0))
      {
					  sprintf(chr_g_log_buff,"E:CLOSE Accountcur1");
					  CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
					  EXEC SQL CLOSE AaccountCur1;
					  IS_ANY_ORA_ERROR
      }
      else if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
                  && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0)
               &&(int_date_diff==0))
      {
					  sprintf(chr_g_log_buff,"E:CLOSE Accountcur2");
					  CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
					  EXEC SQL CLOSE AaccountCur2;
					  IS_ANY_ORA_ERROR
      }
      else if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
               &&(int_date_diff > 0)
					&& (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0))
      {
					  sprintf(chr_g_log_buff,"E:CLOSE Accountcur3");
					  CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
					  EXEC SQL CLOSE AaccountCur3;
					  IS_ANY_ORA_ERROR
      }
      else if((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
               &&(int_date_diff > 0)
               && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0))
		{
					  sprintf(chr_g_log_buff,"E:CLOSE Accountcur6");
					  CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
					  EXEC SQL CLOSE AaccountCur6;
					  IS_ANY_ORA_ERROR
		}
      else  if ((strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0)  && (int_g_flg_mod_event == 0)
					 &&(int_date_diff >=0))
      {
					  sprintf(chr_g_log_buff,"E:CLOSE Accountcur4");
					  CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
					  EXEC SQL CLOSE AaccountCur4;
					  IS_ANY_ORA_ERROR
      }
      else if ((strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0) && (int_g_flg_mod_event == 0)
					&&(int_date_diff >=0))
      {
					  sprintf(chr_g_log_buff,"E:CLOSE Accountcur5");
					  CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
					  EXEC SQL CLOSE AaccountCur5;
					  IS_ANY_ORA_ERROR
      }
      else if  (int_g_flg_mod_event == 1)
      {
					  sprintf(chr_g_log_buff,"E:CLOSE Accountcur7");
					  CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
					  EXEC SQL CLOSE AaccountCur7;
					  IS_ANY_ORA_ERROR
      } end*/

		strcpy(chr_g_client," ");

         memset(chr_sys_date_time,NULL,APL_DATE_LEN);
         if ( CO_RtvSysDtTime( chr_sys_date_time,
                                    l_debug_info_ptr)== APL_FAILURE )
            APL_GOBACK_FAIL
 

		/*Smita - Name Change Event Process - HDFCCA_027*/
		if (	(strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL) == 0) &&
				(strcmp(g_ca_caevent_struct_h.h_evt_class, EVT_NM_CHNG) == 0)	)
		{
			sprintf(chr_g_log_buff,"Entered Name Change Event Processing");
			CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);

			APL_IF_DEBUG
			{
				printf("Company Code = |%s|\n",g_ca_caevent_struct_h.h_cmp_code);
				printf("Resultant Company Code = |%s|\n",g_ca_caevent_struct_h.h_res_cmp_code);
				printf("Now checking Validity of both Company Codes..\n");
			}
		
			if (CA_ChkCompany(g_ca_caevent_struct_h.h_cmp_code,
					&l_mt_company_struct_h,
					&int_result,
					l_debug_info_ptr) == APL_FAILURE)
				APL_GOBACK_FAIL

			CO_FreeErrLst(l_debug_info_ptr);
      	if ( int_result == ERR_COMPANY_NOTFND)
		   {
			  /* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/	
				EXEC SQL ROLLBACK;
			/*	CA_WriteAlert((&l_ca_canotify_struct_h),
						         chr_g_funccode,
								   chr_warn_cd_cmpnf,	
									g_ca_caevent_struct_h.h_corp_id,
									APL_NULL_STRING,
									g_ca_caevent_struct_h.h_cmp_code)
			  EXEC SQL COMMIT;
			  */
			  	 /* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/
	         /* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,"E:Company %s does not exist,skipping event\n",g_ca_caevent_struct_h.h_cmp_code);
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
		 /**Sana [ISAB 108][RBS][30-12-2010]**/
		 sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Company %s does not exist\n",g_ca_caevent_struct_h.h_corp_id,g_ca_caevent_struct_h.h_cmp_code);
         CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
		 /**End**/
         if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
            APL_GOBACK_FAIL
         else
            continue;
      	}
      	if ( int_result == ERR_COMPANY_NOT_AUTHORIZED )
     		{
			/* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/ 	
         EXEC SQL ROLLBACK;
        /* CA_WriteAlert((&l_ca_canotify_struct_h),
                        chr_g_funccode,
                        chr_warn_cd_cmpunauth,
                        g_ca_caevent_struct_h.h_corp_id,
                        APL_NULL_STRING,
                        g_ca_caevent_struct_h.h_cmp_code)
         EXEC SQL COMMIT;
		 */
		 	/* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/	
         /* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,"E:Company %s unauthorised ,skipping event\n",g_ca_caevent_struct_h.h_cmp_code);
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
		 /**Sana [ISAB 108][RBS][30-12-2010]**/
		 sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Company %s is unauthorised\n",g_ca_caevent_struct_h.h_corp_id,g_ca_caevent_struct_h.h_cmp_code);
         CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
		 /**End**/
         if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
            APL_GOBACK_FAIL
         else
            continue;
      	}
				if (CA_ChkCompany(g_ca_caevent_struct_h.h_res_cmp_code,
					&l_mt_company_struct_h,
					&int_result,
					l_debug_info_ptr) == APL_FAILURE)
				APL_GOBACK_FAIL

			CO_FreeErrLst(l_debug_info_ptr);
      	if ( int_result == ERR_COMPANY_NOTFND)
		   {
			   /* Commented by Swapnil for Entitlement Optimization Changes Starts 	*/
				EXEC SQL ROLLBACK;
			/* 	CA_WriteAlert((&l_ca_canotify_struct_h),
						         chr_g_funccode,
								   chr_warn_cd_cmpnf,	
									g_ca_caevent_struct_h.h_corp_id,
									APL_NULL_STRING,
									g_ca_caevent_struct_h.h_res_cmp_code)
			  EXEC SQL COMMIT;
			  */
			  	/* Commented by Swapnil for Entitlement Optimization Changes Ends 	*/
	         /* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,"E:Resultant Company %s does not exist,skipping event\n",g_ca_caevent_struct_h.h_res_cmp_code);
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
		 /**Sana [ISAB 108][RBS][30-12-2010]**/
		 sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Resultant Company %s does not exist\n",g_ca_caevent_struct_h.h_corp_id,g_ca_caevent_struct_h.h_res_cmp_code);
         CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
		 /**End**/
         if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
            APL_GOBACK_FAIL
         else
            continue;
      	}
      	if ( int_result == ERR_COMPANY_NOT_AUTHORIZED )
     		{
         EXEC SQL ROLLBACK;
       /* Commented by Swapnil for Entitlement Optimization Changes Starts
       CA_WriteAlert((&l_ca_canotify_struct_h),
                        chr_g_funccode,
                        chr_warn_cd_cmpunauth,
                        g_ca_caevent_struct_h.h_corp_id,
                        APL_NULL_STRING,
                        g_ca_caevent_struct_h.h_res_cmp_code)
         EXEC SQL COMMIT;
		 */

         /* Commented By Sana as same is getting printed in failure log sprintf(chr_g_log_buff,"E:Resultant Company %s unauthorised ,skipping event\n",g_ca_caevent_struct_h.h_res_cmp_code);
         CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);*/
		 /**Sana [ISAB 108][RBS][30-12-2010]**/
		 sprintf(chr_g_fail_buff,"  Event |%s| Skipped, Reason : Resultant Company %s is unauthorised\n",g_ca_caevent_struct_h.h_corp_id,g_ca_caevent_struct_h.h_res_cmp_code);
         CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
		 /**End**/
         if (CA_Commit(APL_FAILURE,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE)
            APL_GOBACK_FAIL
         else
            continue;
      	}

			EXEC SQL UPDATE MT_INSTRUMENT
		 				SET CMP_CODE = :g_ca_caevent_struct_h.h_res_cmp_code
		 				WHERE CMP_CODE = :g_ca_caevent_struct_h.h_cmp_code
						AND   STATUS = 'AA';

			IS_ANY_ORA_ERROR

			sprintf(chr_g_log_buff,"Exiting Name Change Event Processing");
			CO_ProcMonitor(g_logfile,chr_g_log_buff,NULL,NULL);
		}
		/*Smita - Name Change Event Process - HDFCCA_027*/
                /* Added By Santhoshi for PEG-CA-ENH-2.3 --START - retro by Sana Bhatkar */
			EXEC SQL SELECT /*+ALL_ROWS*/ CLOSURE_DT_DAYS INTO :q_ca_caseceventstruct_h->h_closure_dt_days
			FROM CASECEVENT
			WHERE CA_EVENT=:q_ca_caseceventstruct_h->h_ca_event
			AND INSTR_TYPE=:q_ca_caseceventstruct_h->h_typeofinstr;
		/* Added By Santhoshi for PEG-CA-ENH-2.3 --END -- retro by Sana Bhatkar */
		if ( !strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL) )
		{
			
			if(!strcmp(g_ca_caevent_struct_h.h_evt_class, EVT_OFFER) 
			&& (g_ca_caevent_struct_i.i_res_instr_code == -1))
			{
				
				//printf("\n Amit:Here1 \n");
				printf("\n Amit:g_ca_caevent_struct_h.h_res_instr_code=|%s| \n",g_ca_caevent_struct_h.h_res_instr_code);
				//fprintf(g_logfile,"\n Amit:Here1 \n");
				fprintf(g_logfile,"\n Amit:g_ca_caevent_struct_h->h_res_instr_code=|%s| \n",g_ca_caevent_struct_h.h_res_instr_code);
				
				EXEC SQL UPDATE CAEVENT SET 
				status	=	'CP',
				PROCESSED_DATE		=	:chr_g_sys_date,
				access_stamp=	:chr_sys_date_time
				WHERE corp_id =	:g_ca_caevent_struct_h.h_corp_id; 	
				IS_ANY_ORA_ERROR
			}
			else if(	(strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_NM_CHNG) != 0) && /* Smita- HDFCCA_027*/
					   (strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_BUY_BACK) != 0)	) /*Smita - HDFCCA_009*/
			{
                                /* Added By Santhoshi for PEG-CA-ENH-2.3 --START - retro by Sana Bhatkar */
				// To check holdings of client and  status to 'RP' if client has holdings
				printf("g_ca_caevent_struct_h.h_instr_code is |%s| \n",g_ca_caevent_struct_h.h_instr_code);
				printf("elig_entitl_pos |%lf| \n",elig_entitl_pos);
				Alert("tot_elig_entitl_pos is |%lf|",tot_elig_entitl_pos);
				//if(elig_entitl_pos != 0) // Commented by Gouse for Prod Issue - ISKB_5945
				if (tot_elig_entitl_pos !=0 ) // Added by Gouse for Prod Issue - ISKB_5945
				{
					printf("in  status to RP \n" );
					/* Added By Santhoshi for PEG-CA-ENH-2.3 --END -- retro by Sana Bhatkar */ 

				EXEC SQL UPDATE CAEVENT SET 
				status	=	'RP',
				PROCESSED_DATE		=	:chr_g_sys_date,
				access_stamp=	:chr_sys_date_time
				WHERE corp_id =	:g_ca_caevent_struct_h.h_corp_id; 	
				IS_ANY_ORA_ERROR
                                }
			}
		}
			/*Smita - Name Change Event Process - HDFCCA_027*/
		
			if ((strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_NM_CHNG) == 0) && (int_date_diff==0) && (strlen(g_ca_caevent_struct_h.h_effect_date)!=0))
			{
					EXEC SQL UPDATE CAEVENT SET
								status = 'SN',
								PROCESSED_DATE    =  :chr_g_sys_date,
					  			access_stamp=  :chr_sys_date_time
								WHERE corp_id =   :g_ca_caevent_struct_h.h_corp_id;
			}
			/*Smita - HDFCCA_009 - Buy Back Event*/
			else if (	(strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_BUY_BACK) == 0) &&
							(int_date_diff == 0) )
			{
				EXEC SQL UPDATE CAEVENT SET
								status = 'SN',
								PROCESSED_DATE    =  :chr_g_sys_date,
								access_stamp=  :chr_sys_date_time
								WHERE corp_id =   :g_ca_caevent_struct_h.h_corp_id;
			}
			/*Smita - HDFCCA_009 - Buy Back Event*/
			else if(	(strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_NM_CHNG) !=0) && /*Smita - HDFCCA_027*/
					 	(strcmp(g_ca_caevent_struct_h.h_evt_class,EVT_BUY_BACK) !=0)	)/*Smita - HDFCCA_009*/
			{		
				printf("\n Amit:Here2 \n");
				printf("\n Amit:g_ca_caevent_struct_h.h_evt_class=|%s| \n",g_ca_caevent_struct_h.h_evt_class);
				fprintf(g_logfile,"\n Amit:Here2 \n");
				fprintf(g_logfile,"\n Amit:g_ca_caevent_struct_h.h_evt_class=|%s| \n",g_ca_caevent_struct_h.h_evt_class);
				IF_COND_EXISTS("CA_ENTITLEMENT","REC_DATE") /* kotak retro by Lakshmi Swetha - start */
				{
					/* Added By Santhoshi for PEG-CA-ENH-2.3 --START - retro by Sana Bhatkar */
					/* To check whether pro_sys_date  is greater than or equal to event closure date i.e Ex-Date + CLOSURE_DT_DAYS and updating event status to 'CP'*/
				printf("g_ca_caevent_struct_h.h_ex_date |%s| \n",g_ca_caevent_struct_h.h_ex_date);
				printf("q_ca_caseceventstruct_h->h_closure_dt_days |%d| \n",q_ca_caseceventstruct_h->h_closure_dt_days);
					printf("chr_g_closure_dt before |%s| \n",chr_g_closure_dt);

					EXEC SQL SELECT TO_DATE(:g_ca_caevent_struct_h.h_ex_date) + :q_ca_caseceventstruct_h->h_closure_dt_days
						INTO :chr_g_closure_dt FROM DUAL;
					IS_ANY_ORA_ERROR

					printf("chr_g_closure_dt after |%s| \n",chr_g_closure_dt);
					printf("chr_g_sys_date |%s| \n",chr_g_sys_date);

					if (strcmp(chr_g_closure_dt,APL_NULL_STRING) != 0)
					{
						EXEC SQL SELECT TO_DATE(:chr_g_sys_date) - TO_DATE(:chr_g_closure_dt)
							INTO :int_date_diff_cp :i_date_diff_cp from dual;
						IS_ANY_ORA_ERROR
					}
					printf("int_date_diff_cp after calc second|%d| \n",int_date_diff_cp);

					/* Changed for UAT issue to close event on BOD of close date plus 1 day
					if(int_date_diff_cp >= 0) */
					if(int_date_diff_cp > 0)
					{/* Added By Santhoshi for PEG-CA-ENH-2.3 --END*/                                
						Alert("Event Will Be marked Paid and Closed as Closure date has been passed");
						fflush(stdout);
						EXEC SQL UPDATE CAEVENT SET 
									status	=	'CP',
									PROCESSED_DATE		=	:chr_g_sys_date,
									access_stamp=	:chr_sys_date_time
									WHERE corp_id =	:g_ca_caevent_struct_h.h_corp_id
											AND NOT EXISTS
											( SELECT 1 FROM CAENTITLEMENT
												WHERE CAENTITLEMENT.corp_id=:g_ca_caevent_struct_h.h_corp_id 	);
						fprintf(g_logfile,"\n Updating Event1|%d| \n",sqlca.sqlcode);
						l_int_res_1 = sqlca.sqlcode;
						IS_ANY_ORA_ERROR

						EXEC SQL UPDATE CAEVENT SET 
						STATUS	=	'CP',
						PROCESSED_DATE = :chr_g_sys_date,
						ACCESS_STAMP = :chr_sys_date_time
						WHERE CORP_ID =	:g_ca_caevent_struct_h.h_corp_id
						AND 0 = (
						SELECT COUNT(*) FROM CAENTITLEMENT WHERE CORP_ID =:g_ca_caevent_struct_h.h_corp_id
							AND STATUS NOT IN ('RV','DL','NP','CP'));
						fprintf(g_logfile,"\n Updating Event2|%d| \n",sqlca.sqlcode);
						l_int_res_2 = sqlca.sqlcode;
						IS_ANY_ORA_ERROR
						/**Sana [ISAB 108][RBS][30-12-2010]**/
						if(l_int_res_1 == 0 || l_int_res_2 == 0)
						{
							sprintf(chr_g_fail_buff,"  Event |%20s| Closed, Reason : Closure date greater than/equal to the system date.\n",g_ca_caevent_struct_h.h_corp_id);
							CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
						}
						/**End**/
					}
                 }
                  /* Added By Santhoshi for PEG-CA-ENH-2.3 --END - Retro by Sana Bhatkar */
                 else
                 {
					/* Added By Santhoshi for PEG-CA-ENH-2.3 --START - retro by Sana Bhatkar */
					/* To check whether pro_sys_date  is greater than or equal to event closure date i.e Ex-Date + CLOSURE_DT_DAYS and updating event status to 'CP'*/
				printf("g_ca_caevent_struct_h.h_ex_date  |%s| \n",g_ca_caevent_struct_h.h_ex_date);
				printf("q_ca_caseceventstruct_h->h_closure_dt_days |%d| \n",q_ca_caseceventstruct_h->h_closure_dt_days);
					printf("chr_g_closure_dt before |%s| \n",chr_g_closure_dt);

					EXEC SQL SELECT TO_DATE(:g_ca_caevent_struct_h.h_ex_date) + :q_ca_caseceventstruct_h->h_closure_dt_days
						INTO :chr_g_closure_dt FROM DUAL;
					IS_ANY_ORA_ERROR

					printf("chr_g_closure_dt after |%s| \n",chr_g_closure_dt);
					printf("chr_g_sys_date |%s| \n",chr_g_sys_date);

					if (strcmp(chr_g_closure_dt,APL_NULL_STRING) != 0)
					{
						EXEC SQL SELECT TO_DATE(:chr_g_sys_date) - TO_DATE(:chr_g_closure_dt)
							INTO :int_date_diff_cp :i_date_diff_cp from dual;
						IS_ANY_ORA_ERROR
					}
					printf("int_date_diff_cp after calc second|%d| \n",int_date_diff_cp);

					/* Changed for UAT issue to close event on BOD of close date plus 1 day
					if(int_date_diff_cp >= 0) */
					if(int_date_diff_cp > 0)
					{/* Added By Santhoshi for PEG-CA-ENH-2.3 --END*/                                
						Alert("Event Will Be marked Paid and Closed as Closure date has been passed");
						fflush(stdout);
					EXEC SQL UPDATE CAEVENT SET 
					status	=	'CP',
					PROCESSED_DATE		=	:chr_g_sys_date,
					access_stamp=	:chr_sys_date_time
					WHERE corp_id =	:g_ca_caevent_struct_h.h_corp_id
							AND NOT EXISTS
								( SELECT 1 FROM CAENTITLEMENT
								WHERE CAENTITLEMENT.corp_id=:g_ca_caevent_struct_h.h_corp_id 	);
					fprintf(g_logfile,"\n Updating Event1|%d| \n",sqlca.sqlcode);
						l_int_res_1 = sqlca.sqlcode;
					IS_ANY_ORA_ERROR

					EXEC SQL UPDATE CAEVENT SET 
					STATUS	=	'CP',
					PROCESSED_DATE = :chr_g_sys_date,
					ACCESS_STAMP = :chr_sys_date_time
					WHERE CORP_ID =	:g_ca_caevent_struct_h.h_corp_id
					AND 0 = (
					SELECT COUNT(*) FROM CAENTITLEMENT WHERE CORP_ID =:g_ca_caevent_struct_h.h_corp_id
						AND STATUS NOT IN ('RV','DL','NP','CP'));
					fprintf(g_logfile,"\n Updating Event2|%d| \n",sqlca.sqlcode);
						l_int_res_2 = sqlca.sqlcode;
					IS_ANY_ORA_ERROR     
						/**Sana [ISAB 108][RBS][30-12-2010]**/
						if(l_int_res_1 == 0 || l_int_res_2 == 0)
						{
							sprintf(chr_g_fail_buff,"  Event |%20s| Closed, Reason : Closure date greater than/equal to the system date.\n",g_ca_caevent_struct_h.h_corp_id);
							CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
						}
						/**End**/
                  }
}/* Added By Santhoshi for PEG-CA-ENH-2.3*/
			}

			/*Smita - Name Change Event Process - HDFCCA_027*/
			EXEC SQL DELETE FROM CACHGEVENT 
						WHERE corp_id = :g_ca_caevent_struct_h.h_corp_id;

			IS_ANY_ORA_ERROR
			

		if ( CA_Commit(APL_SUCCESS,S_LEVEL_EVENT,l_debug_info_ptr) == APL_FAILURE )
			APL_GOBACK_FAIL

	}


		
		APL_GOBACK_SUCCESS
		RETURN_SUCCESS:
		{
			CO_Proc_RptClose(l_repfile,l_debug_info_ptr);
			APL_FREE(l_ca_caentitlement_struct_h);
			APL_FREE(l_ca_caentitlement_struct_i);
			APL_FREE(l_ca_tbcaentitlement_struct_h);
			APL_FREE(l_ca_tbcaentitlement_struct_i);
			APL_FREE(q_ca_caseceventstruct_h);
			APL_FREE(l_ca_casecevent_struct_i);
			return (APL_SUCCESS);
		}
		RETURN_FAILURE:
		{
			CO_Proc_RptClose(l_repfile,l_debug_info_ptr);
			APL_FREE(l_ca_caentitlement_struct_h);
			APL_FREE(l_ca_caentitlement_struct_i);
			APL_FREE(l_ca_tbcaentitlement_struct_h);
			APL_FREE(l_ca_tbcaentitlement_struct_i);
			APL_FREE(q_ca_caseceventstruct_h);
			APL_FREE(l_ca_casecevent_struct_i);
			return (APL_FAILURE);
		}
}




static int CA_CalcEntitlPos(	short						p_safek_flg,
									CA_CASECEVENT_STRUCT_H   *p_ca_casecevent_struct_h,
									char						*p_rec_date_h,
									char						*chr_p_client,
									double					*p_entpos,
									DEBUG_INFO_STRUCT_H			**l_debug_info_ptr)

{ 		
	struct sqlca sqlca;
	char		chr_prev_rec_dt	[APL_DATE_LEN];
	int		int_h_count=0;
	double	posn_adj=0.00;
	int		int_h_date_diff=0;
	double	h_sum_hissafekeep_pos;
	short		i_date_diff,
				i_sum_hissafek;
 	double 	h_backtrdinp_quantity = 0.00;
	double   h_del_backtrdinp_quantity = 0.00;
	short		i_backtrdinp_qty = 0;
	short		i_del_backtrdinp_qty = 0;
	double 	h_old_elig_entitl_pos = 0.00;
	short 	i_old_ent_pos = 0;

   char  chr_mainfuncarea_h [APL_MAINFUNCAREA_LEN];
   char  chr_condid_h       [APL_CONDID_LEN];
   short Cond_exists_h;
   short Cond_exists_tr;
	double l_future_pos = 0.0;

   EXEC SQL VAR chr_mainfuncarea_h IS STRING;
   EXEC SQL VAR chr_condid_h IS STRING;


		memset(&g_position_h,NULL,sizeof(S_POSITION_STRUCT_H));
		memset(&g_position_i,NULL,sizeof(S_POSITION_STRUCT_I));

		APL_IF_DEBUG
		{
			printf("Inside Fn CA_CalcEntitlPos with p_safek_flg = |%d|\n",p_safek_flg);
			printf("Client = |%s|\n",chr_p_client);
			printf("Instr Code = |%s|\n",g_ca_caevent_struct_h.h_instr_code);
		}
		switch(p_safek_flg)
		{
			 case 1 :
			  EXEC SQL SELECT /*+ ALL_ROWS */ instr_code,client,SUM(NVL(safekeep_pos,0)),
			  SUM(NVL(NVALRECEIVE,0)),SUM(NVL(NVALDELIVER,0)),
			  SUM(NVL(VAL_REC,0)),SUM(NVL(VAL_DEL,0)),SUM(NVL(DP_REC,0)),SUM(NVL(DP_DEL,0)) INTO
			  :g_position_h :g_position_i
			  FROM DL_SAFEK
			  WHERE	 instr_code = :g_ca_caevent_struct_h.h_instr_code
			  AND	client =:chr_p_client
			  AND STATUS in ('000','001','002','003')
			  GROUP BY instr_code,client;
			  IS_ANY_ORA_ERROR
				break;

			 case 2 :
			  EXEC SQL SELECT /*+ ALL_ROWS */ instr_code,client,SUM(NVL(safekeep_pos,0)),
			  SUM(NVL(NVALRECEIVE,0)),SUM(NVL(NVALDELIVER,0)),
			  SUM(NVL(VAL_REC,0)),SUM(NVL(VAL_DEL,0)),SUM(NVL(DP_REC,0)),SUM(NVL(DP_DEL,0)) into 
			  :g_position_h :g_position_i
			  FROM DL_SAFEK
			  WHERE	 instr_code = :g_ca_caevent_struct_h.h_instr_code
			  AND	client =:chr_p_client 
			  AND STATUS in ('002','003')
			  GROUP BY instr_code,client;
			  IS_ANY_ORA_ERROR
				break;

			 case 3 :
			  EXEC SQL SELECT /*+ ALL_ROWS */ instr_code,client,SUM(NVL(safekeep_pos,0)),
			  SUM(NVL(NVALRECEIVE,0)),SUM(NVL(NVALDELIVER,0)),
			  SUM(NVL(VAL_REC,0)),SUM(NVL(VAL_DEL,0)),SUM(NVL(DP_REC,0)),SUM(NVL(DP_DEL,0)) into 
			  :g_position_h :g_position_i
			  FROM DL_SAFEK
			  WHERE		 instr_code = :g_ca_caevent_struct_h.h_instr_code
			  AND	client =:chr_p_client
			  GROUP BY instr_code,client;
			  IS_ANY_ORA_ERROR
				break;

          case 4 :
           EXEC SQL SELECT /*+ ALL_ROWS */ instr_code,client,SUM(NVL(safekeep_pos,0)),
           SUM(NVL(NVALRECEIVE,0)),SUM(NVL(NVALDELIVER,0)),
           SUM(NVL(VAL_REC,0)),SUM(NVL(VAL_DEL,0)),SUM(NVL(DP_REC,0)),SUM(NVL(DP_DEL,0)) into
           :g_position_h :g_position_i
           FROM DL_SAFEK A,MT_LOCATION B
           WHERE      A.INSTR_CODE = :g_ca_caevent_struct_h.h_instr_code
           AND A.LOCATION_CD=B.LOCATION_CD
           AND INSTR(NVL(B.STATUS_POS,' '),'Y')!=0
           AND A.CLIENT =:chr_p_client
           GROUP BY A.INSTR_CODE,A.CLIENT;
           IS_ANY_ORA_ERROR
            break;
		}


	EXEC SQL SELECT TO_DATE(:chr_g_sys_date) - TO_DATE(:p_rec_date_h)
	INTO :int_h_date_diff :i_date_diff from dual;
	IS_ANY_ORA_ERROR
	
	
	

		if	(	!strcmp(p_ca_casecevent_struct_h->h_entitl_base, ENTL_BASE_DL)	)
		{
			*p_entpos	=	 		g_position_h.h_safekeep_pos 
									+	g_position_h.h_val_rec 
									+	g_position_h.h_nval_rec 
									+  g_position_h.h_dp_rec
									-	g_position_h.h_val_del
									-	g_position_h.h_nval_del 
									-  g_position_h.h_dp_del;
		
         
         strcpy(chr_mainfuncarea_h,"CA_ENTITL");
         strcpy(chr_condid_h,"POSN_NOCHECK_BO");
         Cond_exists_tr = 0;
         if(CO_Chk_CntryEnabled(   chr_mainfuncarea_h,
                                 chr_condid_h,
                                 &Cond_exists_tr,
                                 l_debug_info_ptr)==APL_FAILURE)
            APL_GOBACK_FAIL

         if (Cond_exists_tr)
         {
               if(CA_CalcPosnAdj_Tr( p_rec_date_h,
                              chr_g_sys_date,
                              g_ca_caevent_struct_h.h_instr_code,
                              chr_p_client,
                              &posn_adj,
                              l_debug_info_ptr) == APL_SUCCESS)
                  *p_entpos = *p_entpos + posn_adj;
               else
                  APL_GOBACK_FAIL
         }
         else
         {
			if(int_h_date_diff > 0)
				{	if(CA_CalcPosnAdj(	p_rec_date_h,
										chr_g_sys_date,
										g_ca_caevent_struct_h.h_instr_code,
										chr_p_client,
										&posn_adj,
										l_debug_info_ptr) == APL_SUCCESS)
						*p_entpos = *p_entpos + posn_adj;	
					else
						APL_GOBACK_FAIL
				}

         }
				printf("p_entpos is %lf\n",*p_entpos);
		}
		else	if	(	!strcmp(p_ca_casecevent_struct_h->h_entitl_base, ENTL_BASE_SETL)	)
		{
			if(int_h_date_diff > 0)
			{
				h_sum_hissafekeep_pos=0.0;
				int_h_count =0;
				
				EXEC SQL SELECT count(*) into :int_h_count  
				FROM MT_HOLIDAY
				WHERE H_DATE = :p_rec_date_h
				AND	STATUS = 'AA'
				AND BANK_IND = 'Y';
				IS_ANY_ORA_ERROR
				
				if(int_h_count == 1)
				{
	 				memset(chr_prev_rec_dt,NULL,APL_DATE_LEN);
					if(CA_GetPrevBusinessDay(	p_rec_date_h,
														chr_prev_rec_dt,
														l_debug_info_ptr)==APL_FAILURE)
						APL_GOBACK_FAIL
				
					strcpy(p_rec_date_h,chr_prev_rec_dt);
				}	
            EXEC SQL SELECT /*+leading(a,b)*/ SUM(NVL(safekeep_pos,0)) INTO
            :h_sum_hissafekeep_pos:i_sum_hissafek
            FROM DL_HISSAFEK A,MT_LOCATION B
            WHERE A.POSIT_DATE   =  :p_rec_date_h
            AND   A.INSTR_CODE    =  :g_ca_caevent_struct_h.h_instr_code
            AND   A.CLIENT   =  :chr_p_client
            AND A.LOCATION_CD=B.LOCATION_CD
            AND INSTR(NVL(B.STATUS_POS,' '),'Y')!=0;
            IS_ANY_ORA_ERROR
	
				*p_entpos = h_sum_hissafekeep_pos;
			}
			else
				*p_entpos	=	g_position_h.h_safekeep_pos;
		}
		else	if	(	!strcmp(p_ca_casecevent_struct_h->h_entitl_base, ENTL_BASE_REG)	)
		{
			
			strcpy(chr_mainfuncarea_h,"CA_REGN_PROC");
			strcpy(chr_condid_h,"TRD_ADJ");
			if(CO_Chk_CntryEnabled(	chr_mainfuncarea_h,
											chr_condid_h,
											&Cond_exists_h,
											l_debug_info_ptr)==APL_FAILURE)
				APL_GOBACK_FAIL
			else
			{
				if(Cond_exists_h>0)
				{
					double 	markstamp_quantity_h=0.0;
					short		markstamp_qty_i;
					
					EXEC SQL SELECT /*+ ALL_ROWS */ SUM(MRK_DL_FAILQTY + STAMP_QTY) 
					INTO	:markstamp_quantity_h:markstamp_qty_i	
					FROM 	DL_DEAL
					WHERE client 	= :chr_p_client
					AND	instr_code	= :g_ca_caevent_struct_h.h_instr_code;

					IS_ANY_ORA_ERROR
					*p_entpos = ((g_position_h.h_safekeep_pos) 
										- markstamp_quantity_h);	
				}
				else
				{
				
					*p_entpos	=	g_position_h.h_safekeep_pos;
				
					strcpy(chr_mainfuncarea_h,"CA_REGN_PROC");
					strcpy(chr_condid_h,"TRD_ADJ_CSD");

					if(CO_Chk_CntryEnabled(	chr_mainfuncarea_h,
													chr_condid_h,
													&Cond_exists_h,
													l_debug_info_ptr)==APL_FAILURE)
						APL_GOBACK_FAIL
					else
					{
						if(Cond_exists_h>0)
						{
							double	posn_adj=0.0;


							if (CA_HuPosnAdj(  p_rec_date_h,
												g_ca_caevent_struct_h.h_instr_code,
												chr_p_client,
												&posn_adj,
												l_debug_info_ptr) == APL_SUCCESS)
								*p_entpos	= *p_entpos + posn_adj;
							else
								APL_GOBACK_FAIL
						}
					}
				}
			}
		}
	/**IF_COND_EXISTS("CA_ENTITLE","PRIORITY_CALC")
	{
	**/
		if(Process_AttCorpAdj(	g_ca_caevent_struct_h.h_attach_corp_id,
										g_ca_caevent_struct_h.h_instr_code,
										g_ca_caevent_struct_h.h_ex_date,
										chr_p_client,
										g_ca_caevent_struct_h.h_priority,
										*p_entpos,
										&l_future_pos,
										l_debug_info_ptr) == APL_FAILURE)
		{
			Alert("Failed InCalculating attach event adjustment");
			/**Sana[ISAB 108][RBS][30-12-2010]**/
			CO_ProcMonitor(g_logfile,"Failed InCalculating attach event adjustment",NULL,NULL);
	 		sprintf(chr_g_fail_buff,"  Event |%s|, Entitlement Generation Failed, Reason : Failed InCalculating attach event adjustment.\n",g_ca_caevent_struct_h.h_corp_id);
			CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
			/**End**/
			APL_GOBACK_FAIL

		}

		/**
	}**/
	Alert("Positions Before Attach Corp Adjustment (%lf)",*p_entpos);
	*p_entpos   = *p_entpos + l_future_pos;
	Alert("Positions After Attach Corp Adjustment (%lf)",*p_entpos);
	
APL_GOBACK_SUCCESS
	RETURN_SUCCESS:
		APL_FUNCTION_RET_SUCCESS(APL_OUT_FILE)
	RETURN_FAILURE:
		APL_FUNCTION_RET_FAILURE(APL_OUT_FILE)
	
}
					
					
					

					
static int CA_CalcEntitlement( CA_CAEVENT_STRUCT_H		*p_ca_caevent_struct_h,
										CA_CAENTITLEMENT_STRUCT_H	*p_ca_caentitlement_struct_h,
										CA_CASECEVENT_STRUCT_H	*p_ca_casecevent_struct_h,
										double					 p_ent_pos,
										double					 p_nomval,
										char						*p_lst_pay_date,
										char						*p_basis,
										DEBUG_INFO_STRUCT_H			**l_debug_info_ptr )

{	
	struct 	sqlca sqlca;
	char		chr_sys_date_time[APL_DATE_LEN];
	char		chr_mainfuncarea_h	[APL_MAINFUNCAREA_LEN];
	char		chr_condid_h			[APL_CONDID_LEN];
	short 	Trunc_Cond_exists_h;
	int 		int_period_flg1;
	double  	l_elig_entitl_pos_tr =0.0;
	double	ent_quantity=0.00;
	double	round_val= 0.00;
	double   new_round_val=0.00;
	double   round_val_stan=0.00; 
	double	p_calc_value;	
	double 	new_ent_quantity=0.00;
	double   l_precision = 6;
	int		int_period_flg=0;
   int 		h_dec_len = 0;
   double 	new_instr_inc_bal=0.00;
   short 	i_dec_len=0; 
   short 	int_l_exist_a = 0;
	short 	l_keep_fract_cond = 0;  
   char 		chr_l_keep_fract_flag = APL_NULL_CHAR;
   short 	i_keep_fract_flag = 0;
	/* Chirag To Calculate Interest upto Pay Date - 1 for BI */ 
	char		l_pay_date[APL_DATE_LEN] = APL_NULL_STRING; 
	short		i_pay_date = 0;
	/* Chirag To Calculate Interest upto Pay Date - 1 for BI */
	memset(p_ca_caentitlement_struct_h,NULL,sizeof(CA_CAENTITLEMENT_STRUCT_H));

	if ( CO_RtvSysDtTime(chr_sys_date_time,l_debug_info_ptr)	== APL_FAILURE )
		 APL_GOBACK_FAIL

	strcpy(chr_mainfuncarea_h,	"CA_ENTITL");
	strcpy(chr_condid_h,			"NO_TRUNC_ENT_QTY");
	Trunc_Cond_exists_h = 0;

	if(CO_Chk_CntryEnabled(	chr_mainfuncarea_h,
									chr_condid_h,
									&Trunc_Cond_exists_h,
									l_debug_info_ptr)==APL_FAILURE)
		APL_GOBACK_FAIL
   

   strcpy(chr_mainfuncarea_h, "ENTL_GEN_RSLTINSTR");
   strcpy(chr_condid_h,       "KEEP_FRACTION");

   if(CO_Chk_CntryEnabled(   chr_mainfuncarea_h,
                           chr_condid_h,
                           &l_keep_fract_cond,
                           l_debug_info_ptr) == APL_FAILURE)
   APL_GOBACK_FAIL

   if (l_keep_fract_cond > 0 )
   {

      EXEC SQL SELECT /*+ ALL_ROWS */ CLN_FRACT_IND INTO :chr_l_keep_fract_flag:i_keep_fract_flag
               FROM MT_CLIENT
               WHERE CLN_CODE = :chr_g_client;
      IS_ANY_ORA_ERROR
   }

   
	int_period_flg1=0;
	if ( CO_Chk_CcyConvDt("",&int_period_flg1,l_debug_info_ptr) == APL_FAILURE )
		APL_GOBACK_FAIL


	if	(	!strcmp(p_ca_caevent_struct_h->h_evt_class, EVT_CASH_DIV)	|| 
			!strcmp(p_ca_caevent_struct_h->h_evt_class, EVT_DECR_VAL) )  
	{
      int_l_exist_a = 0;
      if (APL_FAILURE  == CO_Chk_CntryEnabled("CA_CASH_DIV","TRUNC_INC_DUE",&int_l_exist_a,l_debug_info_ptr))
      {
         APL_GOBACK_FAIL
      }
      

		/* if (!strcmp(p_ca_casecevent_struct_h->h_amt_rt_ind,AMT_IND)) */
			printf("Postion for Cash Dividend is |%lf|****************************Chirag***\n",p_ent_pos); 
		   round_val=2.0;
			if(p_ca_caevent_struct_h->h_earnings>0)
			{
			
				//COM BY ASP,TO ADD ROUNDOFF 2, 13jul06
				/*
				    p_ca_caentitlement_struct_h->h_instr_inc_bal =
								        (p_ent_pos * p_ca_caevent_struct_h->h_earnings);
	         */
			       CO_Round((p_ent_pos * p_ca_caevent_struct_h->h_earnings), 2, &round_val);
			       p_ca_caentitlement_struct_h->h_instr_inc_bal = round_val;
			}		 
			 else
			 {
				 //COM BY ASP,TO ADD ROUNDOFF 2, 13jul06
				   /*
			       p_ca_caentitlement_struct_h->h_instr_inc_bal =
			                			(p_ent_pos  * p_ca_caevent_struct_h->h_earnings_rt * p_nomval / 100);
			 	   */
				   CO_Round((p_ent_pos  * p_ca_caevent_struct_h->h_earnings_rt * p_nomval / 100), 2, &round_val);
			       p_ca_caentitlement_struct_h->h_instr_inc_bal = round_val;
			 }			 
			printf("After Roundoff, Calculated Balance is |%lf|***********************\n",p_ca_caentitlement_struct_h->h_instr_inc_bal);
			printf("earnings rate is |%lf|***********************\n",p_ca_caevent_struct_h->h_earnings_rt);
			printf("nom val is |%lf|***********************\n",p_nomval);
 		if (int_l_exist_a > 0)
      {
         if (!strcmp(p_ca_caevent_struct_h->h_ca_currency,APL_GRD_CCYCODE))
         {
            EXEC SQL SELECT TRUNC(:p_ca_caentitlement_struct_h->h_instr_inc_bal) INTO :new_instr_inc_bal FROM DUAL;
            IS_ANY_ORA_ERROR
         }
      
         else
         {
            EXEC SQL SELECT DEC_LEN INTO :h_dec_len:i_dec_len FROM DL_CURRENCY WHERE CURRENCY_CD=:p_ca_caevent_struct_h->h_ca_currency;
            IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,"CURRENCY : ",p_ca_caevent_struct_h->h_ca_currency,APL_NULL_STRING)

            if (APL_FAILURE == CO_Round(p_ca_caentitlement_struct_h->h_instr_inc_bal,h_dec_len,&new_instr_inc_bal))
            {
               APL_GOBACK_FAIL
            }
         }
  
         p_ca_caentitlement_struct_h->h_instr_inc_bal = new_instr_inc_bal;
      }
	}
	
	else if (!strcmp(p_ca_caevent_struct_h->h_evt_class, EVT_CAP_RED))
	{
		/* UAT Fix PJ -- SGS removed 
			 if (!strcmp(p_ca_caevent_struct_h->h_div_class,RED_TYP_FACEVAL))
			 {
			 if(p_ca_caevent_struct_h->h_earnings>0)
				    p_ca_caentitlement_struct_h->h_instr_inc_bal =
								        (p_ent_pos * p_ca_caevent_struct_h->h_earnings);
			 else
			       p_ca_caentitlement_struct_h->h_instr_inc_bal =
			                			(p_ent_pos  * p_ca_caevent_struct_h->h_earnings_rt
								 				 * p_nomval / 100);
			 }
			 else
			 { **/
				  	if (!strcmp(p_ca_casecevent_struct_h->h_ratio_perc_ind,PERCEN_IND))
			         ent_quantity   =  p_ent_pos * (p_ca_caevent_struct_h->h_new_safek_quantity_rt /100);
			     	else
			         ent_quantity = p_ent_pos *  p_ca_caevent_struct_h->h_new_safek_quantity /
											                                   p_ca_caevent_struct_h->h_old_safek_quantity;
					if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
					{

						new_ent_quantity = 0.00;
						EXEC SQL SELECT TRUNC(:ent_quantity,:l_mt_core_sys_params_struct_h.qty_dec_len) INTO :new_ent_quantity FROM DUAL;
						IS_ANY_ORA_ERROR
					}
					else
					{
						new_ent_quantity = 0.00;
						EXEC SQL SELECT TRUNC(:ent_quantity) INTO :new_ent_quantity FROM DUAL;
						IS_ANY_ORA_ERROR
					}

					Alert("\n Amit1:Inside CA_CalcEntitlement:h_disp_of_fract=|%s| \n",p_ca_caevent_struct_h->h_disp_of_fract);

					/**Change By Biju **/
					if((ent_quantity - new_ent_quantity) > 0)
					{
						if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_RNDOFF))
						{
							p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
							p_ca_caentitlement_struct_h->h_quantity_due = (new_ent_quantity + 1) ;
						}
						else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,CASH_IND))
						{
							round_val=0.0;
							CR_Proc_InstrQtyRound( (ent_quantity-new_ent_quantity),p_ca_caevent_struct_h->h_instr_code,&round_val,l_debug_info_ptr);
							p_ca_caentitlement_struct_h->h_instr_inc_bal = round_val * p_ca_caevent_struct_h->h_f_pr ;
							p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity;
							IF_COND_EXISTS("CA_ENTITL","CALC_ENTITL_FRACT")
							{
								p_ca_caentitlement_struct_h->h_fract_due = round_val;
							}
						}
						else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,DISRGD_IND))
						{
							p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
							if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
							{
								EXEC SQL SELECT TRUNC(:ent_quantity) INTO :l_elig_entitl_pos_tr FROM DUAL;
								IS_ANY_ORA_ERROR
									p_ca_caentitlement_struct_h->h_quantity_due = l_elig_entitl_pos_tr ;
							}
							else
								p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity ;
						}
						else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_STDRND))
						{
							p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
							if((ent_quantity - new_ent_quantity) >= 0.5)
								p_ca_caentitlement_struct_h->h_quantity_due = (new_ent_quantity + 1) ;
							else
								p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity;
						}
						else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_IND))
						{

							if (l_keep_fract_cond > 0  &&   p_ca_caevent_struct_h->h_f_pr == 0)
							{
								p_ca_caentitlement_struct_h->h_quantity_due = 0.00;

								if (chr_l_keep_fract_flag == 'Y')
								{
									EXEC SQL SELECT TRUNC(:ent_quantity, :l_mt_core_sys_params_struct_h.qty_dec_len)
										INTO :p_ca_caentitlement_struct_h->h_quantity_due
										FROM DUAL;
									IS_ANY_ORA_ERROR
								}	
								else
								{
									EXEC SQL SELECT TRUNC(:ent_quantity) 
										INTO :p_ca_caentitlement_struct_h->h_quantity_due
										FROM DUAL;
									IS_ANY_ORA_ERROR
								}	

							}  
				//ELSE part Added by Chirag - 16012008
							else
							{
								if (chr_l_keep_fract_flag == 'Y')
								{
									EXEC SQL SELECT TRUNC(:ent_quantity, :l_mt_core_sys_params_struct_h.qty_dec_len)
										INTO :p_ca_caentitlement_struct_h->h_quantity_due
										FROM DUAL;
									IS_ANY_ORA_ERROR
								}	
								else
								{
									EXEC SQL SELECT TRUNC(:ent_quantity) 
										INTO :p_ca_caentitlement_struct_h->h_quantity_due
										FROM DUAL;
									IS_ANY_ORA_ERROR
								}	

							}
						}
						/* If no fraction policy selected no rnding off is considered VaibhavK 241207 KOTAK */
						else 
						{
							Alert("no fraction policy selected no rnding off is considered Chirag\n");
							p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
							if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
							{
								EXEC SQL SELECT TRUNC(:ent_quantity) INTO :l_elig_entitl_pos_tr FROM DUAL;
								IS_ANY_ORA_ERROR
									p_ca_caentitlement_struct_h->h_quantity_due = l_elig_entitl_pos_tr ;
							}
							else
								p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity ;
						}
					}
					else
					{
						p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
						p_ca_caentitlement_struct_h->h_quantity_due =new_ent_quantity ;
						p_ca_caentitlement_struct_h->h_fract_due = 0;
					 }
			 /**} **/
		 
	}
	
	else if(	!strcmp(p_ca_caevent_struct_h->h_evt_class, EVT_BONUS)	|| 
				(!strcmp(p_ca_caevent_struct_h->h_evt_class, EVT_STOK_DIV)) ) 
	{		
			Alert("\n Amit1:Inside CA_CalcEntitlement:QtyBal=|%lf| new_ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,new_ent_quantity);//AIX Migration CHanges
			if (!strcmp(p_ca_casecevent_struct_h->h_ratio_perc_ind,PERCEN_IND))
				ent_quantity	=	p_ent_pos * (p_ca_caevent_struct_h->h_new_safek_quantity_rt /100);
			else 
				ent_quantity = p_ent_pos *  p_ca_caevent_struct_h->h_new_safek_quantity / 
											p_ca_caevent_struct_h->h_old_safek_quantity;

			Alert(" ent_quantity is |%lf|\n",ent_quantity);
/**
      IF_COND_EXISTS("CA_ENTITL","CALC_ENTITL_FRACT")
      {
         new_ent_quantity = 0.00;
         EXEC SQL SELECT TRUNC(:ent_quantity) INTO :new_ent_quantity FROM DUAL;
         IS_ANY_ORA_ERROR

         round_val=0.0;
         printf("new_ent_quantity is %lf*****\n",new_ent_quantity);
         printf("ent_quantity is %lf*****\n",ent_quantity);
         p_ca_caentitlement_struct_h->h_quantity_due =new_ent_quantity ;
         CR_Proc_InstrQtyRound( (ent_quantity - new_ent_quantity),
                                 p_ca_caevent_struct_h->h_instr_code,
                                 &round_val,
                                 l_debug_info_ptr);

         printf("round_val is %lf***********\n",round_val);

            if(p_ca_caevent_struct_h->h_f_pr == 0)
            {
               p_ca_caentitlement_struct_h->h_fract_due = round_val;
               p_ca_caentitlement_struct_h->h_instr_inc_bal=0;
            }
            else
            {
               p_ca_caentitlement_struct_h->h_fract_due = round_val;
               p_ca_caentitlement_struct_h->h_instr_inc_bal =
               p_ca_caevent_struct_h->h_f_pr * round_val;
            }

      }
		  else
		  {
		  **/

		if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
		{
			
			printf("**********Without rounding!! new_ent_quantity is %lf\n",new_ent_quantity);
			new_ent_quantity = 0.00;
			EXEC SQL SELECT TRUNC(:ent_quantity,:l_mt_core_sys_params_struct_h.qty_dec_len) INTO :new_ent_quantity FROM DUAL;
			IS_ANY_ORA_ERROR
		}
		else
		{
			new_ent_quantity = 0.00;
      	EXEC SQL SELECT TRUNC(:ent_quantity) INTO :new_ent_quantity FROM DUAL;
			IS_ANY_ORA_ERROR
		}

			Alert(" new_ent_quantity is |%lf|\n",new_ent_quantity);
			Alert("\n Amit2:Inside CA_CalcEntitlement:QtyBal=|%lf| ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,ent_quantity);
		/**Change By Biju **/
	if((ent_quantity - new_ent_quantity) > 0)
	{	
		Alert("\n Amit3:Inside CA_CalcEntitlement:h_disp_of_fract=|%s| \n",p_ca_caevent_struct_h->h_disp_of_fract);
		Alert("\n Amit3:Inside CA_CalcEntitlement:QtyBal=|%lf| ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,ent_quantity);
		if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_RNDOFF))
		{
			p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
			p_ca_caentitlement_struct_h->h_quantity_due = (new_ent_quantity + 1) ;
			Alert("\n Amit4:Inside CA_CalcEntitlement:QtyBal=|%lf| new_ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,new_ent_quantity);
		}
		else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,CASH_IND))
		{
			round_val=0.0;
			CR_Proc_InstrQtyRound( (ent_quantity-new_ent_quantity),p_ca_caevent_struct_h->h_instr_code,&round_val,l_debug_info_ptr);
			p_ca_caentitlement_struct_h->h_instr_inc_bal = round_val * p_ca_caevent_struct_h->h_f_pr ;
			p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity;
			Alert("\n Amit5:Inside CA_CalcEntitlement:QtyBal=|%lf| new_ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,new_ent_quantity);
			IF_COND_EXISTS("CA_ENTITL","CALC_ENTITL_FRACT")
			{
				p_ca_caentitlement_struct_h->h_fract_due = round_val;
			}
		}
		else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,DISRGD_IND))
		{
			p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
			if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
			{
				EXEC SQL SELECT TRUNC(:ent_quantity) INTO :l_elig_entitl_pos_tr FROM DUAL;
				IS_ANY_ORA_ERROR
				p_ca_caentitlement_struct_h->h_quantity_due = l_elig_entitl_pos_tr ;
				Alert("\n Amit6:Inside CA_CalcEntitlement:QtyBal=|%lf| new_ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,new_ent_quantity);
			}
			else
				p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity ;
		}
		else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_STDRND))
		{
			Alert("\n Amit7:Inside CA_CalcEntitlement:QtyBal=|%lf| new_ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,new_ent_quantity);
			p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
			if((ent_quantity - new_ent_quantity) >= 0.5)
				p_ca_caentitlement_struct_h->h_quantity_due = (new_ent_quantity + 1) ;
			else
				p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity;
		}
		else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_IND))
		{
			Alert("\n Amit8:Inside CA_CalcEntitlement:QtyBal=|%lf| new_ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,new_ent_quantity);
			if (l_keep_fract_cond > 0  &&   p_ca_caevent_struct_h->h_f_pr == 0)
			{
				p_ca_caentitlement_struct_h->h_quantity_due = 0.00;
				Alert("\n Amit9:Inside CA_CalcEntitlement:QtyBal=|%lf| new_ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,new_ent_quantity);
				if (chr_l_keep_fract_flag == 'Y')
				{
					Alert("\n Amit10:Inside CA_CalcEntitlement:QtyBal=|%lf| ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,ent_quantity);
					EXEC SQL SELECT TRUNC(:ent_quantity, :l_mt_core_sys_params_struct_h.qty_dec_len)
						INTO :p_ca_caentitlement_struct_h->h_quantity_due
						FROM DUAL;
					IS_ANY_ORA_ERROR
				}	
				else
				{
					Alert("\n Amit11:Inside CA_CalcEntitlement:QtyBal=|%lf| ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,ent_quantity);
					EXEC SQL SELECT TRUNC(:ent_quantity) 
						INTO :p_ca_caentitlement_struct_h->h_quantity_due
						FROM DUAL;
					IS_ANY_ORA_ERROR
				}	

			}  
	//ELSE part Added By Chirag - 16012008
			else
			{
				if (chr_l_keep_fract_flag == 'Y')
				{
					Alert("\n Amit10:Inside CA_CalcEntitlement:QtyBal=|%lf| ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,ent_quantity);
					EXEC SQL SELECT TRUNC(:ent_quantity, :l_mt_core_sys_params_struct_h.qty_dec_len)
						INTO :p_ca_caentitlement_struct_h->h_quantity_due
						FROM DUAL;
					IS_ANY_ORA_ERROR
				}	
				else
				{
					Alert("\n Amit11:Inside CA_CalcEntitlement:QtyBal=|%lf| ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,ent_quantity);
					EXEC SQL SELECT TRUNC(:ent_quantity) 
						INTO :p_ca_caentitlement_struct_h->h_quantity_due
						FROM DUAL;
					IS_ANY_ORA_ERROR
				}	

			}
		}
		    /* If no fraction policy selected no rnding off is considered VaibhavK 241207 KOTAK */ 
		else
		{
							Alert("no fraction policy selected no rnding off is considered Chirag\n");
			p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
			if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
			{
				EXEC SQL SELECT TRUNC(:ent_quantity) INTO :l_elig_entitl_pos_tr FROM DUAL;
				IS_ANY_ORA_ERROR
				p_ca_caentitlement_struct_h->h_quantity_due = l_elig_entitl_pos_tr ;
			}
			else
				p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity ;
		}
	}
	else
	{

		p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
		p_ca_caentitlement_struct_h->h_quantity_due =new_ent_quantity ;
		p_ca_caentitlement_struct_h->h_fract_due = 0;
		Alert("\n Amit12:Inside CA_CalcEntitlement:QtyBal=|%lf| new_ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,new_ent_quantity);//AIX Migration CHanges
	}


		  /**
	
		if (l_keep_fract_cond > 0  &&   p_ca_caevent_struct_h->h_f_pr == 0)
		{
			p_ca_caentitlement_struct_h->h_quantity_due = 0.00;

			if (chr_l_keep_fract_flag == 'Y')
			{
				 EXEC SQL SELECT TRUNC(:ent_quantity, :l_mt_core_sys_params_struct_h.qty_dec_len)
                     INTO :p_ca_caentitlement_struct_h->h_quantity_due
                     FROM DUAL;
            IS_ANY_ORA_ERROR
			}	
			else
			{
				EXEC SQL SELECT TRUNC(:ent_quantity) 
							INTO :p_ca_caentitlement_struct_h->h_quantity_due
							FROM DUAL;
				IS_ANY_ORA_ERROR
			}	
	
		}  
		else
		{
			round_val=0.0;
			p_ca_caentitlement_struct_h->h_quantity_due =new_ent_quantity ;
			CR_Proc_InstrQtyRound( (ent_quantity - new_ent_quantity),p_ca_caevent_struct_h->h_instr_code,&round_val,l_debug_info_ptr);
			 p_ca_caentitlement_struct_h->h_instr_inc_bal =
			 p_ca_caevent_struct_h->h_f_pr * round_val;
		}
		**/
	/**
	 }
**/
}
			
	else if(	!strcmp(p_ca_caevent_struct_h->h_evt_class, EVT_RHTS))	
	{			
		if (!strcmp(p_ca_casecevent_struct_h->h_ratio_perc_ind,PERCEN_IND))
		{	
			ent_quantity =  p_ent_pos * (p_ca_caevent_struct_h->h_new_safek_quantity_rt /100);
		}
		else	
		{	
			ent_quantity =p_ent_pos * p_ca_caevent_struct_h->h_new_safek_quantity/p_ca_caevent_struct_h->h_old_safek_quantity; 
		}

		if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
		{
		   new_ent_quantity=0.00;
 	     EXEC SQL SELECT TRUNC(:ent_quantity,:l_mt_core_sys_params_struct_h.qty_dec_len) INTO :new_ent_quantity FROM DUAL;
 	     IS_ANY_ORA_ERROR	
		}
		else
		{
		   new_ent_quantity=0.00;
 	     	EXEC SQL SELECT TRUNC(:ent_quantity) INTO :new_ent_quantity FROM DUAL;
 	     	IS_ANY_ORA_ERROR	
		}
	  
	  	if((ent_quantity - new_ent_quantity) > 0)
		{	
			if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_RNDOFF))
			{
				p_ca_caentitlement_struct_h->h_instr_inc_bal = 0; 
		    	p_ca_caentitlement_struct_h->h_quantity_due = (new_ent_quantity + 1) ;
			}
			else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,CASH_IND))
			{
				round_val=0.0;
  	      	CR_Proc_InstrQtyRound( (ent_quantity-new_ent_quantity),p_ca_caevent_struct_h->h_instr_code,&round_val,l_debug_info_ptr);
				p_ca_caentitlement_struct_h->h_instr_inc_bal = round_val * p_ca_caevent_struct_h->h_f_pr ;
           	p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity; 
               IF_COND_EXISTS("CA_ENTITL","CALC_ENTITL_FRACT")
               {
                  p_ca_caentitlement_struct_h->h_fract_due = round_val;
               }
			}

			else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,DISRGD_IND))
			{
				p_ca_caentitlement_struct_h->h_instr_inc_bal = 0; 
		
      		if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
      		{
        			EXEC SQL SELECT TRUNC(:ent_quantity) INTO :l_elig_entitl_pos_tr FROM DUAL;
        			IS_ANY_ORA_ERROR
            	p_ca_caentitlement_struct_h->h_quantity_due = l_elig_entitl_pos_tr ;
				}
				else
            	p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity ;
			}
			
			else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_STDRND)) 
			{
			   p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
			   if((ent_quantity - new_ent_quantity) >= 0.5)
				    p_ca_caentitlement_struct_h->h_quantity_due = (new_ent_quantity + 1) ;	
            else
					 p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity;
         }
			
        	else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_IND))
         	{
			 			if (l_keep_fract_cond > 0)
							{		
								EXEC SQL SELECT TRUNC(:ent_quantity, :l_mt_core_sys_params_struct_h.qty_dec_len)
                     	INTO :p_ca_caentitlement_struct_h->h_quantity_due
                     	FROM DUAL;
            				IS_ANY_ORA_ERROR
      					}  	
						else 
							{
								p_ca_caentitlement_struct_h->h_quantity_due =  ent_quantity;	
							}		
				}
				/* If no fraction policy selected no rnding off is considered VaibhavK 241207 KOTAK */
			else 
			{
				Alert("no fraction policy selected no rnding off is considered Chirag\n");
				p_ca_caentitlement_struct_h->h_instr_inc_bal = 0; 
		
      	                	if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
      		                {
        			EXEC SQL SELECT TRUNC(:ent_quantity) INTO :l_elig_entitl_pos_tr FROM DUAL;
        			IS_ANY_ORA_ERROR
            	                p_ca_caentitlement_struct_h->h_quantity_due = l_elig_entitl_pos_tr ;
				}
				else
            	                p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity ;
			}
		}
		else
		{
			p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
         p_ca_caentitlement_struct_h->h_quantity_due =new_ent_quantity ;
			p_ca_caentitlement_struct_h->h_fract_due = 0;
		}
			strcpy(p_ca_caentitlement_struct_h->h_sent550date,chr_g_sys_date) ; 
	}
	else if(	!strcmp(p_ca_caevent_struct_h->h_evt_class, EVT_SPLIT))
	{	
		ent_quantity = 	p_ent_pos * p_ca_caevent_struct_h->h_new_safek_quantity
									 	/p_ca_caevent_struct_h->h_old_safek_quantity;
	
		round_val=0.0;
Alert("Below IF_COND_EXISTS chnged by Chirag 18032008 never go in below if loop ISKB 1003 \n");
	      IF_COND_EXISTS("CA_ENTITL111","CALC_ENTITL_FRACT")
      {
         new_ent_quantity = 0.00;
         EXEC SQL SELECT TRUNC(:ent_quantity) INTO :new_ent_quantity FROM DUAL;
         IS_ANY_ORA_ERROR

         round_val=0.0;
         p_ca_caentitlement_struct_h->h_quantity_due =new_ent_quantity ;
         CR_Proc_InstrQtyRound( (ent_quantity - new_ent_quantity),
                                 p_ca_caevent_struct_h->h_instr_code,
                                 &round_val,
                                 l_debug_info_ptr);

            if(p_ca_caevent_struct_h->h_f_pr == 0)
            {
               p_ca_caentitlement_struct_h->h_fract_due = round_val;
               p_ca_caentitlement_struct_h->h_instr_inc_bal=0;
            }
            else
            {
               p_ca_caentitlement_struct_h->h_fract_due = round_val;
               p_ca_caentitlement_struct_h->h_instr_inc_bal =
               p_ca_caevent_struct_h->h_f_pr * round_val;
            }
        }
        else
         {
	
      new_ent_quantity = 0.00;

		if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
		{
      	EXEC SQL SELECT TRUNC(:ent_quantity,:l_mt_core_sys_params_struct_h.qty_dec_len) INTO :new_ent_quantity FROM DUAL;
      	IS_ANY_ORA_ERROR
		}
		else
		{
      	EXEC SQL SELECT TRUNC(:ent_quantity) INTO :new_ent_quantity FROM DUAL;
      	IS_ANY_ORA_ERROR
		}
	 	/*********** RVSL starts - just changing logic  HDFCCA_035************/	
		if( strcmp(g_ca_caevent_struct_h.h_op_evt_class,STOCK_SPLIT)==0 )
		{
			if (l_keep_fract_cond > 0  &&   p_ca_caevent_struct_h->h_f_pr == 0)
			{
				p_ca_caentitlement_struct_h->h_quantity_due = 0.00;

				if (chr_l_keep_fract_flag == 'Y')
				{
					EXEC SQL SELECT TRUNC(:ent_quantity, :l_mt_core_sys_params_struct_h.qty_dec_len)
						INTO :p_ca_caentitlement_struct_h->h_quantity_due
						FROM DUAL;
					IS_ANY_ORA_ERROR
				}

				else
				{
					EXEC SQL SELECT TRUNC(:ent_quantity)
						INTO :p_ca_caentitlement_struct_h->h_quantity_due
						FROM DUAL;
					IS_ANY_ORA_ERROR
				}
			}  
			else	
			{
				p_ca_caentitlement_struct_h->h_quantity_due =new_ent_quantity ;
				CR_Proc_InstrQtyRound( (ent_quantity - new_ent_quantity),p_ca_caevent_struct_h->h_instr_code,&round_val, l_debug_info_ptr);

				p_ca_caentitlement_struct_h->h_instr_inc_bal = p_ca_caevent_struct_h->h_f_pr * round_val  ;
			}
		}
		else
		{
			/***************** RVSL HDFCCA_035 START ***************/

			if((ent_quantity - new_ent_quantity) > 0)
			{
				if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_RNDOFF))
				{
					p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
					p_ca_caentitlement_struct_h->h_quantity_due = (new_ent_quantity + 1) ;
				}
				else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,CASH_IND))
				{

               IF_COND_EXISTS("CA_ENTITL","CALC_ENTITL_FRACT")
               {
            		CR_Proc_InstrQtyRound( (ent_quantity - new_ent_quantity),
										p_ca_caevent_struct_h->h_instr_code,&round_val, l_debug_info_ptr);
                  if(p_ca_caevent_struct_h->h_f_pr == 0)
                  {
							p_ca_caentitlement_struct_h->h_fract_due = round_val;
                     p_ca_caentitlement_struct_h->h_instr_inc_bal=0;
                  }
		            else
  			          {
               			p_ca_caentitlement_struct_h->h_fract_due = round_val;
               			p_ca_caentitlement_struct_h->h_instr_inc_bal =
               			p_ca_caevent_struct_h->h_f_pr * round_val;
            		 }
					}
               else
               {

					round_val=0.0;
					p_ca_caentitlement_struct_h->h_instr_inc_bal = (ent_quantity-new_ent_quantity) * p_ca_caevent_struct_h->h_f_pr ;
					EXEC SQL SELECT TRUNC(:p_ca_caentitlement_struct_h->h_instr_inc_bal,:l_mt_core_sys_params_struct_h.amount_decimal_len)
						INTO :p_ca_caentitlement_struct_h->h_instr_inc_bal
						FROM DUAL;
					IS_ANY_ORA_ERROR
						}
						p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity;
				}
				else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,DISRGD_IND))
				{
					p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
					if ((int_period_flg1>0 )&&(Trunc_Cond_exists_h>0))
					{
						EXEC SQL SELECT TRUNC(:ent_quantity) INTO :l_elig_entitl_pos_tr FROM DUAL;
					IS_ANY_ORA_ERROR
							p_ca_caentitlement_struct_h->h_quantity_due = l_elig_entitl_pos_tr;
					}
					else
						p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity ;
				}
				else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_STDRND))
				{
					p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
					if((ent_quantity - new_ent_quantity) >= 0.5)
						p_ca_caentitlement_struct_h->h_quantity_due = (new_ent_quantity + 1) ;
					else
						p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity;
				}
				else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_IND))
				{
					if (l_keep_fract_cond > 0)
					{
						if (chr_l_keep_fract_flag== 'Y')
						{
							EXEC SQL SELECT TRUNC(:ent_quantity, :l_mt_core_sys_params_struct_h.qty_dec_len)
								INTO :p_ca_caentitlement_struct_h->h_quantity_due
								FROM DUAL;
					IS_ANY_ORA_ERROR
						}
						else
						{
							EXEC SQL SELECT TRUNC(:ent_quantity)
								INTO :p_ca_caentitlement_struct_h->h_quantity_due
								FROM DUAL;
					IS_ANY_ORA_ERROR
						}
					}
					else
					{
						p_ca_caentitlement_struct_h->h_quantity_due =new_ent_quantity ;

						CR_Proc_InstrQtyRound((ent_quantity - new_ent_quantity),p_ca_caevent_struct_h->h_instr_code,&round_val, l_debug_info_ptr);
						p_ca_caentitlement_struct_h->h_instr_inc_bal =p_ca_caevent_struct_h->h_f_pr * round_val  ;
					}
				}
					/* If no fraction policy selected no rnding off is considered VaibhavK 241207 KOTAK */
				else
				{
							Alert("no fraction policy selected no rnding off is considered Chirag\n");
					p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
					if ((int_period_flg1>0 )&&(Trunc_Cond_exists_h>0))
					{
						EXEC SQL SELECT TRUNC(:ent_quantity) INTO :l_elig_entitl_pos_tr FROM DUAL;
					IS_ANY_ORA_ERROR
							p_ca_caentitlement_struct_h->h_quantity_due = l_elig_entitl_pos_tr;
					}
					else
						p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity ;
				}
			}
			else
			{
				p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
				p_ca_caentitlement_struct_h->h_quantity_due =new_ent_quantity ;
			}

			/***************** RVSL HDFCCA_035 End  *****************/
			}
		}
	}

	else if(	!strcmp(p_ca_caevent_struct_h->h_evt_class, EVT_BOND))
	{	
		if(p_ca_caevent_struct_h->h_earnings > 0 )
		{	
			p_ca_caentitlement_struct_h->h_instr_inc_bal = 	p_ent_pos * (p_ca_caevent_struct_h->h_earnings);
		}

		else if(p_ca_caevent_struct_h->h_earnings_rt > 0 )
		{	
			/* UAT Fix PJ EMU Condition removed instead apply instrument level condition to identify if fixed or 
			 * floting interest is to be applied 
			
			 * if ( CO_Chk_EMU_Period(APL_NULL_STRING,&int_period_flg,l_debug_info_ptr) == APL_FAILURE )
   		{
      		APL_GOBACK_FAIL
   		}
			if ( (int_period_flg == 2) || (int_period_flg == 3) ) */
			printf("\n *** 3509  ASH*** |%s|", l_mt_instrument_struct_h.h_int_typ);
			/*if (l_mt_instrument_struct_h.h_int_typ[0] == 'F' || l_mt_instrument_struct_h.h_int_typ[0] == 'Q')*Vaibhav 24/04/2006*/
			if (strcmp(l_mt_instrument_struct_h.h_int_typ,"F")==0 || 
					strcmp(l_mt_instrument_struct_h.h_int_typ,"Q") ==0)/*Vaibhav 24/04/2006*/
			{                                                     
				printf("\n **************** INSIDE VOILA LOOP **************");
				/**
				if(CA_CalcInterest(	1.0,
											p_ca_caevent_struct_h->h_earnings_rt,
											&p_calc_value,
											p_lst_pay_date,
											p_ca_caevent_struct_h->h_pymt_dt,
											p_basis,
											l_debug_info_ptr)==APL_SUCCESS) 		

				p_calc_value = 1.0 * TRUNC_VAL_DEC(p_calc_value,l_precision);
				round_val = 0.0;
				CO_Round(p_calc_value, 8, &round_val); 
				p_calc_value = 1.0 * round_val ;
	
				printf("*******The chr_value of p_calc_value is : %lf\n",p_calc_value);
				p_ca_caentitlement_struct_h->h_instr_inc_bal = (p_ent_pos * p_calc_value); 
			   printf("*******The chr_value of p_ent_pos is :%lf\n",p_ent_pos);
			   printf("*******The chr_value of p_ca_caentitlement_struct_h->h_instr_inc_bal is :%lf\n",p_ca_caentitlement_struct_h->h_instr_inc_bal);
				 **/
				Alert("p_basis is |%s| \n",p_basis);
				if(!strcmp(p_basis,"A") || !strcmp(p_basis,"B") || !strcmp(p_basis,"E"))
				{
						  /* p_ca_caevent_struct_h->h_pymtdt replaced by p_ca_caevent_struct_h->h_pymtdt - 1 in below function - KOTAK */
						  /* Chirag 01-01-2006 */
						  EXEC SQL SELECT TO_DATE(:p_ca_caevent_struct_h->h_pymt_dt,'DD/MM/YYYY HH24:MI:SS') - 1
									 INTO :l_pay_date:i_pay_date
									 FROM DUAL;
						  IS_ANY_ORA_ERROR
									 Alert("\np_ca_caevent_struct_h->h_pymt_dt date is |%s| \n",p_ca_caevent_struct_h->h_pymt_dt);
						  Alert("p_ca_caevent_struct_h->h_pymt_dt - 1 date is |%s| \n",l_pay_date);
				}
				else
				{
						  strcpy(l_pay_date,p_ca_caevent_struct_h->h_pymt_dt);
						  Alert("l_pay_date is |%s|\n",l_pay_date);
				}
				/* Chirag 01-01-2006 */
				if(CA_CalcFix_Float( p_nomval,
							p_ca_caevent_struct_h->h_earnings_rt,
							&p_calc_value,
							p_lst_pay_date,
							l_pay_date,
							p_basis,
							l_mt_instrument_struct_h.h_instr_code,
							chr_g_client,
							p_ent_pos,
							l_mt_instrument_struct_h.h_int_typ,
							l_debug_info_ptr)==APL_FAILURE)
				{
					Alert("Failed in CA_CalcFix_Float");
					APL_GOBACK_FAIL
				}

				

			}		
			else
			{
				printf("P_LST_PAY_DT is %s\n",p_lst_pay_date);
				printf("P_PAY_DT is %s\n",p_ca_caevent_struct_h->h_pymt_dt);
				printf("P_basis is %s\n",p_basis);
				/**
				if(CA_CalcInterest(	p_nomval,
											p_ca_caevent_struct_h->h_earnings_rt,
											&p_calc_value,
											p_lst_pay_date,
											p_ca_caevent_struct_h->h_pymt_dt,
											p_basis,
											l_debug_info_ptr)==APL_SUCCESS) 		
	
	 
				p_calc_value = p_nomval * TRUNC_VAL_DEC(p_calc_value,l_precision);
				round_val = 0.0;
				printf("*******before roundingThe chr_value of p_calc_value1 is : %lf\n",p_calc_value);
				CO_Round(p_calc_value, 8, &round_val); 
				printf("*******after roundingThe chr_value of p_calc_value1 is : %lf\n",round_val);
				p_calc_value = 1.0 * round_val;   
				printf("*******after multiplication chr_value of p_calc_value1 is : %lf\n",p_calc_value);
				printf("*******The chr_value of p_calc_value1 is : %lf\n",p_calc_value);
				p_ca_caentitlement_struct_h->h_instr_inc_bal = (p_ent_pos * p_calc_value); 
			   printf("*******The chr_value of p_ent_pos is :%lf\n",p_ent_pos);
				printf("*******The chr_value of p_ca_caentitlement_struct_h->h_instr_inc_bal is : %lf\n",p_ca_caentitlement_struct_h->h_instr_inc_bal);
				 **/
				if(CA_CalcFix_Float( p_nomval,
							p_ca_caevent_struct_h->h_earnings_rt,
							&p_calc_value,
							p_lst_pay_date,
							p_ca_caevent_struct_h->h_ex_date,
							p_basis,
							l_mt_instrument_struct_h.h_instr_code,
							chr_g_client,
							p_ent_pos,
							l_mt_instrument_struct_h.h_int_typ,
							l_debug_info_ptr)==APL_FAILURE)
				{
					Alert("Failed in CA_CalcFix_Float");
					APL_GOBACK_FAIL
			}
		}  
			round_val = 2.0;			
			printf("Before p_calc_value |%lf||%lf| *************\n",p_calc_value,round_val);
			CO_Round(p_calc_value, 2, &round_val);
			printf("After p_calc_value |%lf||%lf| *************\n",p_calc_value,round_val);
			p_ca_caentitlement_struct_h->h_instr_inc_bal = round_val;
			Alert("So Instr Balace uis|%lf|\n",p_ca_caentitlement_struct_h->h_instr_inc_bal);
		}                          	
	}

	else if(	!strcmp(p_ca_caevent_struct_h->h_evt_class, EVT_BOND_REDMP))
		
	{	
		if(p_ca_caevent_struct_h->h_earnings>0)		
	 	{	
			p_ca_caentitlement_struct_h->h_instr_inc_bal =  p_ent_pos * p_ca_caevent_struct_h->h_earnings;
		}
		
		if(p_ca_caevent_struct_h->h_earnings_rt>0)
		{
			p_ca_caentitlement_struct_h->h_instr_inc_bal =
												(		p_ent_pos 
												 	* (p_ca_caevent_struct_h->h_earnings_rt/100)
												 	* p_nomval);
		}
		
	}
	else if(	!strcmp(p_ca_caevent_struct_h->h_evt_class, EVT_OFFER) || 
				!strcmp(p_ca_caevent_struct_h->h_evt_class, EVT_CV) )
	{			
	 if (g_ca_caevent_struct_i.i_res_instr_code != -1) 
		{
			if (!strcmp(p_ca_casecevent_struct_h->h_ratio_perc_ind,PERCEN_IND))
			{	
				ent_quantity =  p_ent_pos * (p_ca_caevent_struct_h->h_new_safek_quantity_rt /100);
			}
			else	
			{	
				ent_quantity = 	p_ent_pos 
								* p_ca_caevent_struct_h->h_new_safek_quantity/p_ca_caevent_struct_h->h_old_safek_quantity; 
			}
          new_ent_quantity=0.00;



		if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
		{
             EXEC SQL SELECT TRUNC(:ent_quantity,:l_mt_core_sys_params_struct_h.qty_dec_len) INTO :new_ent_quantity FROM DUAL;
             IS_ANY_ORA_ERROR
		}
		else
		{
             EXEC SQL SELECT TRUNC(:ent_quantity) INTO :new_ent_quantity FROM DUAL;
             IS_ANY_ORA_ERROR
		}

 
			if((ent_quantity - new_ent_quantity) > 0)
			{	
				if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_RNDOFF))
				{
					p_ca_caentitlement_struct_h->h_instr_inc_bal = 0; 
					p_ca_caentitlement_struct_h->h_quantity_due = (new_ent_quantity + 1) ; 	
				}

				else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,CASH_IND))
				{
					round_val=0.0;

				
					
				CR_Proc_InstrQtyRound( (ent_quantity-new_ent_quantity),p_ca_caevent_struct_h->h_instr_code,&round_val,l_debug_info_ptr);
               IF_COND_EXISTS("CA_ENTITL","CALC_ENTITL_FRACT")
               {
                  if(p_ca_caevent_struct_h->h_f_pr == 0)
                  {
                     p_ca_caentitlement_struct_h->h_fract_due = round_val;
                     p_ca_caentitlement_struct_h->h_instr_inc_bal=0;
                  }
                  else
                  {
                     p_ca_caentitlement_struct_h->h_fract_due = round_val;
                     p_ca_caentitlement_struct_h->h_instr_inc_bal =
                              round_val * p_ca_caevent_struct_h->h_f_pr ;
                  }
                     p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity;
               }
               else
               {
                  p_ca_caentitlement_struct_h->h_instr_inc_bal =
                              round_val * p_ca_caevent_struct_h->h_f_pr ;
                  p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity;
               }
            }

				else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,DISRGD_IND))
				{
						
					p_ca_caentitlement_struct_h->h_instr_inc_bal = 0; 
					

      			if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
      			{
        				EXEC SQL SELECT TRUNC(:ent_quantity) INTO :l_elig_entitl_pos_tr FROM DUAL;
        				IS_ANY_ORA_ERROR

							p_ca_caentitlement_struct_h->h_quantity_due = l_elig_entitl_pos_tr ; 	
 				   }
      			else
							p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity ; 	
				}

			   

			   else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_STDRND)) 
			   {
			      p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
			      if((ent_quantity - new_ent_quantity) >= 0.5)
				       p_ca_caentitlement_struct_h->h_quantity_due = (new_ent_quantity + 1) ;	
               else
					    p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity;
            }
			 
				
           	else if (!strcmp(p_ca_caevent_struct_h->h_disp_of_fract,FRACT_DISP_IND))
           		{
	            	if (l_keep_fract_cond > 0)
   	         			{
      	         			if (chr_l_keep_fract_flag == 'Y')
               				{
                  				EXEC SQL SELECT TRUNC(:ent_quantity, :l_mt_core_sys_params_struct_h.qty_dec_len)
                    				INTO :p_ca_caentitlement_struct_h->h_quantity_due
                    				FROM DUAL;
            						IS_ANY_ORA_ERROR
               				}

               				else
               				{
                  				EXEC SQL SELECT TRUNC(:ent_quantity)
                     	   	INTO :p_ca_caentitlement_struct_h->h_quantity_due
                        		FROM DUAL;
                  				IS_ANY_ORA_ERROR
               				}
            			  }  
						  	else
						  		{	 
							  	p_ca_caentitlement_struct_h->h_quantity_due =  ent_quantity;
						  		}
            		} 
			   /* If no fraction policy selected no rnding off is considered VaibhavK 241207 KOTAK */
			else
			{
			    Alert("no fraction policy selected no rnding off is considered Chirag\n");
			    p_ca_caentitlement_struct_h->h_instr_inc_bal = 0; 
			    if ((int_period_flg1>0)&&(Trunc_Cond_exists_h>0))
      			   {
        			EXEC SQL SELECT TRUNC(:ent_quantity) INTO :l_elig_entitl_pos_tr FROM DUAL;
        			IS_ANY_ORA_ERROR
				p_ca_caentitlement_struct_h->h_quantity_due = l_elig_entitl_pos_tr ; 	
			   }
        		   else
			   p_ca_caentitlement_struct_h->h_quantity_due = new_ent_quantity ; 	
			}
			}
			else
			{
				p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
				
			   p_ca_caentitlement_struct_h->h_quantity_due =new_ent_quantity;	

			}
		}
		else 
		{
			p_ca_caentitlement_struct_h->h_instr_inc_bal = 0;
			p_ca_caentitlement_struct_h->h_quantity_due = 0;
		 }
	}
	/*Smita - HDFCCA_009 - Added Calc Entitled Positions Formula*/
	else if (!strcmp(p_ca_caevent_struct_h->h_evt_class, EVT_BUY_BACK))	
	{
		ent_quantity =  p_ent_pos * (p_ca_caevent_struct_h->h_new_safek_quantity_rt /100);
		p_ca_caentitlement_struct_h->h_quantity_due =  ent_quantity;
	}
	/*Smita - HDFCCA_009 - Added Calc Entitled Positions Formula*/
	strcpy(p_ca_caentitlement_struct_h->h_access_stamp,chr_sys_date_time);
	//Alert("\n Amit11:Leaving CA_CalcEntitlement:QtyBal=|%lf| ent_quantity=|%lf| new_ent_quantity=|%lf| \n",p_ca_caentitlement_struct_h->h_quantity_due,ent_quantity,new_ent_quantity); // AIX -Warnings Reaoval
	fflush(stdout);	
	
	APL_GOBACK_SUCCESS

	RETURN_SUCCESS:
	{
		return (APL_SUCCESS);
	}
	RETURN_FAILURE:
	{
		return (APL_FAILURE);
	}
}

int CA_CalcFix_Float(   double   p_nom_val,
		double   p_rate,
		double   *p_calc_value,
		char     *p_from_date,
		char     *p_to_date,
		char     *p_basis,
		char     *p_instr_code,
		char     *p_cln_code,
		double   p_ent_pos,
		char     *p_int_type,
		DEBUG_INFO_STRUCT_H  **l_debug_info_ptr)
{
	double l_calc_value  = 0.0;
	double l_precision   = 6;
	double l_rnd_value   =  0.0;
	double l_today_amount= 0.0;
	double l_rate        =0.0;
	double l_calc_amount =0.0;
	double l_calc_int    = 0.0;
	int l_date_diff = 0;

	APL_FUNCTION_ENTER(APL_OUT_FILE)
		Alert("From Date (%s) To Date (%s)",p_from_date,p_to_date);


	printf("inside p_calc_value is %lf\n",*p_calc_value);  // AIX -Warnings Reaoval
	IF_COND_EXISTS("CAENTITLE","FIX_FLOAT")
		
	{
		Alert("Conditinon Exists");

		if(!strcmp(p_int_type,"F") || !strcmp(p_int_type,"Q"))
		{
			Alert("Instrument is Fixed");
			if(CalcFixRate (  p_basis,
						p_instr_code,
						p_from_date,
						p_to_date,
						&l_calc_value,
						l_debug_info_ptr) == APL_FAILURE)
			{
				Alert("Failed in CalcFixRate");

				APL_GOBACK_FAIL
			}
			
			Alert("Calc %.10lf %lf %lf",  l_calc_value, p_nom_val, p_ent_pos);
			l_calc_value = p_nom_val * TRUNC_VAL_DEC(l_calc_value,14);
			Alert("Calc %.14lf %lf",  l_calc_value, p_nom_val);
			CO_Round(l_calc_value,14, &l_rnd_value);
			l_calc_value = 1.0 * l_rnd_value;
			l_calc_value = p_ent_pos * l_calc_value;
			Alert("Calc %lf ",  l_calc_value);

		}
		else if(!strcmp(p_int_type,"L"))
		{
			Alert("Float Instrument");

			/* EXEC SQL SELECT NVL(BASEAMOUNT,0.0),
				  NVL(INTRATE, 0.0),
				  NVL(BASEAMOUNT,0.0) + NVL(INTEREST,0.0)
					  INTO  :l_today_amount,
				  :l_rate,
				  :l_calc_amount
					  FROM CADAILY_FLOATINTEREST
					  WHERE to_date(ON_DATE,'dd/mm/yyyy hh24:mi:ss') = to_date(:p_to_date,'dd/mm/yyyy hh24:mi:ss')
					  AND   INSTR_CODE =:p_instr_code
					  AND   CLN_CODE   =:p_cln_code; ***/
			EXEC SQL SELECT SUM(NVL(INTEREST,0.0))
					  INTO  :l_calc_amount
					  FROM CADAILY_FLOATINTEREST
					  WHERE ON_DATE between to_date(:p_from_date,'dd/mm/yyyy hh24:mi:ss') and to_date(:p_to_date,'dd/mm/yyyy hh24:mi:ss')
					  AND   INSTR_CODE =:p_instr_code
					  AND   CLN_CODE   =:p_cln_code;
			IS_ANY_ORA_ERROR
				if(sqlca.sqlcode == 1403)
				{
					Alert("float calculation Not done for It (%s) (%s) (%s)",chr_g_sys_date,p_instr_code,p_cln_code);
					/**APL_GOBACK_FAIL*Chirag*/
				}
				l_calc_value = l_calc_amount; 
				/* No need to calculate interest upto payment date 
			EXEC SQL SELECT to_date(:p_to_date) - to_date(:chr_g_sys_date)
				INTO :l_date_diff
				FROM DUAL;
			IS_ANY_ORA_ERROR
				Alert("Date Difference is |%d|",l_date_diff);
			Alert("Base Amount  (%lf) Int Rate (%lf) ",l_today_amount,l_rate);
			if(l_date_diff > 0)
			{
				l_calc_value = 0.0;
				Alert("Date Difference is ther, We proceed for calculation on paydate");
				l_calc_amount = l_today_amount * pow(1.0 + (l_rate/100.00),l_date_diff); UAT Fix PJ*
				l_calc_amount = l_today_amount * pow(1.0 + ((l_rate/365.00)/100.00),l_date_diff);
				l_calc_int = l_calc_amount * ( (l_rate / 365.00) / 100.00);
				l_calc_value = l_calc_amount + l_calc_int;
				Alert("Calculating For Date (%s) Amount (%lf) Int (%lf) Value (%lf)",p_to_date,l_calc_amount,l_calc_int,l_calc_value);
			}  */

		}

	}
	else
	{
		if(CA_CalcInterest(  p_nom_val,
					p_rate,
					&l_calc_value,
					p_from_date,
					p_to_date,
					p_basis,
					l_debug_info_ptr) == APL_FAILURE)
		{
			Alert("Failed inn CA_CalcInterest");
			APL_GOBACK_FAIL
		}
		l_calc_value = p_nom_val * TRUNC_VAL_DEC(l_calc_value,l_precision);
		CO_Round(l_calc_value, 8, &l_rnd_value);
		l_calc_value = 1.0 * l_rnd_value;
		l_calc_value = p_ent_pos * l_calc_value;
	}
	printf("return p_calc_value is |%lf|\n",*p_calc_value);  // AIX -Warnings Reaoval
	*p_calc_value = l_calc_value;
	printf("return p_calc_value is |%lf|\n",*p_calc_value);
	printf("return l_calc_value is |%lf|\n",l_calc_value);

	APL_GOBACK_SUCCESS
		RETURN_SUCCESS:
		APL_FUNCTION_RET_SUCCESS(APL_OUT_FILE)
		RETURN_FAILURE:
		APL_FUNCTION_RET_FAILURE(APL_OUT_FILE)
}



static int	CA_CalcInterest(	double			p_nom_val,
										double			p_rate,
										double			*p_calc_value,  
										char				*p_from_date,
										char				*p_to_date,
										char				*p_basis,
										DEBUG_INFO_STRUCT_H	**l_debug_info_ptr)
{
	struct sqlca sqlca;
	char	chr_asc_f_year[S_YEAR_LEN+1],
			chr_asc_t_year[S_YEAR_LEN+1],
			chr_asc_f_month[S_MONTH_LEN+1],
			chr_asc_t_month[S_MONTH_LEN+1],
			chr_asc_f_day[S_DAY_LENGTH+1],
			chr_asc_t_day[S_DAY_LENGTH+1],
			chr_asc_to_month[S_MONTH_LEN+1],
			chr_asc_to_day[S_DAY_LENGTH+1],
			chr_temp_to_date[APL_DATE_LEN],
			chr_temp_from_date[APL_DATE_LEN];

	double	dbl_from_yr,
				to_yr,
				dbl_from_month,
				to_month,
				dbl_from_day,
				to_day,
				t_month,
				t_day;

	double	dbl_h_num_days1,
				dbl_h_num_days2;
	
	double  l_ae_rate_per_val=0,l_precision = 6;
	
	int 		int_ratio,
				int_days_n_year;
	short    int_l_exist_a=0;

	chr_asc_f_year[S_YEAR_LEN]= NULL;
	chr_asc_t_year[S_YEAR_LEN]= NULL;
	chr_asc_f_month[S_MONTH_LEN]= NULL;
	chr_asc_t_month[S_MONTH_LEN]= NULL;
	chr_asc_f_day[S_DAY_LENGTH]= NULL;
	chr_asc_t_day[S_DAY_LENGTH]= NULL;

	strncpy(chr_asc_f_year, p_from_date+S_YEAR_POS, S_YEAR_LEN);
	strncpy(chr_asc_t_year, p_to_date+S_YEAR_POS, S_YEAR_LEN);
	strncpy(chr_asc_f_month, p_from_date+S_MONTH_POS, S_MONTH_LEN);
	strncpy(chr_asc_t_month, p_to_date+S_MONTH_POS, S_MONTH_LEN);
	strncpy(chr_asc_f_day, p_from_date+S_DAY_POS, S_DAY_LENGTH);
	strncpy(chr_asc_t_day, p_to_date+S_DAY_POS, S_DAY_LENGTH);
	


	dbl_from_yr	=	atof(chr_asc_f_year);
	to_yr		=	atof(chr_asc_t_year);
	dbl_from_month	= 	atof(chr_asc_f_month);
	to_month		=	atof(chr_asc_t_month);
	dbl_from_day		=	atof(chr_asc_f_day);
	to_day		=	atof(chr_asc_t_day);


	if(CA_CalcDaysInAYear(atoi(chr_asc_f_year),&int_days_n_year,l_debug_info_ptr)==APL_SUCCESS)
	printf("P BASIS Befor All Com ****************************|%s|\n",p_basis);
	 printf("no of Days :: p rate |%lf||%lf|****************************\n",p_rate,dbl_h_num_days1);
	if ( !strcmp(p_basis,INTEREST_BASE_IND_A))
	{	EXEC SQL SELECT TO_DATE(:p_to_date) - TO_DATE(:p_from_date) 
		INTO :dbl_h_num_days1 FROM dual;
		IS_ANY_ORA_ERROR		
	printf("p frm Dt :: p to Dt :: dbl_h_num_days1 |%s||%s||%lf|*******A*********\n",p_from_date,p_to_date,dbl_h_num_days1);	
	 	*p_calc_value = (p_rate/100) * (dbl_h_num_days1/360);
		//printf("Inside INTEREST_BASE_IND_A p_calc_value is **********|%lf|\n",p_calc_value); Changes done for AIX Migration
		printf("Inside INTEREST_BASE_IND_A p_calc_value is **********|%lf|\n",*p_calc_value); 

	

		APL_GOBACK_SUCCESS				 	
	}

	
	if ( !strcmp(p_basis,INTEREST_BASE_IND_B))
	{
		EXEC SQL SELECT TO_DATE(:p_to_date) - TO_DATE(:p_from_date) 
		INTO :dbl_h_num_days1 FROM dual;
		IS_ANY_ORA_ERROR
		
		if (!strncmp(p_from_date+S_YEAR_POS,p_to_date+S_YEAR_POS,S_YEAR_LEN))
		{
			*p_calc_value = (p_rate/100) * (dbl_h_num_days1/ int_days_n_year);
			printf("Inside INTEREST_BASE_IND_B p_calc_value is **********|%lf|\n",*p_calc_value);   // AIX -Warnings Reaoval
			APL_GOBACK_SUCCESS				 	
		}
		else
		{
			sprintf(chr_temp_to_date,S_LAST_DAY,ltoa(dbl_from_yr));
			sprintf(chr_temp_from_date,S_FIRST_DAY,ltoa(dbl_from_yr+1));

			EXEC SQL SELECT TO_DATE(:chr_temp_to_date) - TO_DATE(:p_from_date) 
			INTO :dbl_h_num_days2 FROM dual;
			IS_ANY_ORA_ERROR	
			 
			 int_ratio = 		CA_CalcInterest(	p_nom_val,
														p_rate,
														p_calc_value,
														chr_temp_from_date, 
														p_to_date,p_basis,l_debug_info_ptr);
		
			*p_calc_value += (p_rate/100)*((dbl_h_num_days2 + 1)/int_days_n_year);
			printf("Inside ELSE INTEREST_BASE_IND_B p_calc_value is **********|%lf|\n",*p_calc_value);  // AIX -Warnings Reaoval	
			APL_GOBACK_SUCCESS				 	
		}
	}

	if ( !strcmp(p_basis,INTEREST_BASE_IND_C))
	{
		if (!strncmp(p_from_date+S_YEAR_POS,p_to_date+S_YEAR_POS,S_YEAR_LEN))
		{
			*p_calc_value = (p_rate/100) * (((30*(to_month - dbl_from_month)) + (to_day - dbl_from_day))
						/int_days_n_year);	
			printf("Inside INTEREST_BASE_IND_C p_calc_value is **********|%lf|\n",*p_calc_value);   // AIX -Warnings Reaoval
			APL_GOBACK_SUCCESS				 	
		}
		else
		{	
			chr_asc_to_month[S_MONTH_LEN]= NULL;
			chr_asc_to_day[S_DAY_LENGTH]= NULL;
			
			sprintf(chr_temp_to_date,S_LAST_DAY,ltoa(dbl_from_yr));
			sprintf(chr_temp_from_date,S_FIRST_DAY,ltoa(dbl_from_yr+1L));
			
			strncpy(chr_asc_to_month, chr_temp_to_date+S_MONTH_POS, S_MONTH_LEN);
			strncpy(chr_asc_to_day, chr_temp_to_date+S_DAY_POS, S_DAY_LENGTH);
			t_month 	= atoi(chr_asc_to_month);
			t_day 	= atoi(chr_asc_to_day);

			 int_ratio 	= CA_CalcInterest(	p_nom_val,
												p_rate,
												p_calc_value,
												chr_temp_from_date,
												p_to_date,p_basis,l_debug_info_ptr);

			
	
			*p_calc_value += (p_rate/100) * (((30 *(t_month - dbl_from_month)) + ((t_day - dbl_from_day)))/int_days_n_year);
         printf("Inside ELSE INTEREST_BASE_IND_C p_calc_value is **********|%lf|\n",*p_calc_value);  // AIX -Warnings Reaoval
			APL_GOBACK_SUCCESS				 	
		}	
	}
	
	if ( !strcmp(p_basis,INTEREST_BASE_IND_D))
	{
      int_l_exist_a = 0;
      if (APL_FAILURE  == CO_Chk_CntryEnabled("CA_FMT_INT","INT_BASIS_D",&int_l_exist_a,l_debug_info_ptr))
      {
         APL_GOBACK_FAIL
      }
      if (int_l_exist_a > 0)
      {
			 *p_calc_value = (p_rate/100)*1;
			 printf("Inside INTEREST_BASE_IND_D p_calc_value is **********|%lf|\n",*p_calc_value);  // AIX -Warnings Reaoval
      }
      else
      {
		*p_calc_value = (p_rate/100) * (((360*(to_yr - dbl_from_yr)) + 30*(to_month - dbl_from_month) + (to_day - dbl_from_day))/360);
		printf("Inside ELSE INTEREST_BASE_IND_D p_calc_value is **********|%lf|\n",*p_calc_value);  // AIX -Warnings Reaoval
		}
			APL_GOBACK_SUCCESS				 	
	}
	
	
	if ( !strcmp(p_basis,INTEREST_BASE_IND_E))
	{	EXEC SQL SELECT TO_DATE(:p_to_date) - TO_DATE(:p_from_date) 
		INTO :dbl_h_num_days1 FROM dual;
		IS_ANY_ORA_ERROR		
			
	 *p_calc_value = (p_rate/100) * (dbl_h_num_days1/365);
     printf("Inside INTEREST_BASE_IND_E p_calc_value is *******shiva***|%lf|\n",*p_calc_value);  // AIX -Warnings Reaoval
		APL_GOBACK_SUCCESS				 	
	}

	APL_GOBACK_SUCCESS

	RETURN_SUCCESS:
	{
		return (APL_SUCCESS);
	}
	RETURN_FAILURE:
	{
		return (APL_FAILURE);
	}
}


static int	CA_CalcDaysInAYear(	int				chr_p_year,
											int				*p_no_days,
											DEBUG_INFO_STRUCT_H	**l_debug_info_ptr)

{
	*p_no_days = (!(chr_p_year%4)?(!(chr_p_year%100)?(!(chr_p_year%400)?366:365):366):365);
			
	
	APL_GOBACK_SUCCESS

	RETURN_SUCCESS:
	{
		return (APL_SUCCESS);
	}
/* AIX Warning
	RETURN_FAILURE:
	{
		return (APL_FAILURE);
	}
*/
}



static int 		CA_CalcPosnAdj(		char				*p_from_date,
											char				*p_to_date,
											char				*p_instr_code,
											char				*chr_p_client,
											double			*p_posn_adj,
											DEBUG_INFO_STRUCT_H	**l_debug_info_ptr)
{
	struct sqlca sqlca;
	char 		chr_trdcode_df[APL_FLAG_LENGTH]	=APL_DEAL_DF,
				chr_trdcode_rf[APL_FLAG_LENGTH]	=APL_DEAL_RF,
				chr_trdcode_dvp[APL_FLAG_LENGTH]	=APL_DEAL_DVP,
				chr_trdcode_rvp[APL_FLAG_LENGTH]	=APL_DEAL_RVP;

	char 		chr_trdcode_cd[APL_FLAG_LENGTH]	=APL_DEAL_CD,
				chr_trdcode_cr[APL_FLAG_LENGTH]	=APL_DEAL_CR,
				chr_trdcode_dcd[APL_FLAG_LENGTH]	=APL_DEAL_DCD,
				chr_trdcode_rcr[APL_FLAG_LENGTH]	=APL_DEAL_RCR;

	double	dbl_h_sum_trd=0.0,dbl_h_sum_trd_hist=0.0;
	short		i_sum_trd;

	EXEC SQL SELECT NVL(SUM(DECODE(deal_cd,:chr_trdcode_df,QTY,
														:chr_trdcode_dvp,QTY,
														:chr_trdcode_rf,-QTY,
														:chr_trdcode_rvp,-QTY,
														:chr_trdcode_dcd,QTY,
														:chr_trdcode_rcr,-QTY)),0)
	INTO	:dbl_h_sum_trd:i_sum_trd
	FROM 	DL_DEAL
	WHERE client 	= :chr_p_client
	AND	instr_code	= :p_instr_code
	AND   deal_date >= TO_DATE(:p_from_date,'dd/mm/yyyy') and deal_date <= to_date(:p_to_date,'dd/mm/yyyy')
	AND   DEAL_STAT not in ('DU','DA','DS')
	AND DL_CLASS not in ('59','56');/* Condition added by Chirag 13-11-2006 for not to consider shortage & square off deals*/
	IS_ANY_ORA_ERROR
	/* ISKB-462:AMitB:Added equal to sign to skip exdated trades 261007 */

	EXEC SQL SELECT NVL(SUM(DECODE(deal_cd,:chr_trdcode_df,QTY,
														:chr_trdcode_dvp,+QTY,
														:chr_trdcode_rf,-QTY,
														:chr_trdcode_rvp,-QTY,
														:chr_trdcode_dcd,QTY,
														:chr_trdcode_rcr,-QTY)),0)
	INTO	:dbl_h_sum_trd_hist
	FROM 	DL_HISDEAL
	WHERE client	=:chr_p_client
	AND	instr_code	=:p_instr_code
   AND   deal_date >=TO_DATE(:p_from_date,'dd/mm/yyyy')  and deal_date <= to_date(:p_to_date,'dd/mm/yyyy')
	AND 	DEAL_STAT != 'DD'
	AND DL_CLASS not in ('59','56');/* Condition added by Chirag 13-11-2006 for not to consider shortage & square off deal
s*/
	IS_ANY_ORA_ERROR
/* ISKB-462:AMitB:Added equal to sign to skip exdated trades 261007 */

	*p_posn_adj= dbl_h_sum_trd + dbl_h_sum_trd_hist;
  	 Alert("Position Chirag %lf ", *p_posn_adj);

	APL_GOBACK_SUCCESS

	RETURN_SUCCESS:
	{
		return (APL_SUCCESS);
	}
	RETURN_FAILURE:
	{
		return (APL_FAILURE);
	}

}

static int     CA_CalcPosnAdj_Tr(    char           *p_from_date,
                                 char           *p_to_date,
                                 char           *p_instr_code,
                                 char           *chr_p_client,
                                 double         *p_posn_adj,
                                 DEBUG_INFO_STRUCT_H   **l_debug_info_ptr)
{
   struct sqlca sqlca;
   char     chr_trdcode_df[APL_FLAG_LENGTH]   =APL_DEAL_DF,
            chr_trdcode_rf[APL_FLAG_LENGTH]   =APL_DEAL_RF,
            chr_trdcode_dvp[APL_FLAG_LENGTH]  =APL_DEAL_DVP,
            chr_trdcode_rvp[APL_FLAG_LENGTH]  =APL_DEAL_RVP;

	char 		chr_trdcode_cd[APL_FLAG_LENGTH]	=APL_DEAL_CD,
				chr_trdcode_cr[APL_FLAG_LENGTH]	=APL_DEAL_CR,
				chr_trdcode_dcd[APL_FLAG_LENGTH]	=APL_DEAL_DCD,
				chr_trdcode_rcr[APL_FLAG_LENGTH]	=APL_DEAL_RCR;

   double   dbl_h_sum_trd=0.0,dbl_h_sum_trd_hist=0.0,dbl_h_sum_uu=0.0;
   short    i_sum_trd=0,i_sum_uu=0;
	/* PJ For SP, CR add qty which are created due to sp processing upto pay date 
	if (  strcmp(g_ca_caevent_struct_h.h_evt_class,"SP") == 0 
			  && (strcmp(g_ca_caevent_struct_h.h_op_evt_class,"SP") == 0  
			          ||  strcmp(g_ca_caevent_struct_h.h_op_evt_class,"SR") == 0 ))
	{
   EXEC SQL SELECT NVL(SUM(DECODE(deal_cd,:chr_trdcode_df,QTY,
                                          :chr_trdcode_dvp,QTY,
                                          :chr_trdcode_rf,QTY,
														:chr_trdcode_rvp,QTY,
														:chr_trdcode_dcd,-QTY,
														:chr_trdcode_rcr,QTY)),0)
   INTO  :dbl_h_sum_trd:i_sum_trd
   FROM  DL_DEAL
   WHERE client  = :chr_p_client
   AND   instr_code   = :p_instr_code
   AND   deal_date = :g_ca_caevent_struct_h.h_pymt_dt 
   AND   DEAL_STAT not in ('DU','DA','DS')
	AND   INFORMATON = :g_ca_caevent_struct_h.h_corp_id;
   IS_ANY_ORA_ERROR

   *p_posn_adj= dbl_h_sum_trd; 
	}*/
   
	if (  strcmp(g_ca_caevent_struct_h.h_evt_class,"SP") == 0 ||  strcmp(g_ca_caevent_struct_h.h_evt_class,"CR") == 0)
	{
	EXEC SQL SELECT /*+ ALL_ROWS */ NVL(SUM(DECODE(deal_cd,:chr_trdcode_df,QTY,
                                          :chr_trdcode_dvp,QTY,
                                          :chr_trdcode_rf,-QTY,
														:chr_trdcode_rvp,-QTY,
														:chr_trdcode_dcd,QTY,
														:chr_trdcode_rcr,-QTY)),0)
   INTO  :dbl_h_sum_trd:i_sum_trd
   FROM  DL_DEAL
   WHERE client  = :chr_p_client
   AND   instr_code   = :p_instr_code
   AND   deal_date >= (TO_DATE(:p_from_date)) 
   AND   DEAL_STAT not in ('DU','DA','DS')
   AND DL_CLASS not in ('59','56'); /*Condition added by Chirag 13-11-2006 for not to consider shortage & square off deals*/
   IS_ANY_ORA_ERROR
	}
	else
	{
		
	EXEC SQL SELECT /*+ ALL_ROWS */ NVL(SUM(DECODE(deal_cd,:chr_trdcode_df,QTY,
                                          :chr_trdcode_dvp,QTY,
                                          :chr_trdcode_rf,-QTY,
														:chr_trdcode_rvp,-QTY,
														:chr_trdcode_dcd,QTY,
														:chr_trdcode_rcr,-QTY)),0)
   INTO  :dbl_h_sum_trd:i_sum_trd
   FROM  DL_DEAL
   WHERE client  = :chr_p_client
   AND   instr_code   = :p_instr_code
   AND   deal_date >= (TO_DATE(:p_from_date)) 
   AND   DEAL_STAT not in ('DU','DA','DS');
   IS_ANY_ORA_ERROR
	}
	Alert("dbl_h_sum_trd Position %lf and p_from_date is %s ", dbl_h_sum_trd,p_from_date); // Alert Added by Amit.Nair
	
	if (  strcmp(g_ca_caevent_struct_h.h_evt_class,"SP") == 0 ||  strcmp(g_ca_caevent_struct_h.h_evt_class,"CR") == 0)
	{
   EXEC SQL SELECT /*+ ALL_ROWS */ NVL(SUM(DECODE(deal_cd,:chr_trdcode_df,QTY,
                                          :chr_trdcode_dvp,+QTY,
                                          :chr_trdcode_rf,-QTY,
														:chr_trdcode_rvp,-QTY,
														:chr_trdcode_dcd,QTY,
														:chr_trdcode_rcr,-QTY)),0)
   INTO  :dbl_h_sum_trd_hist
   FROM  DL_HISDEAL
   WHERE client  =:chr_p_client
   AND   instr_code   =:p_instr_code
   AND   deal_date >=TO_DATE(:p_from_date) 
   AND   DEAL_STAT != 'DD'
   AND DL_CLASS not in ('59','56'); /*Condition added by Chirag 13-11-2006 for not to consider shortage & square off deals*/
   IS_ANY_ORA_ERROR
	}
	else
	{
   EXEC SQL SELECT /*+ ALL_ROWS */ NVL(SUM(DECODE(deal_cd,:chr_trdcode_df,QTY,
                                          :chr_trdcode_dvp,+QTY,
                                          :chr_trdcode_rf,-QTY,
														:chr_trdcode_rvp,-QTY,
														:chr_trdcode_dcd,QTY,
														:chr_trdcode_rcr,-QTY)),0)
   INTO  :dbl_h_sum_trd_hist
   FROM  DL_HISDEAL
   WHERE client  =:chr_p_client
   AND   instr_code   =:p_instr_code
   AND   deal_date >=TO_DATE(:p_from_date) 
   AND   DEAL_STAT != 'DD';
   /* AND DL_CLASS not in ('59','56'); Condition added by Chirag 13-11-2006 for not to consider shortage & square off deals*/
   IS_ANY_ORA_ERROR
	}

	Alert("dbl_h_sum_trd_hist Position %lf ", dbl_h_sum_trd_hist); // Alert Added by Amit.Nair
		/* SGS exclude unauth trades */
   EXEC SQL SELECT /*+ ALL_ROWS */ NVL(SUM(DECODE(deal_cd,:chr_trdcode_df,QTY,
                                          :chr_trdcode_dvp,QTY,
                                          :chr_trdcode_rf,-QTY,
														:chr_trdcode_rvp,-QTY,
														:chr_trdcode_dcd,QTY,
														:chr_trdcode_rcr,-QTY)),0)
   INTO  :dbl_h_sum_uu:i_sum_uu
   FROM  DL_DEAL
   WHERE client  = :chr_p_client
   AND   instr_code   = :p_instr_code
   AND   deal_date < (TO_DATE(:p_from_date)) 
   AND   DEAL_STAT = 'UU';
   /* AND DL_CLASS not in ('59','56'); Condition added by Chirag 13-11-2006 for not to consider shortage & square off deals*/
   IS_ANY_ORA_ERROR

	Alert("dbl_h_sum_uu Position %lf ", dbl_h_sum_uu); // Alert Added by Amit.Nair
   *p_posn_adj= dbl_h_sum_trd + dbl_h_sum_trd_hist+ dbl_h_sum_uu;

   Alert("Adjusted Position %lf ", *p_posn_adj);
   APL_GOBACK_SUCCESS

   RETURN_SUCCESS:
   {
      return (APL_SUCCESS);
   }
   RETURN_FAILURE:
   {
      return (APL_FAILURE);
   }

}


static int 		CA_HuPosnAdj(		char				*p_from_date,
											char				*p_instr_code,
											char				*chr_p_client,
											double			*p_posn_adj,
											DEBUG_INFO_STRUCT_H	**l_debug_info_ptr)
{

	struct sqlca sqlca;
	char 		chr_trdcode_df[APL_FLAG_LENGTH]	=APL_DEAL_DF,
				chr_trdcode_rf[APL_FLAG_LENGTH]	=APL_DEAL_RF,
				chr_trdcode_dvp[APL_FLAG_LENGTH]	=APL_DEAL_DVP,
				chr_trdcode_rvp[APL_FLAG_LENGTH]	=APL_DEAL_RVP;
	
	char 		chr_trdcode_cd[APL_FLAG_LENGTH]	=APL_DEAL_CD,
				chr_trdcode_cr[APL_FLAG_LENGTH]	=APL_DEAL_CR,
				chr_trdcode_dcd[APL_FLAG_LENGTH]	=APL_DEAL_DCD,
				chr_trdcode_rcr[APL_FLAG_LENGTH]	=APL_DEAL_RCR;


	double	dbl_h_sum_trd=0.0;
	short		i_sum_trd;

	EXEC SQL SELECT /*+ ALL_ROWS */ SUM(DECODE(deal_cd,:chr_trdcode_rf,QTY,
													:chr_trdcode_rvp,+QTY,
													:chr_trdcode_df,-QTY,
													:chr_trdcode_dvp,-QTY,
													:chr_trdcode_dcd,-QTY,
													:chr_trdcode_rcr,+QTY))
	INTO	:dbl_h_sum_trd:i_sum_trd
	FROM 	DL_DEAL
	WHERE client 	= :chr_p_client
	AND	instr_code	= :p_instr_code
	AND	VAL_FDT	IS NOT NULL	
	AND 	setl_date <= :p_from_date
	AND	INSTRUMENT_DT		IS NULL;	
	IS_ANY_ORA_ERROR

	*p_posn_adj= dbl_h_sum_trd ;
	
	APL_GOBACK_SUCCESS

	RETURN_SUCCESS:
	{
		return (APL_SUCCESS);
	}
	RETURN_FAILURE:
	{
		return (APL_FAILURE);
	}

}

static int	CA_SendEntitlMsg(	char* p_event_type,
						char* p_msg_key1,
						char* p_msg_key2,
						DEBUG_INFO_STRUCT_H ** l_debug_info_ptr)
{

	struct sqlca sqlca;
	char	chr_msg_code[7];
	char l_param_str[201] =APL_NULL_STRING;
	memset(l_param_str,APL_NULL_CHAR,201);
	if(!strcmp(g_ca_caevent_struct_h.h_entl_send_msg_ind,APL_YES_IND))
	{
		
		if((!strcmp(p_event_type,EVT_STOK_DIV))
			||(!strcmp(p_event_type,EVT_BONUS))
			||(!strcmp(p_event_type,EVT_SPLIT))
			||(!strcmp(p_event_type,EVT_CASH_DIV)) ||(!strcmp(p_event_type,EVT_DECR_VAL)) || (!strcmp(p_event_type,"CR")))
			strcpy(chr_msg_code,MSG_NO_ENT_CD_SD_BO_SP);      
		else if((!strcmp(p_event_type,EVT_BOND)))
			strcpy(chr_msg_code,MSG_NO_ENT_BI);
		else if(!strcmp(p_event_type,EVT_RHTS))
			strcpy(chr_msg_code,MSG_NO_ENT_RT);
		else if(!strcmp(p_event_type,EVT_BOND_REDMP))
			strcpy(chr_msg_code,MSG_NO_ENT_RD);
		else if(!strcmp(p_event_type,EVT_OFFER) || !strcmp(p_event_type,"BB") || !strcmp(p_event_type,"CV"))
			strcpy(chr_msg_code,MSG_NO_ENT_OP);

	memset(l_param_str,APL_NULL_CHAR,201);
		if ( GBDbInsIMSGENT(	chr_msg_code,
									p_msg_key1,
									p_msg_key2,
									'Y',
									l_param_str, /*Smita - Changed - HDFCCA_001*/
									l_debug_info_ptr) == APL_FAILURE )
			APL_GOBACK_FAIL
	}
	
	
	APL_GOBACK_SUCCESS
	RETURN_SUCCESS:
	{
		return (APL_SUCCESS);
	}
	RETURN_FAILURE:
	{
		return (APL_FAILURE);
	}
}

int	CA_SendEntitlChgMsg(	char* p_event_type,
								char* p_msg_key1,
								char* p_msg_key2,
								DEBUG_INFO_STRUCT_H ** l_debug_info_ptr)
{
	struct sqlca sqlca;
	char	chr_msg_code[7];
	char l_param_str[201] =APL_NULL_STRING;
	memset(l_param_str,APL_NULL_CHAR,201);
	if(!strcmp(g_ca_caevent_struct_h.h_entl_send_msg_ind,APL_YES_IND))
	{
		if((!strcmp(p_event_type,EVT_STOK_DIV))
			||(!strcmp(p_event_type,EVT_BONUS))
			||(!strcmp(p_event_type,EVT_SPLIT))
			||(!strcmp(p_event_type,EVT_CASH_DIV)) ||(!strcmp(p_event_type,EVT_DECR_VAL)) || (!strcmp(p_event_type,"CR")))
			strcpy(chr_msg_code,MSG_NO_ENT_CHG_CD_SD_BO_SP);               
		else if((!strcmp(p_event_type,EVT_BOND)))
			strcpy(chr_msg_code,MSG_NO_ENT_CHG_BI);
		else if(!strcmp(p_event_type,EVT_RHTS))
			strcpy(chr_msg_code,MSG_NO_ENT_CHG_RT);
		else if(!strcmp(p_event_type,EVT_BOND_REDMP))
			strcpy(chr_msg_code,MSG_NO_ENT_CHG_RD);
		else if(!strcmp(p_event_type,EVT_OFFER) || !strcmp(p_event_type,"CV") || !strcmp(p_event_type,"BB"))
			strcpy(chr_msg_code,MSG_NO_ENT_CHG_OP);

	memset(l_param_str,APL_NULL_CHAR,201);
		if ( GBDbInsIMSGENT(	chr_msg_code,
									p_msg_key1,
									p_msg_key2,
									'Y',
									l_param_str, /*Smita - Changed - HDFCCA_001*/
									l_debug_info_ptr) == APL_FAILURE )
			APL_GOBACK_FAIL
	}
	
	
	APL_GOBACK_SUCCESS
	RETURN_SUCCESS:
	{
		return (APL_SUCCESS);
	}
	RETURN_FAILURE:
	{
		return (APL_FAILURE);
	}
}
static	int CA_Commit ( int				p_commit_status,
					int				p_commit_level,
					DEBUG_INFO_STRUCT_H	**l_debug_info_ptr)
{
	short l_cond_gr1 = 0; 
	struct sqlca sqlca;


   
   if(APL_FAILURE == CO_Chk_CntryEnabled(  "EVNT_INIT",
                                          "EX_REC",
                                          &l_cond_gr1,
                                          l_debug_info_ptr ))
      {
        APL_GOBACK_FAIL
      }

	if (p_commit_status == APL_FAILURE)
	{
		EXEC SQL ROLLBACK;
		IS_ANY_ORA_ERROR
	}
	printf("g_account is %s, g_ca_id is %s\n",chr_g_client,g_ca_caevent_struct_h.h_corp_id);
	EXEC SQL UPDATE CACHGEVENT 		
				SET CURR_CLT = :chr_g_client 
				WHERE corp_id = :g_ca_caevent_struct_h.h_corp_id;
	IS_ANY_ORA_ERROR 
	g_priority = g_ca_caevent_struct_h.h_priority;
	strcpy(chr_g_restart_ca_id,ltoa(g_priority));	
	strcat(chr_g_restart_ca_id,		g_ca_caevent_struct_h.h_corp_id);
	strcpy(chr_g_restart_client,	chr_g_client);

  	sprintf(chr_g_restart_data_h,"%s%s%s%s",
				chr_g_restart_ca_id,
				S_RESTART_SEP_TOKEN,
				chr_g_restart_client,
				S_RESTART_SEP_TOKEN);
	Alert("restart Data |%s|\n",chr_g_restart_data_h);

	 EXEC SQL UPDATE SYS_BATCHPROC
  	SET PROCESSING_STATUS = :chr_g_restart_data_h
  	WHERE PROCESS_NAME	=:chr_g_progname
  	AND	PROC_INIT		=:chr_g_key
  	AND	STARTDATE=:chr_g_start_date
  	AND 	STATUS	='started';
	IS_ANY_ORA_ERROR 
	EXEC SQL COMMIT;


	Alert("commit_level = |%d|\n",p_commit_level);
	
	switch ( p_commit_level)
	{
		case (S_LEVEL_EVENT) :
		{

			strcpy(chr_g_restart_client, " ");
			if (l_cond_gr1)
			{
			EXEC SQL OPEN AevntCur_gt_gr;
			IS_ANY_ORA_ERROR
			}
			else
			{
			EXEC SQL OPEN AevntCur_gt;
			IS_ANY_ORA_ERROR
			}
			break;
		}
		case (S_LEVEL_ENTITL) :
		{
      		if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
            	&& (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0)
            	&&(int_g_date_diff==0))
      		{
      			EXEC SQL OPEN AaccountCur1;
      			IS_ANY_ORA_ERROR
					break;
      		}
      		else if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
            	      && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0)
               	&&(int_g_date_diff==0))
      		{
      			EXEC SQL OPEN AaccountCur2;
      			IS_ANY_ORA_ERROR
					break;
      		}
      		else if ((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
            	   &&(int_g_date_diff > 0)
						&& (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0))
      		{
      			EXEC SQL OPEN AaccountCur3;
      			IS_ANY_ORA_ERROR
					break;
      		}
      		else if((strcmp(g_ca_caevent_struct_h.h_evt_stat,STATUS_RDY_ENTL)==0)
           		    &&(int_g_date_diff > 0)
               	 && (strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0))
				{
      			EXEC SQL OPEN AaccountCur6;
      			IS_ANY_ORA_ERROR
					break;
				}
      		else if((strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_DL)==0)  && (int_g_flg_mod_event == 0))
      		{
      			EXEC SQL OPEN AaccountCur4;
      			IS_ANY_ORA_ERROR
					break;
      		}
      		else if((strcmp(q_ca_caseceventstruct_h->h_entitl_base,ENTL_BASE_SETL)==0) &&(int_g_flg_mod_event== 0))
      		{
      			EXEC SQL OPEN AaccountCur5;
      			IS_ANY_ORA_ERROR
					break;
      		}
      		else if  (int_g_flg_mod_event == 1)
      		{
      			EXEC SQL OPEN AaccountCur7;
      			IS_ANY_ORA_ERROR
					break;
      		}
		}
	}

	APL_GOBACK_SUCCESS
	RETURN_SUCCESS:
	{
		return (APL_SUCCESS);
	}
	RETURN_FAILURE:
	{
		return (APL_FAILURE);
	}
}
int	CA_GetPrevBusinessDay(	const	char				*chr_p_inp_date,
										char						*p_out_date,
										DEBUG_INFO_STRUCT_H	**l_debug_info_ptr)
{
	struct sqlca sqlca;
	char	chr_out_date[APL_DATE_LEN]	=	APL_NULL_STRING;
	short	i_out_date	=	0;

	APL_FUNCTION_ENTER(g_logfile)

	EXEC SQL SELECT MIN(H_DATE) - 1
				INTO	:chr_out_date:i_out_date
				FROM	MT_HOLIDAY
				WHERE STATUS='AA'
				AND BANK_IND = 'Y'
				CONNECT BY PRIOR	H_DATE - 1 = H_DATE
				AND 	PRIOR STATUS = STATUS
				START WITH H_DATE=:chr_p_inp_date 
				AND 	STATUS='AA'
				AND BANK_IND = 'Y';
	IS_ANY_ORA_ERROR

	if	(i_out_date	==	-1)
	{
		strcpy(chr_out_date,chr_p_inp_date);
	}

	strcpy(p_out_date,chr_out_date);
	
	APL_GOBACK_SUCCESS
   RETURN_SUCCESS  :
		APL_FUNCTION_RET_SUCCESS(g_logfile)
   RETURN_FAILURE  :
		APL_FUNCTION_RET_FAILURE(g_logfile)
}



int	CA_Proc_GenUpdEntitl( 	CA_CAENTITLEMENT_STRUCT_H 	*p_ca_caentitlement_struct_h,
										CA_CAENTITLEMENT_STRUCT_I 	*p_ca_caentitlement_struct_i,
										CA_CAENTITLEMENT_STRUCT_H 	*p_entitl_img_struct_h,
										char					 			*p_ora_rowid,
                     			INTL_ENV_DATA_STRUCT_H 	 	*p_intlenv_data_struct_h,
                     			DEBUG_INFO_STRUCT_H 		 	**l_debug_info_ptr)

{
	struct	sqlca	sqlca;
	CA_CHK_DET_STRUCT_H    *l_ca_chk_det_struct_h   =  (CA_CHK_DET_STRUCT_H *)NULL;
	int	count					=	0;
	double h_sum_earnings 	= 	0.0;
	double h_sum_quantity	= 	0.0;
	
	
	APL_FUNCTION_ENTER(g_logfile)
	l_ca_chk_det_struct_h=(CA_CHK_DET_STRUCT_H *)calloc(	1,sizeof(CA_CHK_DET_STRUCT_H)	);
	APL_MALLOC_FAIL(l_ca_chk_det_struct_h) 

	
	if	(	CA_CheckEntl	(	p_ca_caentitlement_struct_h->h_corp_id,
									p_ca_caentitlement_struct_h->h_dl_client,
 	 		   		    		l_ca_chk_det_struct_h, 
									p_intlenv_data_struct_h,
									l_debug_info_ptr)	==	APL_FAILURE)
	{
		CO_ProcMonitor(g_logfile,"Failed In CA_CheckEntl",NULL,NULL);
		/**Sana [ISAB 108][RBS][30-12-2010]**/
	 		sprintf(chr_g_fail_buff,"  Event |%s|, Entitlement Generation Failed, Reason : Failed In CA_CheckEntl.\n",g_ca_caevent_struct_h.h_corp_id);
			CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
		/**End**/
		APL_GOBACK_FAIL
	}

	if ( p_ca_caentitlement_struct_h->h_entitl_pos < 0 ) 
	{
		EXEC SQL SELECT NVL(COUNT(*),0) 
					INTO :count
					FROM CACHEQUE
					WHERE CORP_ID 	= :p_ca_caentitlement_struct_h->h_corp_id
					AND	CLIENT 	= :p_ca_caentitlement_struct_h->h_dl_client
					AND	STAT_PYMT NOT IN ('RV','DL')
					AND 	ROWNUM 	< 2;
		IS_ANY_ORA_ERROR /** Added -- Biju **/		
		if ( count > 0 ) 
			strcpy(p_ca_caentitlement_struct_h->h_entitl_stat,STATUS_FROZ_RP);
		else 
			strcpy(p_ca_caentitlement_struct_h->h_entitl_stat,STATUS_PENDING);
	}

	else 
	{
		EXEC SQL SELECT /*+ ALL_ROWS */
         	         NVL(SUM(CURR_PYMT),0),
      	            NVL(SUM(QUANTITY_RECEIVED),0)
   				INTO
                  	:h_sum_earnings,
                  	:h_sum_quantity
   				FROM 	CACHEQUE
   				WHERE CORP_ID	=:p_ca_caentitlement_struct_h->h_corp_id    
					AND 	CLIENT	=:p_ca_caentitlement_struct_h->h_dl_client   
					AND 	STAT_PYMT NOT IN   ('RV','DL');
		IS_ANY_ORA_ERROR
	
		if	(	 ( p_ca_caentitlement_struct_h->h_instr_inc_bal <  h_sum_earnings ) ||
			  	 (	p_ca_caentitlement_struct_h->h_quantity_due	< h_sum_quantity	)) 
			strcpy(p_ca_caentitlement_struct_h->h_entitl_stat,STATUS_FROZ_RP);
	}
				
	if		(	CA_Mod_EntitlRec(p_ca_caentitlement_struct_h,
										p_ca_caentitlement_struct_i,
										p_ora_rowid,
										l_debug_info_ptr
										) == APL_FAILURE)
	{

		CO_ProcMonitor(g_logfile,"Failed In CA_Mod_EntitlRec",NULL,NULL);
		/**Sana [ISAB 108][RBS][30-12-2010]**/
	 		sprintf(chr_g_fail_buff,"  Event |%s|, Entitlement Generation Failed, Reason : Failed In CA_Mod_EntitlRec.\n",g_ca_caevent_struct_h.h_corp_id);
			CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
		/**End**/
		APL_GOBACK_FAIL
	}	
	
	APL_GOBACK_SUCCESS
	RETURN_SUCCESS	:
		APL_FREE(l_ca_chk_det_struct_h);
		APL_FUNCTION_RET_SUCCESS(g_logfile)
			
	RETURN_FAILURE	:
		APL_FREE(l_ca_chk_det_struct_h);
		APL_FUNCTION_RET_FAILURE(g_logfile)
		APL_FUNCTION_RET_FAILURE(g_failurefile)		/**Sana [ISAB 108][RBS][30-12-2010]**/

}


static int CA_RedenomCalcEnt(  short                p_safek_flg,
                               CA_CASECEVENT_STRUCT_H   *p_ca_casecevent_struct_h,
                               char                 *p_rec_date_h,
                               char                 *chr_p_client,
                               INTL_ENV_DATA_STRUCT_H    *p_intlenv_data_struct_h,
                               DEBUG_INFO_STRUCT_H         **l_debug_info_ptr)
  
{ 
      struct	sqlca sqlca;
      char    	chr_prev_rec_dt [APL_DATE_LEN]	=	APL_NULL_STRING;
      int     	int_h_count			=	0;
      double  	posn_adj				=	0.00;
      int     	int_h_date_diff	=	0;
      double  	h_safekeep_pos		=	0.0;
		double	h_sum_hissafekeep_pos	=	0.0;
      short  	i_date_diff			=	0;
      double	l_uneur_after_rnd	=	0.0;
		double  	l_eur_after_rnd	=	0.0;
		static  	double   grd_euro_exchg_rt = 0.0;
      double  	l_tot_entpos		=	0.0;
		double  	l_tot_uneur_after_rnd	=	0.0;
		double  	l_tot_eur_after_rnd 	=	0.0;
		char		chr_eur_ccycode[APL_CCYCODE_LEN]	=	{APL_EMU_CCYCODE};
		char		chr_grd_ccycode[APL_CCYCODE_LEN]	=	{APL_GRD_CCYCODE};
		char		h_loccode[APL_LOCNCODE_LENGTH]	=	APL_NULL_STRING;
		short		i_loccode 	=	0;
      char    chr_h_sts_rdy_pymt[APL_STATUS_LEN]	=	{STATUS_RDY_PYMT};
      char    chr_h_func_area_redenom[6]				=	{FUNC_AREA_REDENOM};
		CA_CACHEQUE_STRUCT_H	*l_ca_cacheque_struct_ha	= (CA_CACHEQUE_STRUCT_H *)NULL;
		CA_CACHEQUE_STRUCT_I	*l_ca_cacheque_struct_ia	= (CA_CACHEQUE_STRUCT_I *)NULL;
		char 		h_maker[APL_USERID_LEN]				=	APL_NULL_STRING;
		int		seqnum_pay	=	1;

		/**
		 * EXEC SQL VAR h_loccode IS STRING; -- take cared by makefile -- Biju **/
		
		APL_FUNCTION_ENTER(g_logfile)
		strcpy(h_maker,"SYSTEM");
		l_ca_cacheque_struct_ha = ( CA_CACHEQUE_STRUCT_H *) calloc ( 1, sizeof(CA_CACHEQUE_STRUCT_H) ); 
		APL_MALLOC_FAIL(l_ca_cacheque_struct_ha)

		l_ca_cacheque_struct_ia = ( CA_CACHEQUE_STRUCT_I *) calloc ( 1, sizeof(CA_CACHEQUE_STRUCT_I) ); 
		APL_MALLOC_FAIL(l_ca_cacheque_struct_ia)
 
			

			if ( grd_euro_exchg_rt == 0 )
			{
			if ( !strcmp(l_mt_core_sys_params_struct_h.dir_indir_fxqt_ind,"I") )
			{	
         /*Commented and rewritten by sana as below for entitlement opt EXEC SQL SELECT a.EXCHGRT
         INTO :grd_euro_exchg_rt
         FROM  MT_EXCHRATE a
         WHERE a.DENOM_CCY=:chr_eur_ccycode
         AND   a.currency_cd= :chr_grd_ccycode
   		AND a.RATE_DATE = ( SELECT MAX(b.RATE_DATE)
                     FROM MT_EXCHRATE b
                     WHERE b.DENOM_CCY = :chr_eur_ccycode
                     AND b.currency_cd = :chr_grd_ccycode
                  );*/

		 EXEC SQL SELECT a.EXCHGRT
         INTO :grd_euro_exchg_rt
         FROM  MT_EXCHRATE a, ( SELECT MAX(b.RATE_DATE) RATE_DATE
                     FROM MT_EXCHRATE b
                     WHERE b.DENOM_CCY = :chr_eur_ccycode
                     AND b.currency_cd = :chr_grd_ccycode
                  ) b
         WHERE a.DENOM_CCY=:chr_eur_ccycode
         AND   a.currency_cd= :chr_grd_ccycode
   		AND a.RATE_DATE = b.RATE_DATE;


         IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,"GRD-EUR","Indirect","Exchange rate")
			}
			else
			{
         /*Commented and rewritten by Sana as below EXEC SQL SELECT a.EXCHGRT
         INTO :grd_euro_exchg_rt
         FROM  MT_EXCHRATE a
         WHERE a.DENOM_CCY=:chr_grd_ccycode
         AND   a.currency_cd= :chr_eur_ccycode
   		AND a.RATE_DATE = ( SELECT MAX(b.RATE_DATE)
                     FROM MT_EXCHRATE b
                     WHERE b.DENOM_CCY = :chr_grd_ccycode
                     AND b.currency_cd = :chr_eur_ccycode
                  );*/
				  EXEC SQL SELECT a.EXCHGRT
				 INTO :grd_euro_exchg_rt
				 FROM  MT_EXCHRATE a, (SELECT MAX(b.RATE_DATE) RATE_DATE
							 FROM MT_EXCHRATE b
							 WHERE b.DENOM_CCY = :chr_grd_ccycode
							 AND b.currency_cd = :chr_eur_ccycode
                  ) b
				 WHERE a.DENOM_CCY=:chr_grd_ccycode
				 AND   a.currency_cd= :chr_eur_ccycode
				AND a.RATE_DATE = b.RATE_DATE;

         IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,"EUR-GRD","Direct","Exchange rate")
			}

	
			} 
			EXEC SQL DECLARE csafekcur CURSOR
			FOR	
			SELECT /*+ALL_ROWS*/ NVL(safekeep_pos,0),location_cd 
			FROM DL_SAFEK
			WHERE		 instr_code = :g_ca_caevent_struct_h.h_instr_code
			AND	client =:chr_p_client
			ORDER BY location_cd;
			
			
			EXEC SQL DECLARE chissafekcur CURSOR
			FOR	
			SELECT /*+ALL_ROWS*/ NVL(safekeep_pos,0), location_cd 
			FROM DL_HISSAFEK
			WHERE instr_code = :g_ca_caevent_struct_h.h_instr_code
			AND	POSIT_DATE 	= 	:p_rec_date_h
			AND	client =:chr_p_client
			ORDER BY location_cd;

			EXEC SQL SELECT TO_DATE(:chr_g_sys_date) - TO_DATE(:p_rec_date_h)
			INTO :int_h_date_diff :i_date_diff from dual;
			IS_ANY_ORA_ERROR
	
			if(int_h_date_diff > 0)
			{
				h_sum_hissafekeep_pos=0.0;
				int_h_count =0;
				
				EXEC SQL SELECT count(*) into :int_h_count  
				FROM MT_HOLIDAY
				WHERE H_DATE = :p_rec_date_h
				AND	STATUS = 'AA'
				AND BANK_IND = 'Y';
				IS_ANY_ORA_ERROR
				
				if(int_h_count == 1)
				{
	 				memset(chr_prev_rec_dt,NULL,APL_DATE_LEN);
					if(CA_GetPrevBusinessDay(	p_rec_date_h,
														chr_prev_rec_dt,
														l_debug_info_ptr)==APL_FAILURE)
						APL_GOBACK_FAIL
				
					strcpy(p_rec_date_h,chr_prev_rec_dt);
				}	
			}

		/*Smita - Entitlement Mnt - Added val for FRACT_DUE,FRACT_RCVD cols - HDFCCA_001,HDFCCA_002,HDFCCA_017*/	
		EXEC SQL INSERT /*+APPEND_VALUES*/ INTO CAENTITLEMENT
		VALUES
		(
         :g_ca_caevent_struct_h.h_corp_id,
         :chr_g_client,
			0,
			:g_ca_caevent_struct_h.h_ca_currency,
			0,
			0,
			0,
			0,
			NULL,
			NULL,
			NULL,
			:chr_h_sts_rdy_pymt,	
			:chr_g_sys_date,
			:h_maker,
			:chr_g_sys_date,
			:h_maker,
			:chr_g_sys_date,
			:chr_g_sys_date_time,
			0,
			0,
			0
		);
	
		IS_ANY_ORA_ERROR
	

			
			if(int_h_date_diff > 0)
			{
				EXEC SQL OPEN chissafekcur;
				IS_ANY_ORA_ERROR
			}
			else
			{
				EXEC SQL OPEN csafekcur;
				IS_ANY_ORA_ERROR
			}

		
		for (;;) 
		{
			h_safekeep_pos=0.0;
			strcpy(h_loccode,APL_NULL_STRING);

			if(int_h_date_diff > 0)
			{
				EXEC SQL FETCH chissafekcur
				INTO	
				:h_safekeep_pos ,:h_loccode:i_loccode ;

				IS_ANY_ORA_ERROR_CURSOR
			}
			else
			{
				EXEC SQL FETCH csafekcur
				INTO	
				:h_safekeep_pos ,:h_loccode:i_loccode ;
				IS_ANY_ORA_ERROR_CURSOR
			}

		if ( h_safekeep_pos > 0 ) 
		{
		    
     
			CO_Round( h_safekeep_pos/ grd_euro_exchg_rt,
                 UROUND_EUR_DEC_LEN,
                  &l_uneur_after_rnd
                );


		 	CO_Round( l_uneur_after_rnd,
                 EUR_DEC_LEN,
                  &l_eur_after_rnd
                );

        
        strcpy(l_ca_cacheque_struct_ha->h_corp_id,g_ca_caevent_struct_h.h_corp_id);
        strcpy(l_ca_cacheque_struct_ha->h_dl_client,chr_g_client);
        l_ca_cacheque_struct_ha->h_pymt_srl_nbr = seqnum_pay++;
        strcpy(l_ca_cacheque_struct_ha->h_pymt_dt,g_ca_caevent_struct_h.h_pymt_dt);
        strcpy(l_ca_cacheque_struct_ha->h_pymt_currency,g_ca_caevent_struct_h.h_ca_currency);
        l_ca_cacheque_struct_ha->h_curr_pymt = 0;
        l_ca_cacheque_struct_ha->h_quantity_recd = l_eur_after_rnd;
        l_ca_cacheque_struct_ha->h_tax_rate = 0;
        strcpy(l_ca_cacheque_struct_ha->h_pymt_inst,APL_NULL_STRING);
        l_ca_cacheque_struct_ia->i_handoff_date = -1;
        l_ca_cacheque_struct_ia->i_txn_indentity_no = -1;
        l_ca_cacheque_struct_ia->i_billdate = -1;
        strcpy(l_ca_cacheque_struct_ha->h_loccode,h_loccode);
        l_ca_cacheque_struct_ha->h_tax_amount = 0;
        l_ca_cacheque_struct_ha->h_other_chrgs = 0;
        strcpy(l_ca_cacheque_struct_ha->h_pymt_stat,STATUS_RDY_PYMT);
        strcpy(l_ca_cacheque_struct_ha->h_stat_date,chr_g_sys_date);
        strcpy(l_ca_cacheque_struct_ha->h_new_dt,chr_g_sys_date);
        strcpy(l_ca_cacheque_struct_ha->h_maker,"SYSTEM");
        strcpy(l_ca_cacheque_struct_ha->h_maker_dt,chr_g_sys_date);
        strcpy(l_ca_cacheque_struct_ha->h_checker,"SYSTEM");
        strcpy(l_ca_cacheque_struct_ha->h_checker_dt,chr_g_sys_date);
        strcpy(l_ca_cacheque_struct_ha->h_access_stamp,chr_g_sys_date_time);
        l_ca_cacheque_struct_ia->i_clt_pass_flg = -1;
        l_ca_cacheque_struct_ia->i_clt_batch_no = -1;
        l_ca_cacheque_struct_ha->h_quantity_paid = 0;
	    l_ca_cacheque_struct_ha->h_net_amount=0;//Changes done by Sunny for CS0020637

        EXEC SQL INSERT /*+APPEND*/ INTO CACHEQUE
        VALUES ( :l_ca_cacheque_struct_ha:l_ca_cacheque_struct_ia );
  
        IS_ANY_ORA_ERROR
  
 
         EXEC SQL INSERT /*+APPEND_VALUES*/ INTO PRO_EURO_TEMP
         VALUES
         (  :g_ca_caevent_struct_h.h_instr_code,
            :chr_g_client,
            :h_loccode,
            :h_safekeep_pos,
            :l_uneur_after_rnd,
            :l_eur_after_rnd,
				NULL,	
				NULL,
				:chr_h_func_area_redenom,
				0,
				0,
				NULL
			);

        IS_ANY_ORA_ERROR

			l_tot_entpos =l_tot_entpos + h_safekeep_pos;
			l_tot_uneur_after_rnd = l_tot_uneur_after_rnd + l_uneur_after_rnd;
			l_tot_eur_after_rnd = l_tot_eur_after_rnd + l_eur_after_rnd;

		 } 
		}  
		if ( l_tot_entpos > 0 )
		{

		EXEC SQL UPDATE /*+ALL_ROWS*/ CAENTITLEMENT
		SET elig_entitl_pos=:l_tot_entpos,
			 quantity_bal = :l_tot_eur_after_rnd
		WHERE
			corp_id=:g_ca_caevent_struct_h.h_corp_id AND
			client=:chr_g_client	;		
	
		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_ENTITLE_NOTFND,g_ca_caevent_struct_h.h_corp_id,chr_g_client,APL_NULL_STRING)

		sprintf(chr_g_log_buff,"Created Entitlement For %s Account",chr_g_client);
		CO_ProcMonitor(g_logfile,chr_g_log_buff,l_debug_info_ptr,NULL);

		}
		else
		{
		EXEC SQL DELETE CAENTITLEMENT
		WHERE
			corp_id=:g_ca_caevent_struct_h.h_corp_id AND
			client=:chr_g_client	;		
	
		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_ENTITLE_NOTFND,g_ca_caevent_struct_h.h_corp_id,chr_g_client,APL_NULL_STRING)
		/**Sana [ISAB 108][RBS][30-12-2010]**/
		sprintf(chr_g_fail_buff,"  Event : |%s| Client : |%s|, Entitlement Not Generated, Reason : Calculated Entitled Position < 0\n",g_ca_caevent_struct_h.h_corp_id,chr_g_client);
		CO_ProcMonitor(g_failurefile,chr_g_fail_buff,NULL,NULL);
		/**End**/

		}

	
	APL_GOBACK_SUCCESS
	RETURN_SUCCESS	:
			APL_FREE(l_ca_cacheque_struct_ha);
			APL_FREE(l_ca_cacheque_struct_ia);
			APL_FUNCTION_RET_SUCCESS(g_logfile)
			
	RETURN_FAILURE	:
			APL_FREE(l_ca_cacheque_struct_ha);
			APL_FREE(l_ca_cacheque_struct_ia);
			APL_FUNCTION_RET_FAILURE(g_logfile)
			APL_FUNCTION_RET_FAILURE(g_failurefile)		/**Sana [ISAB 108][RBS][30-12-2010]**/

}
