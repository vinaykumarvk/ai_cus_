/*
 *    COPYRIGHT NOTICE
 *
 *   Copyright 2005 Polaris Software Lab Limited. All rights reserved.
 *
 *   These materials are confidential and proprietary to 
 *    Polaris Software Lab Limited and no part of these materials should
 *    be reproduced, published, transmitted or distributed in any form or
 *    by any means, electronic, mechanical, photocopying, recording or 
 *    otherwise, or stored in any information storage or retrieval system
 *    of any nature nor should the materials be disclosed to third parties
 *    or used in any other manner for which this is not authorized, without
 *    the prior express written authorization of Polaris Software Lab Limited.
 */
/*********************************************************************
 *
 * Module Name         :	Maintenance
 *
 * File Name           : 	MT_DbProcInstrument.pc
 *
 * Description         :  	This file contains all functions for maintenance
 *									of Instrument Details in the System.	
 *
 *           
 *
 *            Version Control Block
 *
 * Date        Version		Author               Description			RFS No.
 * ---------   --------	 ---------------  --------------------		-------------
 * 10/10/2005  1.1 	 		Smita Bhat				New File				HDFCMT_003	
 *
 * 03/01/2005	1.2			Smita Bhat				Changes as per 	HDFCMT_003
 * 															Client Discussion
 *
 *********************************************************************/

#include <CO_HostStructdef.h>
#include "MT_Interface.h"
#include "Intellect_Common.h"

EXEC SQL INCLUDE sqlca;

extern 	char *g_chld_table_names[]; 
extern	char  g_mst_table_name[];
char		*p_key_codes[2] = {"INSTR_CODE",APL_NULL_STRING};
char		*p_key_values[2];
	
char		p_status[APL_STATUS_LEN];	
int		p_next_seq_num = 0;
char		p_field_name[25] = "INSTR_SEQ_NUM";

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Mod_Instr                                                               	*
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Structure, Row Id, 					            *
 *                         Env String and debug pointer. Used in Input and Modify Modes.                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_struct_h  				MT_INSTRUMENT_STRUCT_H 				I      Instrument Details			*
 *                                                                             Structure 			         *
 *																																			*
 *	p_row_id_instr								char *									I		 Row Id of Instrument		*
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Mod_Instr(		MT_INSTRUMENT_STRUCT_H *p_mt_instrument_struct_h,
							char *p_row_id_instr,
							INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
							DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca 		  				sqlca;
	int     		 		  				int_retval;
	char			 		  				chr_h_sys_access_stamp[APL_DATE_LEN] = APL_NULL_STRING;
	MT_INSTRUMENT_STRUCT_I  		*l_mt_instrument_struct_i = NULL;
	char									h_status[APL_STATUS_LEN] = APL_NULL_STRING;
	char									chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;
	int         h_field_val;  /* Added  by Gouse For Decimal Length of MF-  31/10/2011 */
     short       i_field_val; /* Added  by Gouse For Decimal Length of MF-  31/10/2011 */
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
	{
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Mod_Instr \n",NULL,p_intl_env_data_struct_h);
		memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
		sprintf(chr_l_buf,"Instrument Code is |%s| \n",p_mt_instrument_struct_h->h_instr_code);
		CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
		
		memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
		sprintf(chr_l_buf,"Mode is |%s| \n",p_intl_env_data_struct_h->h_mode);
		CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
	}
 
	l_mt_instrument_struct_i = (MT_INSTRUMENT_STRUCT_I *)calloc(1,sizeof(MT_INSTRUMENT_STRUCT_I));
	APL_MALLOC_FAIL(l_mt_instrument_struct_i)

	APL_IF_DEBUG
	{
		printf("Calling Function CR_Chk_InstrISINUnique with following details...\n");
		printf("Instrument Code = |%s|\n",p_mt_instrument_struct_h->h_instr_code);
		printf("Instrument ISIN = |%s|\n",p_mt_instrument_struct_h->h_instr_isin);
	}

	int_retval = CR_Chk_InstrISINUnique(	p_mt_instrument_struct_h->h_instr_code,
														p_mt_instrument_struct_h->h_instr_isin,
														l_debug_info_ptr);

	if (int_retval == APL_RECS_EXIST)
	{
		CO_InsertErr(	l_debug_info_ptr,
							ERR_INSTR_ISIN_EXISTS,
							APL_NULL_STRING,
							APL_NULL_STRING,
							APL_NULL_STRING,
							__LINE__,
							__FILE__);
		APL_GOBACK_FAIL
	}
	else if (int_retval == APL_FAILURE)
	{
		APL_GOBACK_FAIL
	}
		
	l_mt_instrument_struct_i->i_instr_code 		= 0;
	l_mt_instrument_struct_i->i_currency_cd 	= 0;
	l_mt_instrument_struct_i->i_nominal_value 	= 0;
	l_mt_instrument_struct_i->i_reg_br_ind 		= 0;
	l_mt_instrument_struct_i->i_allow_rf 			= 0;
	l_mt_instrument_struct_i->i_allow_rvp 		= 0;
	l_mt_instrument_struct_i->i_allow_df 			= 0;
	l_mt_instrument_struct_i->i_allow_dvp 		= 0;
	l_mt_instrument_struct_i->i_ord_type 		= 0;
	l_mt_instrument_struct_i->i_mother_sec_ind 	= 0;
	l_mt_instrument_struct_i->i_ex_arena 			= 0;
	l_mt_instrument_struct_i->i_listed_ind 		= 0;
	l_mt_instrument_struct_i->i_dateof_input 				= 0;
	l_mt_instrument_struct_i->i_threshold_qty 	= 0;
	l_mt_instrument_struct_i->i_maker 				= 0;
	l_mt_instrument_struct_i->i_maker_dt 			= 0;
	l_mt_instrument_struct_i->i_access_stamp 	= 0;
	l_mt_instrument_struct_i->i_status 			= 0;
	l_mt_instrument_struct_i->i_new_issue 		= 0;
	l_mt_instrument_struct_i->i_instr_name 		= 0;
	l_mt_instrument_struct_i->i_instr_isin 		= 0;
	l_mt_instrument_struct_i->i_tipo_inv 			= 0;
	l_mt_instrument_struct_i->i_instr_type 		= 0;
	l_mt_instrument_struct_i->i_instr_sub_type 		= 0;
	l_mt_instrument_struct_i->i_sec_dl_code 		= 0;
	l_mt_instrument_struct_i->i_prod_class 		= 0;
	l_mt_instrument_struct_i->i_instr_corporate_grp      = 0;
	l_mt_instrument_struct_i->i_instr_diluted_ratio_new  = 0;
	l_mt_instrument_struct_i->i_instr_diluted_ratio_old  = 0;

	if(strlen(p_mt_instrument_struct_h->h_location_cd) == 0)
		l_mt_instrument_struct_i->i_location_cd = -1;
	else
		l_mt_instrument_struct_i->i_location_cd = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_new_maker) == 0)
		l_mt_instrument_struct_i->i_new_maker = -1;
	else
		l_mt_instrument_struct_i->i_new_maker = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_new_checker) == 0)
		l_mt_instrument_struct_i->i_new_checker = -1;
	else
		l_mt_instrument_struct_i->i_new_checker = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_chng_lst_ind) == 0)
		l_mt_instrument_struct_i->i_chng_lst_ind = -1;
	else
		l_mt_instrument_struct_i->i_chng_lst_ind = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_cert_of_own_in) == 0)
		l_mt_instrument_struct_i->i_cert_of_own_in = -1;
	else
		l_mt_instrument_struct_i->i_cert_of_own_in = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_instr_parent) == 0)
		l_mt_instrument_struct_i->i_instr_parent = -1;
	else
		l_mt_instrument_struct_i->i_instr_parent = 0;

	if(strlen(p_mt_instrument_struct_h->h_classcd) == 0)
		l_mt_instrument_struct_i->i_classcd = -1;
	else
		l_mt_instrument_struct_i->i_classcd = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_new_cd) == 0)
		l_mt_instrument_struct_i->i_new_cd = -1;
	else
		l_mt_instrument_struct_i->i_new_cd = 0;

 	if(strlen(p_mt_instrument_struct_h->h_chng_isin) == 0)
 		l_mt_instrument_struct_i->i_chng_isin = -1;
	else
 		l_mt_instrument_struct_i->i_chng_isin = 0;
	
 	if(strlen(p_mt_instrument_struct_h->h_chg_mkr) == 0)
 		l_mt_instrument_struct_i->i_chg_mkr = -1;
	else
 		l_mt_instrument_struct_i->i_chg_mkr = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_ca_name) == 0)
		l_mt_instrument_struct_i->i_ca_name = -1;
	else
		l_mt_instrument_struct_i->i_ca_name = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_chng_cd) == 0)
		l_mt_instrument_struct_i->i_chng_cd = -1;
	else
		l_mt_instrument_struct_i->i_chng_cd = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_mature_dt) == 0)
		l_mt_instrument_struct_i->i_mature_dt = -1;
	else
		l_mt_instrument_struct_i->i_mature_dt = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_int_typ) == 0)
		l_mt_instrument_struct_i->i_int_typ = -1;
	else
		l_mt_instrument_struct_i->i_int_typ = 0;
	
	if(p_mt_instrument_struct_h->h_instr_int_rate == 0)
		l_mt_instrument_struct_i->i_instr_int_rate = -1;
	else
		l_mt_instrument_struct_i->i_instr_int_rate = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_freq_code) == 0)
		l_mt_instrument_struct_i->i_freq_code = -1;
	else
		l_mt_instrument_struct_i->i_freq_code = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_int_acctyp) == 0)
		l_mt_instrument_struct_i->i_int_acctyp = -1;
	else
		l_mt_instrument_struct_i->i_int_acctyp = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_last_pymt_date) == 0)
		l_mt_instrument_struct_i->i_last_pymt_date = -1;
	else
		l_mt_instrument_struct_i->i_last_pymt_date = 0;
	
	if(p_mt_instrument_struct_h->h_last_incom_rt == 0)
		l_mt_instrument_struct_i->i_last_incom_rt = -1;
	else
		l_mt_instrument_struct_i->i_last_incom_rt = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_next_pay_date) == 0)
		l_mt_instrument_struct_i->i_next_pay_date = -1;
	else
		l_mt_instrument_struct_i->i_next_pay_date = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_old_lst_paydt) == 0)
		l_mt_instrument_struct_i->i_old_lst_paydt = -1;
	else
		l_mt_instrument_struct_i->i_old_lst_paydt = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_mod_last_paydt) == 0)
		l_mt_instrument_struct_i->i_mod_last_paydt = -1;
	else
		l_mt_instrument_struct_i->i_mod_last_paydt = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_taxonmat_ind) == 0)
		l_mt_instrument_struct_i->i_taxonmat_ind = -1;
	else
		l_mt_instrument_struct_i->i_taxonmat_ind = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_disct_ind) == 0)
		l_mt_instrument_struct_i->i_disct_ind = -1;
	else
		l_mt_instrument_struct_i->i_disct_ind = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_ca_addrdet) == 0)
		l_mt_instrument_struct_i->i_ca_addrdet = -1;
	else
		l_mt_instrument_struct_i->i_ca_addrdet = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_lr_setl_date_a) == 0)
		l_mt_instrument_struct_i->i_lr_setl_date_a = -1;
	else
		l_mt_instrument_struct_i->i_lr_setl_date_a = 0;
	
	if(strlen(p_mt_instrument_struct_h->h_lr_setl_date_b) == 0)
		l_mt_instrument_struct_i->i_lr_setl_date_b = -1;
	else
		l_mt_instrument_struct_i->i_lr_setl_date_b = 0;
	
	if ( strlen(p_mt_instrument_struct_h->h_instr_shortnm) == 0 )  
		l_mt_instrument_struct_i->i_instr_shortnm = -1;
	else
		l_mt_instrument_struct_i->i_instr_shortnm = 0;

	if ( strlen(p_mt_instrument_struct_h->h_ipo_ind) == 0) 
		l_mt_instrument_struct_i->i_ipo_ind = -1;
	else
		l_mt_instrument_struct_i->i_ipo_ind = 0;

	if ( strlen(p_mt_instrument_struct_h->h_valid_ipo_date) == 0) 
		l_mt_instrument_struct_i->i_valid_ipo_date = -1;
	else
		l_mt_instrument_struct_i->i_valid_ipo_date = 0;

	/*Smita - HDFCMT_003 - Instrument Master Maintenance*/
	if (strlen(p_mt_instrument_struct_h->h_cmp_code) == 0)
		l_mt_instrument_struct_i->i_cmp_code = -1;
	else
		l_mt_instrument_struct_i->i_cmp_code = 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_reg_code) == 0)
		l_mt_instrument_struct_i->i_instr_reg_code = -1;
	else
		l_mt_instrument_struct_i->i_instr_reg_code = 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_swf_name) == 0)
		l_mt_instrument_struct_i->i_instr_swf_name = -1;
	else
		l_mt_instrument_struct_i->i_instr_swf_name = 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_priv_placed) == 0)
		l_mt_instrument_struct_i->i_instr_priv_placed = -1;
	else
		l_mt_instrument_struct_i->i_instr_priv_placed = 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_crisil_code) == 0)
		l_mt_instrument_struct_i->i_instr_crisil_code = -1;
	else
		l_mt_instrument_struct_i->i_instr_crisil_code = 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_is_secured) == 0)
		l_mt_instrument_struct_i->i_instr_is_secured = -1;
	else
		l_mt_instrument_struct_i->i_instr_is_secured = 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_secured_dt) == 0)
		l_mt_instrument_struct_i->i_instr_secured_dt = -1;
	else
		l_mt_instrument_struct_i->i_instr_secured_dt = 0;

	if (p_mt_instrument_struct_h->h_instr_tot_nom_val == 0)
		l_mt_instrument_struct_i->i_instr_tot_nom_val = -1;
	else
		l_mt_instrument_struct_i->i_instr_tot_nom_val= 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_pc_ind) == 0)
		l_mt_instrument_struct_i->i_instr_pc_ind= -1;
	else
		l_mt_instrument_struct_i->i_instr_pc_ind = 0;
/* - Effective Date and Cut Off Time for Put Call Moved to Put Call Table  - Smita - HDFCMT_003 */
	/*
	if (strlen(p_mt_instrument_struct_h->h_instr_pc_effdt) == 0)
		l_mt_instrument_struct_i->i_instr_pc_effdt = -1;
	else
		l_mt_instrument_struct_i->i_instr_pc_effdt = 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_pc_cutofftime) == 0)
		l_mt_instrument_struct_i->i_instr_pc_cutofftime = -1;
	else
		l_mt_instrument_struct_i->i_instr_pc_cutofftime = 0;
	*/
/* - Effective Date and Cut Off Time for Put Call Moved to Put Call Table  - Smita - HDFCMT_003 */

	if (strlen(p_mt_instrument_struct_h->h_instr_part_rd_flg) == 0)
		l_mt_instrument_struct_i->i_instr_part_rd_flg= -1;
	else
		l_mt_instrument_struct_i->i_instr_part_rd_flg =0;

	if (strlen(p_mt_instrument_struct_h->h_instr_reset_flg) == 0)
		l_mt_instrument_struct_i->i_instr_reset_flg= -1;
	else
		l_mt_instrument_struct_i->i_instr_reset_flg= 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_exdt_loa) == 0)
		l_mt_instrument_struct_i->i_instr_exdt_loa= -1;
	else
		l_mt_instrument_struct_i->i_instr_exdt_loa= 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_fst_pymt_dt) == 0)
		l_mt_instrument_struct_i->i_instr_fst_pymt_dt= -1;
	else
		l_mt_instrument_struct_i->i_instr_fst_pymt_dt= 0;

	if (p_mt_instrument_struct_h->h_instr_div_rate == 0)
		l_mt_instrument_struct_i->i_instr_div_rate= -1;
	else
		l_mt_instrument_struct_i->i_instr_div_rate= 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_is_demat) == 0)
		l_mt_instrument_struct_i->i_instr_is_demat= -1;
	else
		l_mt_instrument_struct_i->i_instr_is_demat= 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_remark) == 0)
		l_mt_instrument_struct_i->i_instr_remark= -1;
	else
		l_mt_instrument_struct_i->i_instr_remark= 0;

	if (p_mt_instrument_struct_h->h_instrshut_period == 0)
		l_mt_instrument_struct_i->i_instrshut_period= -1;
	else
		l_mt_instrument_struct_i->i_instrshut_period= 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_isin_name) == 0)
		l_mt_instrument_struct_i->i_instr_isin_name= -1;
	else
		l_mt_instrument_struct_i->i_instr_isin_name= 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_attached) == 0)
		l_mt_instrument_struct_i->i_instr_attached= -1;
	else
		l_mt_instrument_struct_i->i_instr_attached= 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_detach_dt) == 0)
		l_mt_instrument_struct_i->i_instr_detach_dt= -1;
	else
		l_mt_instrument_struct_i->i_instr_detach_dt= 0;

	if (p_mt_instrument_struct_h->h_total_pdcapita == 0)
		l_mt_instrument_struct_i->i_total_pdcapita= -1;
	else
		l_mt_instrument_struct_i->i_total_pdcapita= 0;	

	if(strlen(p_mt_instrument_struct_h->h_instr_sub_type) == 0)
		l_mt_instrument_struct_i->i_instr_sub_type = -1;
	else
		l_mt_instrument_struct_i->i_instr_sub_type = 0;

	/* Added by bhuvana for ICICI Retro - Start */
	   if (strlen(p_mt_instrument_struct_h->h_instr_corporate_grp) == 0)
		l_mt_instrument_struct_i->i_instr_corporate_grp = -1;
	else
		l_mt_instrument_struct_i->i_instr_corporate_grp = 0;
	
	if (p_mt_instrument_struct_h->h_instr_diluted_ratio_new == 0)
		l_mt_instrument_struct_i->i_instr_diluted_ratio_new = -1;
	else
		l_mt_instrument_struct_i->i_instr_diluted_ratio_new = 0;
	
	if (p_mt_instrument_struct_h->h_instr_diluted_ratio_old == 0)
		l_mt_instrument_struct_i->i_instr_diluted_ratio_old = -1;
	else
		l_mt_instrument_struct_i->i_instr_diluted_ratio_old = 0;
	/* Added by bhuvana for ICICI Retro - ends */

	/*	ST1.0	*/
	if(strlen(p_mt_instrument_struct_h->h_instr_type) == 0)
		l_mt_instrument_struct_i->i_instr_type = -1;
	else
		l_mt_instrument_struct_i->i_instr_type = 0;

	//Added by Bawa -- 8/11/2008 -- RBI Monthly Investment Report -- Start 
	if (strlen(p_mt_instrument_struct_h->h_instr_tier_1) == 0)
		l_mt_instrument_struct_i->i_instr_tier_1 = -1;
	else
		l_mt_instrument_struct_i->i_instr_tier_1 = 0;

	if (strlen(p_mt_instrument_struct_h->h_instr_tier_2) == 0)
		l_mt_instrument_struct_i->i_instr_tier_2 = -1;
	else
		l_mt_instrument_struct_i->i_instr_tier_2 = 0;
	// Added by Bawa -- 8/11/2008 -- RBI Monthly Investment Report -- End 

	/***printf("l_mt_instrument_struct_i->i_listed_ind is %s\n",l_mt_instrument_struct_i->i_listed_ind);
	printf("p_mt_instrument_struct_h->i_listed_ind is %s\n",p_mt_instrument_struct_h->i_listed_ind);***/

 
/***Srinivas - updating instr_code after checking value from instr_sub_code**/
	/*
	
		EXEC SQL SELECT MAP_VAL INTO :p_mt_instrument_struct_h->h_instr_type:l_mt_instrument_struct_i->i_instr_type
					FROM PRO_SGENSTAT
					WHERE MAP_TYPE='INSTR_SUB_TYPE'
					AND MAP_DESC =:p_mt_instrument_struct_h->h_instr_sub_type;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	*/
	/*Smita - HDFCMT_003 - Instrument Master Maintenance */

	if (CO_RtvSysDtTime(chr_h_sys_access_stamp, l_debug_info_ptr) != APL_SUCCESS)
	 	APL_GOBACK_FAIL

	p_key_values[0] = p_mt_instrument_struct_h->h_instr_code;
	p_key_values[1] = APL_NULL_STRING;
        /* Added  by Gouse For Decimal Length of MF- Start - 31/10/2011 */
         EXEC SQL SELECT FIELD_VAL INTO :h_field_val :i_field_val
             FROM PRO_GSSPLVAL
             WHERE MAIN_FUN='QUANTITY_DEC_LEN'
             AND SUB_PROCESS='DEC_FOR_MUTFUND';
         if ( h_field_val <  p_mt_instrument_struct_h->h_dec_len_mf)
         {
               CO_InsertErr( l_debug_info_ptr,
               ERR_INVALID_DEC_LEN_INST, 
               APL_NULL_STRING,
               APL_NULL_STRING,
               APL_NULL_STRING,
               __LINE__,
               __FILE__);
               APL_GOBACK_FAIL
          }

   l_mt_instrument_struct_i->i_dec_len_mf = 0; 
	APL_IF_DEBUG
	{
		printf("PRO_GSSPLVAL.FIELD_VAL -> h_field_val = %d\n", h_field_val);
		printf("DEC_LEN_MF  = |%d|\n", p_mt_instrument_struct_h->h_dec_len_mf);
		printf("Mode = |%s|\n",p_intl_env_data_struct_h->h_mode);
	}
        /* Added  by Gouse For Decimal Length of MF- End - 31/10/2011 */

	
	if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_INPUT) == 0)
	{
   	strcpy(p_mt_instrument_struct_h->h_status, STATUS_UAUTH); 
   	strcpy(p_mt_instrument_struct_h->h_maker, p_intl_env_data_struct_h->usr);
   	strcpy(p_mt_instrument_struct_h->h_maker_dt, chr_h_sys_access_stamp); 
   	strcpy(p_mt_instrument_struct_h->h_checker, APL_NULL_STRING); 
   	strcpy(p_mt_instrument_struct_h->h_checker_dt, APL_NULL_STRING); 
   	strcpy(p_mt_instrument_struct_h->h_access_stamp, chr_h_sys_access_stamp); 
   	strcpy(p_mt_instrument_struct_h->h_dateof_input, chr_h_sys_access_stamp); 

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
			APL_GOBACK_FAIL

		EXEC SQL INSERT INTO MT_INSTRUMENT
		VALUES(:p_mt_instrument_struct_h:l_mt_instrument_struct_i);

		IS_ANY_ORA_ERROR_AND_DUPLICATE(ERR_REC_EXIST,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
	{
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
			APL_GOBACK_FAIL

		strcpy((char *)h_status,STATUS_UAUTH);
	  
		EXEC SQL UPDATE MT_INSTRUMENT
 		SET 
		CURRENCY_CD = :p_mt_instrument_struct_h->h_currency_cd:l_mt_instrument_struct_i->i_currency_cd,
		LOCATION_CD = :p_mt_instrument_struct_h->h_location_cd:l_mt_instrument_struct_i->i_location_cd,
		NOMINAL_VALUE = :p_mt_instrument_struct_h->h_nominal_value:l_mt_instrument_struct_i->i_nominal_value,
		REG_BR_IND = :p_mt_instrument_struct_h->h_reg_br_ind:l_mt_instrument_struct_i->i_reg_br_ind,
		ALLOW_RF = :p_mt_instrument_struct_h->h_allow_rf:l_mt_instrument_struct_i->i_allow_rf,
		ALLOW_RVP = :p_mt_instrument_struct_h->h_allow_rvp:l_mt_instrument_struct_i->i_allow_rvp,
		ALLOW_DF = :p_mt_instrument_struct_h->h_allow_df:l_mt_instrument_struct_i->i_allow_df,
		ALLOW_DVP = :p_mt_instrument_struct_h->h_allow_dvp:l_mt_instrument_struct_i->i_allow_dvp,
		ORD_TYPE = :p_mt_instrument_struct_h->h_ord_type:l_mt_instrument_struct_i->i_ord_type,
		MOTHER_SEC_IND = :p_mt_instrument_struct_h->h_mother_sec_ind:l_mt_instrument_struct_i->i_mother_sec_ind,
		EX_ARENA = :p_mt_instrument_struct_h->h_ex_arena:l_mt_instrument_struct_i->i_ex_arena,
		LISTED_IND = :p_mt_instrument_struct_h->h_listed_ind:l_mt_instrument_struct_i->i_listed_ind,
		THRESHOLD_QTY = :p_mt_instrument_struct_h->h_threshold_qty:l_mt_instrument_struct_i->i_threshold_qty,
		NEW_MAKER = :p_mt_instrument_struct_h->h_new_maker:l_mt_instrument_struct_i->i_new_maker,
		MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_struct_i->i_maker,
		MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_struct_i->i_maker_dt,
		ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_struct_i->i_access_stamp,
		CHECKER = NULL,
		CHECKER_DT = NULL,
		TOTAL_PDCAPITA = :p_mt_instrument_struct_h->h_total_pdcapita:l_mt_instrument_struct_i->i_total_pdcapita,
		/*STATUS = :h_status,*/
		NEW_ISSUE = :p_mt_instrument_struct_h->h_new_issue:l_mt_instrument_struct_i->i_new_issue,
		NEW_CHECKER = :p_mt_instrument_struct_h->h_new_checker:l_mt_instrument_struct_i->i_new_checker,
		CHNG_LST_IND = :p_mt_instrument_struct_h->h_chng_lst_ind:l_mt_instrument_struct_i->i_chng_lst_ind,
		CERT_OF_OWN_IN =:p_mt_instrument_struct_h->h_cert_of_own_in:l_mt_instrument_struct_i->i_cert_of_own_in,
		INSTR_NAME = :p_mt_instrument_struct_h->h_instr_name:l_mt_instrument_struct_i->i_instr_name,
		INSTR_ISIN = :p_mt_instrument_struct_h->h_instr_isin:l_mt_instrument_struct_i->i_instr_isin,
		TIPO_INV = :p_mt_instrument_struct_h->h_tipo_inv:l_mt_instrument_struct_i->i_tipo_inv,
		INSTR_TYPE = :p_mt_instrument_struct_h->h_instr_type:l_mt_instrument_struct_i->i_instr_type,
		INSTR_PARENT = :p_mt_instrument_struct_h->h_instr_parent:l_mt_instrument_struct_i->i_instr_parent,
		PROD_CLASS = :p_mt_instrument_struct_h->h_prod_class:l_mt_instrument_struct_i->i_prod_class,
		SEC_DL_CODE = :p_mt_instrument_struct_h->h_sec_dl_code:l_mt_instrument_struct_i->i_sec_dl_code,
		CLASSCD = :p_mt_instrument_struct_h->h_classcd:l_mt_instrument_struct_i->i_classcd,
		NEW_CD = :p_mt_instrument_struct_h->h_new_cd:l_mt_instrument_struct_i->i_new_cd,
		CHNG_ISIN = :p_mt_instrument_struct_h->h_chng_isin:l_mt_instrument_struct_i->i_chng_isin,
		ISSUE_DATE = :p_mt_instrument_struct_h->h_issue_date:l_mt_instrument_struct_i->i_issue_date,
		CHG_MKR = :p_mt_instrument_struct_h->h_chg_mkr:l_mt_instrument_struct_i->i_chg_mkr,
		CA_NAME = :p_mt_instrument_struct_h->h_ca_name:l_mt_instrument_struct_i->i_ca_name,
		CHNG_CD = :p_mt_instrument_struct_h->h_chng_cd:l_mt_instrument_struct_i->i_chng_cd,
		MATURE_DT = :p_mt_instrument_struct_h->h_mature_dt:l_mt_instrument_struct_i->i_mature_dt,
		INT_TYP = :p_mt_instrument_struct_h->h_int_typ:l_mt_instrument_struct_i->i_int_typ,
		INSTR_INT_RATE = :p_mt_instrument_struct_h->h_instr_int_rate:l_mt_instrument_struct_i->i_instr_int_rate,
		FREQ_CODE = :p_mt_instrument_struct_h->h_freq_code:l_mt_instrument_struct_i->i_freq_code,
		INT_ACCTYP = :p_mt_instrument_struct_h->h_int_acctyp:l_mt_instrument_struct_i->i_int_acctyp,
		LAST_PYMT_DATE= :p_mt_instrument_struct_h->h_last_pymt_date:l_mt_instrument_struct_i->i_last_pymt_date,
		LAST_INCOM_RT = :p_mt_instrument_struct_h->h_last_incom_rt:l_mt_instrument_struct_i->i_last_incom_rt,
		NEXT_PAY_DATE = :p_mt_instrument_struct_h->h_next_pay_date:l_mt_instrument_struct_i->i_next_pay_date,
		OLD_LST_PAYDT = :p_mt_instrument_struct_h->h_old_lst_paydt:l_mt_instrument_struct_i->i_old_lst_paydt,
		MOD_LAST_PAYDT = :p_mt_instrument_struct_h->h_mod_last_paydt:l_mt_instrument_struct_i->i_mod_last_paydt,
		TAXONMAT_IND = :p_mt_instrument_struct_h->h_taxonmat_ind:l_mt_instrument_struct_i->i_taxonmat_ind,
		DISCT_IND = :p_mt_instrument_struct_h->h_disct_ind:l_mt_instrument_struct_i->i_disct_ind,
		CA_ADDRDET = :p_mt_instrument_struct_h->h_ca_addrdet:l_mt_instrument_struct_i->i_ca_addrdet,
		MIN_FMT_DL_QTY=:p_mt_instrument_struct_h->h_min_fmt_dl_qty:l_mt_instrument_struct_i->i_min_fmt_dl_qty,
		LR_SETL_DATE_A = :p_mt_instrument_struct_h->h_lr_setl_date_a:l_mt_instrument_struct_i->i_lr_setl_date_a,
		LR_SETL_DATE_B = :p_mt_instrument_struct_h->h_lr_setl_date_b:l_mt_instrument_struct_i->i_lr_setl_date_b,
		INSTR_SHORTNM = :p_mt_instrument_struct_h->h_instr_shortnm:l_mt_instrument_struct_i->i_instr_shortnm,
		IPO_IND = :p_mt_instrument_struct_h->h_ipo_ind:l_mt_instrument_struct_i->i_ipo_ind,
		VALID_IPO_DATE = :p_mt_instrument_struct_h->h_valid_ipo_date:l_mt_instrument_struct_i->i_valid_ipo_date,
		LR_SETL_DATE_C = :p_mt_instrument_struct_h->h_lr_setl_date_c:l_mt_instrument_struct_i->i_lr_setl_date_c,
		CMP_CODE = :p_mt_instrument_struct_h->h_cmp_code:l_mt_instrument_struct_i->i_cmp_code,
		INSTR_REG_CODE =:p_mt_instrument_struct_h->h_instr_reg_code:l_mt_instrument_struct_i->i_instr_reg_code,
		INSTR_SWF_NAME =:p_mt_instrument_struct_h->h_instr_swf_name:l_mt_instrument_struct_i->i_instr_swf_name,
		INSTR_PRIV_PLACED =:p_mt_instrument_struct_h->h_instr_priv_placed:l_mt_instrument_struct_i->i_instr_priv_placed,
		INSTR_CRISIL_CODE =:p_mt_instrument_struct_h->h_instr_crisil_code:l_mt_instrument_struct_i->i_instr_crisil_code,
		INSTR_IS_SECURED =:p_mt_instrument_struct_h->h_instr_is_secured:l_mt_instrument_struct_i->i_instr_is_secured,
		INSTR_SECURED_DT =:p_mt_instrument_struct_h->h_instr_secured_dt:l_mt_instrument_struct_i->i_instr_secured_dt,
		INSTR_TOT_NOM_VAL =:p_mt_instrument_struct_h->h_instr_tot_nom_val:l_mt_instrument_struct_i->i_instr_tot_nom_val,
		INSTR_PC_IND = :p_mt_instrument_struct_h->h_instr_pc_ind:l_mt_instrument_struct_i->i_instr_pc_ind,
	/*	INSTR_PC_EFFDT =:p_mt_instrument_struct_h->h_instr_pc_effdt:l_mt_instrument_struct_i->i_instr_pc_effdt,
		INSTR_PC_CUTOFFTIME =:p_mt_instrument_struct_h->h_instr_pc_cutofftime:l_mt_instrument_struct_i->i_instr_pc_cutofftime,
		*/
		INSTR_PART_RD_FLG =:p_mt_instrument_struct_h->h_instr_part_rd_flg:l_mt_instrument_struct_i->i_instr_part_rd_flg,
		INSTR_RESET_FLG =:p_mt_instrument_struct_h->h_instr_reset_flg:l_mt_instrument_struct_i->i_instr_reset_flg,
		INSTR_EXDT_LOA =:p_mt_instrument_struct_h->h_instr_exdt_loa:l_mt_instrument_struct_i->i_instr_exdt_loa,
		INSTR_FST_PYMT_DT =:p_mt_instrument_struct_h->h_instr_fst_pymt_dt:l_mt_instrument_struct_i->i_instr_fst_pymt_dt,
		INSTR_DIV_RATE =:p_mt_instrument_struct_h->h_instr_div_rate:l_mt_instrument_struct_i->i_instr_div_rate,
		INSTR_IS_DEMAT =:p_mt_instrument_struct_h->h_instr_is_demat:l_mt_instrument_struct_i->i_instr_is_demat,
		INSTR_REMARK =:p_mt_instrument_struct_h->h_instr_remark:l_mt_instrument_struct_i->i_instr_remark,
		INSTRSHUT_PERIOD =:p_mt_instrument_struct_h->h_instrshut_period:l_mt_instrument_struct_i->i_instrshut_period,
		INSTR_ISIN_NAME =:p_mt_instrument_struct_h->h_instr_isin_name:l_mt_instrument_struct_i->i_instr_isin_name,
		INSTR_ATTACHED = :p_mt_instrument_struct_h->h_instr_attached:l_mt_instrument_struct_i->i_instr_attached,
		INSTR_SUB_TYPE = :p_mt_instrument_struct_h->h_instr_sub_type:l_mt_instrument_struct_i->i_instr_sub_type,
 		INSTR_DETACH_DT =:p_mt_instrument_struct_h->h_instr_detach_dt:l_mt_instrument_struct_i->i_instr_detach_dt,
		/* Added by Bawa -- 8/11/2008 -- RBI Monthly Investment Report -- Start  */
		INSTR_TIER_1 =:p_mt_instrument_struct_h->h_instr_tier_1:l_mt_instrument_struct_i->i_instr_tier_1,
		INSTR_TIER_2 =:p_mt_instrument_struct_h->h_instr_tier_2:l_mt_instrument_struct_i->i_instr_tier_2,
		/* Added by Bawa -- 8/11/2008 -- RBI Monthly Investment Report -- End */
                /* Added  by Gouse For Decimal Length of MF- Start - 31/10/2011 */
                DEC_LEN_MF = :p_mt_instrument_struct_h->h_dec_len_mf :l_mt_instrument_struct_i->i_dec_len_mf,
                /* Added  by Gouse For Decimal Length of MF- End - 31/10/2011 */
				/* Added by bhuvana for ICICI Retro - Start */
		INSTR_CORPORATE_GRP=:p_mt_instrument_struct_h->h_instr_corporate_grp:l_mt_instrument_struct_i->i_instr_corporate_grp,
		INSTR_DILUTED_RATIO_NEW=:p_mt_instrument_struct_h->h_instr_diluted_ratio_new:l_mt_instrument_struct_i->i_instr_diluted_ratio_new,
        INSTR_DILUTED_RATIO_OLD=:p_mt_instrument_struct_h->h_instr_diluted_ratio_old:l_mt_instrument_struct_i->i_instr_diluted_ratio_old 
		/* Added by bhuvana for ICICI Retro - ends*/

		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}

        /* Added  by Gouse For Decimal Length of MF- Start - 31/10/2011 */


        if ((!strcmp(p_intl_env_data_struct_h->usr,"GFU")) && !strcmp(p_mt_instrument_struct_h->h_maker,"GFU"))
        {
                strcpy(p_intl_env_data_struct_h->h_mode,APL_FUNC_AUTHORISE);
        }


        /* Added  by Gouse For Decimal Length of MF- End - 31/10/2011 */
   int_retval = CR_Mod_UpdMastStatus(  p_key_codes,
                                       p_key_values,
                                       g_mst_table_name,
                                       g_chld_table_names,
                                       APL_MASTER_IND,
                                       p_status,
                                       chr_h_sys_access_stamp,
                                       p_intl_env_data_struct_h,
                                       l_debug_info_ptr);

	APL_IF_DEBUG
	{
        	printf("Returned Status Value = |%s|\n",p_status);
	}
/*ISKB-430 - ASP,Shailesh*/
	if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_INPUT))
	{
		if ( APL_FAILURE == IV_Upd_DataGrp(p_key_values[0], p_status, p_intl_env_data_struct_h, l_debug_info_ptr))
		{
			CO_InsertErr(   l_debug_info_ptr,
                   "Error in Updating IV_DATA_GRP",
							p_key_values[0],
							APL_NULL_STRING,
							APL_NULL_STRING,
							__LINE__,
							__FILE__);

			APL_GOBACK_FAIL;
	
		}
	}


   if (int_retval != APL_SUCCESS)
     	APL_GOBACK_FAIL

   APL_GOBACK_SUCCESS

	RETURN_SUCCESS :
	{
		APL_FREE(l_mt_instrument_struct_i)

		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_Instr \n",NULL,p_intl_env_data_struct_h);
		return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
		APL_FREE(l_mt_instrument_struct_i)

		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_Instr \n",NULL,p_intl_env_data_struct_h);
		return(APL_FAILURE);
	}
}



int CR_Upt_Instr(		MT_INST_CORP_GRP_STRUCT_H *p_mt_inst_corp_grp_struct_h,
									INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
									DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca                     sqlca;
	char			 		  				chr_h_sys_access_stamp[APL_DATE_LEN] = APL_NULL_STRING;
	char									chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;
	int l_count = 0;
	int     		 		  				int_retval;
	char			 		  				chr_h_sys_date[APL_DATE_LEN] = APL_NULL_STRING;
 	
 	#ifdef APL_THREADS
    	APL_SET_CONTEXT
    	EXEC SQL CONTEXT USE :my_ctx_local;
 	#endif
	
	Alert("balaji3");
	
    if (CO_RtvSysDt(chr_h_sys_date, l_debug_info_ptr) != APL_SUCCESS)
	 	APL_GOBACK_FAIL
	if (CO_RtvSysDtTime(chr_h_sys_access_stamp, l_debug_info_ptr) != APL_SUCCESS)
	 	APL_GOBACK_FAIL
//	strcat(chr_h_sys_access_stamp,chr_h_sys_date);
	Alert("system date :|%s|",chr_h_sys_date);
	EXEC SQL SELECT COUNT(*) INTO :l_count FROM MT_INSTRUMENT 
			WHERE INSTR_CODE = :p_mt_inst_corp_grp_struct_h->h_instr_code;
			IS_ANY_ORA_ERROR
			if(l_count > 0)
			{
/* commented by rahul for uat fixed	for ignoring update checker and checker for null
	EXEC SQL UPDATE MT_INSTRUMENT
 		SET INSTR_CORPORATE_GRP = :p_mt_inst_corp_grp_struct_h -> h_instr_corporate_grp,
		MAKER = :p_intl_env_data_struct_h->usr,
		MAKER_DT = :chr_h_sys_access_stamp,
		ACCESS_STAMP = :chr_h_sys_access_stamp,
		CHECKER = NULL,
		CHECKER_DT = NULL
		
		WHERE INSTR_CODE = :p_mt_inst_corp_grp_struct_h->h_instr_code;

	*/  

    	EXEC SQL UPDATE MT_INSTRUMENT
 		SET INSTR_CORPORATE_GRP = :p_mt_inst_corp_grp_struct_h -> h_instr_corporate_grp,
		New_MAKER = :p_intl_env_data_struct_h->usr,
		MAKER_DT = :chr_h_sys_date,
		ACCESS_STAMP = :chr_h_sys_access_stamp
		WHERE INSTR_CODE = :p_mt_inst_corp_grp_struct_h->h_instr_code;	

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
			}
			
			else
			{
				CO_InsertErr(  l_debug_info_ptr,
		                           ERR_INSTR_NOTFND,
		                           p_mt_inst_corp_grp_struct_h->h_instr_code,
		                           APL_NULL_STRING,
		                           APL_NULL_STRING,
		                           __LINE__,
		                           __FILE__);
		            APL_GOBACK_FAIL
			}
				

 	APL_IF_DEBUG
 	{
    	CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Upt_Instr \n",NULL,p_intl_env_data_struct_h);
    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Instrument Code is |%s| \n",p_mt_inst_corp_grp_struct_h->h_instr_code);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);

    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Mode is |%s| \n",p_intl_env_data_struct_h->h_mode);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
 	}

	//if (int_retval != APL_SUCCESS)
		//APL_GOBACK_FAIL

	APL_GOBACK_SUCCESS
															
	RETURN_SUCCESS :
	{
  		APL_IF_DEBUG
    		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Upt_Instr with Success\n",NULL,p_intl_env_data_struct_h);
    		return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
  		APL_IF_DEBUG
   		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Upt_Instr with FAILURE \n",NULL,p_intl_env_data_struct_h);
   		return(APL_FAILURE);
	}
}



/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Mod_InstrOth                                                               *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code, Row Id,Deal Structure                  *
 *                         Env String and debug pointer. Used in other modes                             *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code            				char *           						I      Instrument Code 		      *
 *                                                                                                       *
 * p_row_id_instr                      char *                           I      Row Id of Instrument      *
 *																																			*
 * p_deal_ord_struct_h						DEAL_ORD_STRUCT_H *					I	    Deal Structure				*
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Mod_InstrOth(		char *p_instr_code,
								char *p_row_id_instr,
								DEAL_ORD_STRUCT_H *p_deal_ord_struct_h,
								INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca							sqlca;
	int										int_retval;
	char										h_status[APL_STATUS_LEN] = APL_NULL_STRING;
 	char										chr_h_sys_access_stamp[APL_DATE_LEN] = APL_NULL_STRING;
	int										int_h_flg = 0;
	char										chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;
	MT_INSTRUMENT_STRUCT_H         	*l_mt_instrument_struct_h = NULL; 
 	MT_INSTRUMENT_STRUCT_I         	*l_mt_instrument_struct_i = NULL; 

	p_key_values[0] = p_instr_code;
	p_key_values[1] = APL_NULL_STRING;
	
	/***** For Unlisted instruments By: vinay kalaskar *******/
	
	char l_price_date[APL_DATE_LEN],l_instr_code[APL_INSTRUMENTCODE_LEN];
	char l_modifymode[2],l_access_stamp[APL_DATE_LEN],l_maker_dt[APL_DATE_LEN],l_checker_dt[APL_DATE_LEN];
	char l_maker[15],l_checker[15],l_mkrtpr_stat[3];
	double l_closing_pr=0.0;	
	char l_listed_ind[2];
	int l_count=0;
	char l_prc_dt[APL_DATE_LEN]=APL_NULL_STRING;
          short i_listed_ind;
          short i_closing_pr;
          short i_price_date;
          short i_access_stamp;
          short i_maker;
          short i_maker_dt;
          short i_checker;
          short i_checker_dt;
	/*********************************************************/

	EXEC SQL VAR h_status IS STRING;
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif
   
 	l_mt_instrument_struct_h =(MT_INSTRUMENT_STRUCT_H *)calloc(1,sizeof(MT_INSTRUMENT_STRUCT_H));
	APL_MALLOC_FAIL(l_mt_instrument_struct_h)

 	l_mt_instrument_struct_i =(MT_INSTRUMENT_STRUCT_I *)calloc(1,sizeof(MT_INSTRUMENT_STRUCT_I));
 	APL_MALLOC_FAIL(l_mt_instrument_struct_i)
  
	EXEC SQL BEGIN DECLARE SECTION; 
 	EXEC SQL VAR l_mt_instrument_struct_h->h_checker IS STRING;
 	EXEC SQL VAR l_mt_instrument_struct_h->h_checker_dt IS STRING;
 	EXEC SQL VAR l_mt_instrument_struct_h->h_access_stamp IS STRING;
 	EXEC SQL VAR l_mt_instrument_struct_h->h_status IS STRING;
	EXEC SQL END DECLARE SECTION; 

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
	{
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Mod_InstrOth \n",NULL,p_intl_env_data_struct_h);

		memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
		sprintf(chr_l_buf,"Instrument h_code is |%s| \n",p_instr_code);
		CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
		
		memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
		sprintf(chr_l_buf,"Mode is |%s| \n",p_intl_env_data_struct_h->h_mode);
		CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
	}

	if(CO_RtvSysDtTime(chr_h_sys_access_stamp, l_debug_info_ptr) != APL_SUCCESS)
		APL_GOBACK_FAIL
	else
		strcpy(l_mt_instrument_struct_h->h_access_stamp,chr_h_sys_access_stamp);

	if (strcmp(p_intl_env_data_struct_h->h_mode, APL_FUNC_DELETE) == 0)
		strcpy((char *)h_status, STATUS_DEL_UAUTH);
	else if (strcmp(p_intl_env_data_struct_h->h_mode, APL_FUNC_FREEZE) == 0)
		strcpy((char *)h_status, STATUS_FROZ_UAUTH);
	else
		int_h_flg = 1;

	if (int_h_flg == 0)
	{
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
			APL_GOBACK_FAIL

		EXEC SQL UPDATE MT_INSTRUMENT
		SET maker 			= :p_intl_env_data_struct_h->usr,
 		maker_dt 			= :chr_h_sys_access_stamp,
		checker 				= NULL,
		checker_dt 			= NULL,
		STATUS 				= :h_status,
		access_stamp 		= :chr_h_sys_access_stamp
		WHERE ROWID 		= :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

		APL_GOBACK_SUCCESS
	}

	if (strcmp(p_intl_env_data_struct_h->h_mode, APL_FUNC_RESET) == 0)
	{
		strcpy((char *)h_status, STATUS_AUTH);

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
			APL_GOBACK_FAIL

		EXEC SQL UPDATE MT_INSTRUMENT
		SET 
		checker 			= :p_intl_env_data_struct_h->usr,
	 	checker_dt 		= :chr_h_sys_access_stamp,
		STATUS 			= :h_status,
		access_stamp 	= :chr_h_sys_access_stamp
		WHERE ROWID 		= :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

		APL_GOBACK_SUCCESS
	}

	if (strcmp(p_intl_env_data_struct_h->h_mode, APL_FUNC_UNFREEZE) == 0)
	{
		strcpy((char *)h_status, STATUS_UAUTH);

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
			APL_GOBACK_FAIL
		
		EXEC SQL UPDATE MT_INSTRUMENT
		SET 
		maker 			= :p_intl_env_data_struct_h->usr,
 	 	maker_dt 		= :chr_h_sys_access_stamp,
		checker 			= NULL,
		checker_dt 		= NULL,
		STATUS 			= :h_status,
		ALLOW_RF 		= :p_deal_ord_struct_h->h_allow_rf,
		ALLOW_DF 		= :p_deal_ord_struct_h->h_allow_df,
		ALLOW_RVP 		= :p_deal_ord_struct_h->h_allow_rvp,
		ALLOW_DVP 		= :p_deal_ord_struct_h->h_allow_dvp,
		ORD_TYPE 		= :p_deal_ord_struct_h->h_order_class,
 		access_stamp 	= :chr_h_sys_access_stamp
		WHERE ROWID 	= :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

		APL_GOBACK_SUCCESS
	}

	if (strcmp(p_intl_env_data_struct_h->h_mode, APL_FUNC_AUTHORISE) == 0)
	{
		EXEC SQL SELECT STATUS
		INTO :h_status
		FROM MT_INSTRUMENT
		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
			
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
			APL_GOBACK_FAIL

		if (strcmp(h_status, STATUS_DEL_UAUTH) == 0)
		{
         memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
         sprintf(chr_l_buf,"rowid of Instrument which will be deleted is : |%s| \n",p_row_id_instr);
         CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,NULL);
         CO_ProcMonitor(APL_OUT_FILE,"selecting records into structure\n",NULL,NULL);
        
         EXEC SQL 	SELECT * INTO :l_mt_instrument_struct_h:l_mt_instrument_struct_i 
	   	  				FROM MT_INSTRUMENT
                  	WHERE ROWID = :p_row_id_instr;

         memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
         sprintf(chr_l_buf,"Selected into Struct sqlca.sqlcode = |%d| \n",sqlca.sqlcode);
         CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,NULL);

         strcpy(l_mt_instrument_struct_h->h_checker,p_intl_env_data_struct_h->usr);
         strcpy(l_mt_instrument_struct_h->h_checker_dt,chr_h_sys_access_stamp);
         strcpy(l_mt_instrument_struct_h->h_access_stamp,chr_h_sys_access_stamp);
         strcpy(l_mt_instrument_struct_h->h_status,STATUS_DEL_AUTH);

         /**if (APL_FAILURE == EI_Mod_MQOnDelAccInstr(NULL,l_mt_instrument_struct_h,"S",l_debug_info_ptr))
            APL_GOBACK_FAIL **/

			EXEC SQL DELETE FROM MT_INSTRUMENT
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
			
			APL_GOBACK_SUCCESS
		}
		else if (strcmp(h_status, STATUS_FROZ_UAUTH) == 0)
		{
			strcpy((char *)h_status, STATUS_FROZ_AUTH);

			EXEC SQL UPDATE MT_INSTRUMENT
			SET 
			checker 			= :p_intl_env_data_struct_h->usr,
		 	checker_dt 		= :chr_h_sys_access_stamp,
			STATUS 			= :h_status,
			ALLOW_RF 		= 'N',
			ALLOW_RVP 		= 'N',
			ALLOW_DF 		= 'N',
			ALLOW_DVP 		= 'N',
			ORD_TYPE 		= 'N',
 			access_stamp 	= :chr_h_sys_access_stamp
			WHERE ROWID = :p_row_id_instr;
			
			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

			APL_GOBACK_SUCCESS
		}
		else
		{
			EXEC SQL UPDATE MT_INSTRUMENT
			SET 
			checker 			= :p_intl_env_data_struct_h->usr,
	 		checker_dt 		= :chr_h_sys_access_stamp,
			/*STATUS 			= :h_status,*/
			access_stamp 	= :chr_h_sys_access_stamp
			
			WHERE ROWID 		= :p_row_id_instr;

			
 		/**************** For Unlisted Instrument One Entry in MT_DLYMKTPRC By: vinay kalaskar *******/

		EXEC SQL SELECT LISTED_IND,NOMINAL_VALUE,DATEOF_INPUT,ACCESS_STAMP,
		  		MAKER,MAKER_DT,CHECKER,CHECKER_DT
			   INTO :l_listed_ind:i_listed_ind,:l_closing_pr:i_closing_pr,:l_price_date:i_price_date,
		  			 :l_access_stamp:i_access_stamp,:l_maker:i_maker,:l_maker_dt:i_maker_dt,
		  			 :l_checker:i_checker,:l_checker_dt:i_checker_dt 
			   FROM MT_INSTRUMENT WHERE INSTR_CODE=:p_instr_code;
	
			   IS_ANY_ORA_ERROR

				Alert("l_listed_ind:|%s|",l_listed_ind);
							
			//	if(!strcmp(l_listed_ind,"N"))
			//	{
					Alert("p_instr_code:|%s|l_price_date:|%s|",p_instr_code,l_price_date);
	// Changes:ISolveID-246:24-04-2007:AmitB:PriceDate to be modified before query					
				printf("\n Before changing Price date is :|%s|",l_price_date);
				strncpy(l_prc_dt,l_price_date,10);
				strcpy(l_price_date,l_prc_dt);
				strcat(l_price_date," 12:00:00");
				printf("\n After  changing Price date is :|%s|",l_price_date);

					EXEC SQL SELECT COUNT(*) INTO :l_count
								FROM MT_DLYMKTPRC 
								WHERE INSTR_CODE=:p_instr_code
								AND PRICE_DATE=:l_price_date;
					
					IS_ANY_ORA_ERROR
						
					strcpy(l_modifymode,"H");
					strcpy(l_mkrtpr_stat,"AA");

					Alert("l_count:|%d|",l_count);
					if(l_count == 0)
					{	
						Alert("p_instr_code:|%s|l_closing_pr:|%lf|",p_instr_code,l_closing_pr);
						EXEC SQL INSERT INTO MT_DLYMKTPRC VALUES (:l_price_date,:p_instr_code,:l_closing_pr,:l_modifymode,
																			:l_access_stamp,:l_maker,:l_maker_dt,:l_mkrtpr_stat,
																			:l_checker,:l_checker_dt);
					
						IS_ANY_ORA_ERROR
					}
					else
					{
						Alert("Closing Price :|%lf|",l_closing_pr);
						EXEC SQL UPDATE MT_DLYMKTPRC SET CLOSING_PR=:l_closing_pr
									WHERE INSTR_CODE=:p_instr_code
									AND PRICE_DATE=:l_price_date;
						
						IS_ANY_ORA_ERROR
					}
			//	}
 
		/*********************************************************************************************/
		
		}
	}

	APL_IF_DEBUG
	{
          printf("Key Code = |%s|\n",p_key_codes[0]);
          printf("Key Value = |%s|\n",p_key_values[0]);
          printf("Child Table Name = |%s|\n",g_chld_table_names[0]);
          printf("Child Table Name = |%s|\n",g_chld_table_names[1]);
          printf("Child Table Name = |%s|\n",g_chld_table_names[2]);
          printf("Child Table Name = |%s|\n",g_chld_table_names[3]);
          printf("Child Table Name = |%s|\n",g_chld_table_names[4]);
          printf("Child Table Name = |%s|\n",g_chld_table_names[5]);
          printf("Child Table Name = |%s|\n",g_chld_table_names[6]);
	}

	strcpy(p_status,APL_NULL_STRING);

	if (strcmp(h_status, STATUS_DEL_UAUTH) != 0)
	{
		int_retval = CR_Mod_UpdMastStatus(	p_key_codes,
														p_key_values,
														g_mst_table_name,
														g_chld_table_names,
														APL_MASTER_IND,
														p_status,
														chr_h_sys_access_stamp,
														p_intl_env_data_struct_h,	
														l_debug_info_ptr);

		APL_IF_DEBUG
		{	
			printf("Returned Status Value = |%s|\n",p_status);
		}	
	}
/*ISKB-430 - ASP,Shailesh*/
	if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_INPUT))
	{
		if ( APL_FAILURE == IV_Upd_DataGrp(p_key_values[0], p_status, p_intl_env_data_struct_h, l_debug_info_ptr))
		{
			CO_InsertErr(   l_debug_info_ptr,
                   "Error in Updating IV_DATA_GRP",
							p_key_values[0],
							APL_NULL_STRING,
							APL_NULL_STRING,
							__LINE__,
							__FILE__);

			APL_GOBACK_FAIL;
	
		}
	}

	APL_GOBACK_SUCCESS

	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrOth SUCCESS\n",NULL,p_intl_env_data_struct_h);

		return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrOth FAILURE\n",NULL,p_intl_env_data_struct_h);
		
		return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrOth                                                               *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Structure, 			                           *
 *                         Env String and debug pointer.Validates Instr Details in other Modes.          *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_struct_h            MT_INSTRUMENT_STRUCT_H           I      Instrument Details        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/ 
int CR_Chk_InstrOth(		MT_INSTRUMENT_STRUCT_H *p_mt_instrument_struct_h,
								INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca 	sqlca;
	int			 	int_retval;
	char			 	chr_h_field_val[40] = APL_NULL_STRING;
	char			 	h_reg_br_ind[3] = APL_NULL_STRING;
	short				i_reg_br_ind;
	char			 	h_instr_type[4] = APL_NULL_STRING;
	short				i_instr_type;
	char			 	h_issue_date[APL_DATE_LEN] = APL_NULL_STRING;
	short			 	i_issue_date;
	double		 	h_nominal_value;
	short		 		i_nominal_value;
	char				h_int_acctyp[2] = APL_NULL_STRING;
	short				i_int_acctyp;
	char				h_prod_class[3] = APL_NULL_STRING;
	short				i_prod_class;
	char				h_currency_cd[4] = APL_NULL_STRING;
	short				i_currency_cd;
	char				h_classcd[5] = APL_NULL_STRING;
	short				i_classcd;
	char				chr_h_mainfuncarea[APL_MAINFUNCAREA_LEN] = APL_NULL_STRING;
	char				chr_h_condid[APL_CONDID_LEN] = APL_NULL_STRING;
	short				h_CondExists;
	char				chr_itype,chr_iexist,chr_iauthorised,chr_ideleted,chr_ifrozen;
	char				chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;
	int				l_count = 0;/* Chirag 12-12-2006 */ 
	EXEC SQL BEGIN DECLARE SECTION;
	EXEC SQL VAR h_reg_br_ind IS STRING;
	EXEC SQL VAR h_instr_type IS STRING;
	EXEC SQL VAR h_issue_date IS STRING;
	EXEC SQL VAR h_int_acctyp IS STRING;
	EXEC SQL VAR h_prod_class IS STRING;
	EXEC SQL VAR h_currency_cd IS STRING;
	EXEC SQL VAR h_classcd IS STRING;
	EXEC SQL END DECLARE SECTION;
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
	{
		CO_ProcMonitor(APL_OUT_FILE, "Entered Process CR_Chk_InstrOth \n",NULL,p_intl_env_data_struct_h);

		memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
		sprintf(chr_l_buf,"Instrument  h_code is |%s| \n",p_mt_instrument_struct_h->h_instr_code);
		CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
		
		memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
		sprintf(chr_l_buf,"Mode is |%s| \n",p_intl_env_data_struct_h->h_mode);
		CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
	}

	chr_itype = 'M';
	chr_iexist = 'Y';
	
	printf("h_currency_cd is %s\n",p_mt_instrument_struct_h->h_currency_cd);
	printf("h_location_cd is %s\n",p_mt_instrument_struct_h->h_location_cd);


	/***int_retval = CO_Chk_CcyValid(		p_mt_instrument_struct_h->h_currency_cd,
												chr_itype,
												chr_iexist,
												l_debug_info_ptr);

	if (int_retval != APL_SUCCESS)
		APL_GOBACK_FAIL***/

	if(strlen(p_mt_instrument_struct_h->h_sec_dl_code) != 0)
	{	
		printf("HERE1\n");
		fflush(stdout);
		int_retval = CO_Chk_CodeValid(	"INDUSTRY",
													p_mt_instrument_struct_h->h_sec_dl_code,
													APL_DEF_COUNTRY_CODE,
													l_debug_info_ptr);

		if (int_retval != APL_SUCCESS)
				APL_GOBACK_FAIL
	}

	if (strcmp(l_mt_core_sys_params_struct_h.loc_proc_ind,"Y") == 0)
	{
		chr_iexist = 'Y';
		chr_iauthorised = 'Y';
		chr_ideleted = 'N';
		printf("HERE1\n");
		fflush(stdout);
/**** Location non mandatory Hence commenting - MK**
		int_retval = MT_Chk_Loc(	p_mt_instrument_struct_h->h_location_cd,
											chr_iexist,
											chr_iauthorised,
											chr_ideleted,
											l_debug_info_ptr);

		if (int_retval != APL_SUCCESS)
			APL_GOBACK_FAIL
		printf("HERE1\n");
		fflush(stdout);
****/
	}

	if (strlen(p_mt_instrument_struct_h->h_instr_parent) != 0)
	{
		chr_iexist = 'Y';
		chr_iauthorised = 'Y';
		chr_ideleted = 'N';
		chr_ifrozen = 'N';

		/*Smita - HDFCMT_003 - Instrument Master */
		APL_IF_DEBUG
		{
			printf("Calling Function CO_Chk_InstrValid ....\n");
			printf("Parent Instrument = |%s|\n",p_mt_instrument_struct_h->h_instr_parent);
			printf("Exists Flag = %c\n",chr_iexist);
			printf("Authorised Flag = %c\n",chr_iauthorised);
			printf("Deleted Flag = %c\n",chr_ideleted);
			printf("Frozen flag = %c\n",chr_ifrozen);
		}	
		/*Smita - HDFCMT_003 - Instrument Master */
		
		int_retval = CO_Chk_InstrValid(	p_mt_instrument_struct_h->h_instr_parent,
													chr_iexist,
													chr_iauthorised,
													chr_ideleted,
													chr_ifrozen,
													NULL,
													NULL,
													l_debug_info_ptr);

		if (int_retval != APL_SUCCESS)
			APL_GOBACK_FAIL
	}

	if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
	{
		EXEC SQL 
		SELECT REG_BR_IND,INSTR_TYPE,ISSUE_DATE,NOMINAL_VALUE,INT_ACCTYP,PROD_CLASS,CURRENCY_CD,CLASSCD
		INTO 
		:h_reg_br_ind:i_reg_br_ind,:h_instr_type:i_instr_type,:h_issue_date:i_issue_date,
		:h_nominal_value:i_nominal_value,:h_int_acctyp:i_int_acctyp,:h_prod_class:i_prod_class,
		:h_currency_cd:i_currency_cd,:h_classcd:i_classcd
		FROM MT_INSTRUMENT 
		WHERE INSTR_CODE= :p_mt_instrument_struct_h->h_instr_code;
	
		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

		if ((strcmp(p_mt_instrument_struct_h->h_reg_br_ind, h_reg_br_ind) != 0) && 
				l_mt_core_sys_params_struct_h.proc_reg_ind[0] == 'Y' )
		{
			if ((strcmp(p_mt_instrument_struct_h->h_reg_br_ind, "BR") == 0) &&
				 (strcmp(h_reg_br_ind, "RG") == 0)) 
			{
				int_retval = CR_Chk_InstrTrd(	p_mt_instrument_struct_h->h_instr_code,
														l_debug_info_ptr);

				if (int_retval == APL_RECS_EXIST)
 					CO_InsertErr(	l_debug_info_ptr,
											ERR_TRDEXIST_CANTCHG_BR_INSTR,
											APL_NULL_STRING,
											APL_NULL_STRING,
											APL_NULL_STRING,
											__LINE__,
											__FILE__);
				else if (int_retval == APL_FAILURE)
					APL_GOBACK_FAIL
	
				if (strcmp(l_mt_core_sys_params_struct_h.proc_reg_ind, "Y") == 0)
				{
					int_retval = CR_Chk_InstrPosPosnstat(	p_mt_instrument_struct_h->h_instr_code,
																		l_debug_info_ptr);
					if (int_retval == APL_RECS_EXIST)
 						CO_InsertErr(	l_debug_info_ptr,
												ERR_POSNEXIST_CANTCHG_BR_INSTR,
												APL_NULL_STRING,
												APL_NULL_STRING,
												APL_NULL_STRING,
												__LINE__,
												__FILE__);
					else if (int_retval == APL_FAILURE)
						APL_GOBACK_FAIL
				}
			}
		}
			
		strcpy(chr_h_mainfuncarea, "INSTR_MAINT");
		strcpy(chr_h_condid, "CHK_CLSCODE_FOR_TR");

		int_retval = CO_Chk_CntryEnabled(chr_h_mainfuncarea,chr_h_condid,&h_CondExists,l_debug_info_ptr);
		if (int_retval != APL_SUCCESS)
			APL_GOBACK_FAIL

		if (h_CondExists > 0)
		{
		  if ((strcmp(h_classcd, "HS") == 0) && (strcmp(h_classcd,p_mt_instrument_struct_h->h_classcd) != 0))
		  {
				if (strcmp(l_mt_core_sys_params_struct_h.ord_proc_ind, "Y") == 0)
				{
					int_retval = CR_Chk_InstrOrd(p_mt_instrument_struct_h->h_instr_code,l_debug_info_ptr);
		
					if (int_retval == APL_RECS_EXIST)
						CO_InsertErr(	l_debug_info_ptr,
											ERR_ORDEXIST_CANT_CLSCODE,
											APL_NULL_STRING,
											APL_NULL_STRING,
											APL_NULL_STRING,
											__LINE__,
											__FILE__);
					else if (int_retval == APL_FAILURE)
						APL_GOBACK_FAIL
				}
		 
			  if (strcmp(g_mt_commonsys_params_struct_h.ca_module_ind, "Y") == 0)
		  	  {	
					int_retval = CR_Chk_InstrEvent(p_mt_instrument_struct_h->h_instr_code,l_debug_info_ptr);
					
					if (int_retval == APL_RECS_EXIST)
						CO_InsertErr(	l_debug_info_ptr,
											ERR_EVNTEXIST_CANTCHG_CLSCODE,
											APL_NULL_STRING,
											APL_NULL_STRING,
											APL_NULL_STRING,
											__LINE__,
											__FILE__);

					else if (int_retval == APL_FAILURE)
						APL_GOBACK_FAIL
		  		}
			}
		}

		strcpy(chr_h_mainfuncarea, "INSTR_MAINT");
		strcpy(chr_h_condid, "CHK_CLSCODE_FOR_RU");

		int_retval = CO_Chk_CntryEnabled(chr_h_mainfuncarea,chr_h_condid,&h_CondExists,l_debug_info_ptr);
		if (int_retval != APL_SUCCESS)
			APL_GOBACK_FAIL

		if (h_CondExists > 0)
		{
		  if ((strcmp(h_classcd, "OTH") == 0) && (strcmp(p_mt_instrument_struct_h->h_classcd,"MIN") == 0))
		  {
				if (strcmp(l_mt_core_sys_params_struct_h.ord_proc_ind, "Y") == 0)
				{
					int_retval = CR_Chk_InstrOrd(p_mt_instrument_struct_h->h_instr_code,l_debug_info_ptr);
		
					if (int_retval == APL_RECS_EXIST)
						CO_InsertErr(	l_debug_info_ptr,
											ERR_ORDEXIST_CANT_CLSCODE,
											APL_NULL_STRING,
											APL_NULL_STRING,
											APL_NULL_STRING,
											__LINE__,
											__FILE__);
					else if (int_retval == APL_FAILURE)
						APL_GOBACK_FAIL
				}
		
				int_retval = CR_Chk_InstrPymtTrd(	p_mt_instrument_struct_h->h_instr_code,
																l_debug_info_ptr);
				if (int_retval == APL_RECS_EXIST)
					CO_InsertErr(	l_debug_info_ptr,
										ERR_PYMNTTRDEXIST_CANT_CLSCODE,
										APL_NULL_STRING,
										APL_NULL_STRING,
										APL_NULL_STRING,
										__LINE__,
										__FILE__);
				else if (int_retval == APL_FAILURE)
					APL_GOBACK_FAIL
			}
		}

		if (strcmp(g_mt_commonsys_params_struct_h.ca_module_ind, "Y") == 0)
		{
			if (strcmp(p_mt_instrument_struct_h->h_instr_type, h_instr_type) != 0)
			{
				int_retval = CR_Chk_InstrEvent(p_mt_instrument_struct_h->h_instr_code,l_debug_info_ptr);

				if (int_retval == APL_RECS_EXIST)
 					CO_InsertErr(	l_debug_info_ptr,
											ERR_EVNTEXIST_CANTCHG_TYPEOFINSTR,
											APL_NULL_STRING,
											APL_NULL_STRING,
											APL_NULL_STRING,
											__LINE__,
											__FILE__);
				else if (int_retval == APL_FAILURE)
					APL_GOBACK_FAIL
			}

			if (strcmp(p_mt_instrument_struct_h->h_issue_date, h_issue_date) != 0)
			{
				int_retval = CR_Chk_InstrEvent(p_mt_instrument_struct_h->h_instr_code,l_debug_info_ptr);

				if (int_retval == APL_RECS_EXIST)
					CO_InsertErr(	l_debug_info_ptr,
										ERR_EVNTEXIST_CANTCHG_ISSUEDT,
										APL_NULL_STRING,
										APL_NULL_STRING,
										APL_NULL_STRING,
										__LINE__,
										__FILE__);
				else if (int_retval == APL_FAILURE)
					APL_GOBACK_FAIL
			}

			if (p_mt_instrument_struct_h->h_nominal_value != h_nominal_value)
			{
				l_count = 0;
		
			/* KOTAK Chirag 121206 This will allow Modification of Nominal Value even if RD event status is RP or PP */	
			
				EXEC SQL SELECT COUNT(*) INTO :l_count FROM CAEVENT
				WHERE INSTR_CODE = : p_mt_instrument_struct_h->h_instr_code 
				AND CA_EVENT = 'RD' AND OP_EVT_CLASS NOT IN ('PO')
				AND STATUS IN ('RP','PP');

				IS_ANY_ORA_ERROR

				if(l_count == 0)
				{	
						Alert("No RD Event Found with status RP or PP\n");					 
						 int_retval = CR_Chk_InstrEvent(p_mt_instrument_struct_h->h_instr_code,l_debug_info_ptr);

						  if (int_retval == APL_RECS_EXIST)
									 CO_InsertErr(	l_debug_info_ptr,
														  ERR_EVNTEXIST_CANTCHG_NOMVAL,
														  APL_NULL_STRING,
														  APL_NULL_STRING,
														  APL_NULL_STRING,
														  __LINE__,
														  __FILE__);
						  else if (int_retval == APL_FAILURE)
									 APL_GOBACK_FAIL
				}
				else
				{
					Alert("RD Event Found With Status RP or PP\n");	
					APL_GOBACK_SUCCESS
				}
			}
			
			if (strcmp(p_mt_instrument_struct_h->h_int_acctyp, h_int_acctyp) != 0)
			{
				int_retval = CR_Chk_InstrEvent(p_mt_instrument_struct_h->h_instr_code,l_debug_info_ptr);

				if (int_retval == APL_RECS_EXIST)
					CO_InsertErr(	l_debug_info_ptr,
										ERR_EVNTEXIST_CANTCHG_INTCALCTYPE,
										APL_NULL_STRING,
										APL_NULL_STRING,
										APL_NULL_STRING,
										__LINE__,
										__FILE__);
				else if (int_retval == APL_FAILURE)
					APL_GOBACK_FAIL
			}
		}
	
		if (strcmp(g_mt_commonsys_params_struct_h.bill_module_ind, "Y") == 0)
		{
			if (strcmp(p_mt_instrument_struct_h->h_prod_class, h_prod_class) != 0)
			{
				int_retval = IV_Rtv_Bill_FrmGendt_DlvDt(l_debug_info_ptr);

				if (int_retval == APL_SUCCESS)
					CO_InsertErr(	l_debug_info_ptr,
										ERR_BTWNGENDELV_CANTCHG_PRODTYPE,
										APL_NULL_STRING,
										APL_NULL_STRING,
										APL_NULL_STRING,
										__LINE__,
										__FILE__);
			}
	
			if (strcmp(p_mt_instrument_struct_h->h_currency_cd, h_currency_cd) != 0)
			{
				int_retval = IV_Rtv_Bill_FrmGendt_DlvDt(l_debug_info_ptr);

				if (int_retval == APL_SUCCESS)
 					CO_InsertErr(	l_debug_info_ptr,
											ERR_BTWNGENDELV_CANTCHG_INSTRCCY,
											APL_NULL_STRING,
											APL_NULL_STRING,
											APL_NULL_STRING,
											__LINE__,
											__FILE__);
			}
		}
	}

	if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
		APL_GOBACK_FAIL

	APL_GOBACK_SUCCESS

	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrOth SUCCESS\n",NULL,p_intl_env_data_struct_h);
		return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrOth FAILURE\n",NULL,p_intl_env_data_struct_h);
		return(APL_FAILURE);

	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_ChldInstr                                                              *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code, and debug pointer.                     *
 *                         Checks whether Child Instrument exists for the given Instrument.              *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code                      	char *                           I      Instrument Code           *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_ChldInstr(		char *p_instr_code,
									DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca	sqlca;
	int				int_h_num_rows = 0;
	char				chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
	{
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_ChldInstr \n",NULL,NULL);
		memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
		sprintf(chr_l_buf,"Instrument h_code is |%s| \n",p_instr_code);
		CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,NULL);
	}

	EXEC SQL SELECT NVL(COUNT(*),0) INTO :int_h_num_rows
	FROM MT_INSTRUMENT
	WHERE INSTR_PARENT = :p_instr_code
	AND INSTR_CODE != :p_instr_code;

	IS_ANY_ORA_ERROR

	if (int_h_num_rows > 0)
	{
		APL_GOBACK_SUCCESS
	}
	else
	{
		APL_GOBACK_FAIL
	}

	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_ChldInstr SUCCESS\n",NULL,NULL);
		return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_ChldInstr FAILURE\n",NULL,NULL);
		return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrMkrChkr                                                           *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code, User ID and debug pointer.             *
 *                         Checks whether Maker = Checker for the given Instrument.   			            *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code                        char *                           I      Instrument Code           *
 *                                                                                                       *
 * p_user										char *									I		 User ID							*
 *																																		   *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/ 
int CR_Chk_InstrMkrChkr(	char *p_instr_code,
									char *p_user,
									DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	VARCHAR					h_maker[APL_USERID_LEN];
	struct sqlca			sqlca;
	char						chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
	{
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrMkrChkr \n",NULL,NULL);
		memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
		sprintf(chr_l_buf,"Instrument h_code is |%s| \n",p_instr_code);
		CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,NULL);
		
		memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
		sprintf(chr_l_buf,"User is |%s| \n",p_user);
		CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,NULL);
	}

	EXEC SQL SELECT MAKER 
	INTO :h_maker
	FROM MT_INSTRUMENT
	WHERE INSTR_CODE = :p_instr_code;

	IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

	h_maker.arr[h_maker.len] = APL_NULL_CHAR;

	if (strcmp(p_user,h_maker.arr) == 0)
	{
		CO_InsertErr(	l_debug_info_ptr,
							ERR_MAKER_CHECKER_SAME,
							APL_NULL_STRING,
							APL_NULL_STRING,
							APL_NULL_STRING,
							__LINE__,
							__FILE__);

		APL_GOBACK_FAIL
	}

	APL_GOBACK_SUCCESS

	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_AccAuth SUCCESS\n",NULL,NULL);
			return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_AccAuth FAILURE\n",NULL,NULL);
			return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrEvent                                                             *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code, and debug pointer.                     *
 *                         Checks whether Instrument exists in Events.              							*
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code                        char *                           I      Instrument Code           *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrEvent(	char *p_instr_code,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	EXEC SQL BEGIN DECLARE SECTION;

	struct sqlca sqlca;
	int			 int_l_num_rows = 0;
	
	EXEC SQL END DECLARE SECTION;
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrEvent \n",NULL,NULL);
   
	EXEC SQL SELECT NVL(COUNT(*),0) INTO :int_l_num_rows
	FROM CAEVENT
	WHERE INSTR_CODE= :p_instr_code
	AND status NOT IN ('SN','CP','RV','UU','FI','FE','FS','WI');

	IS_ANY_ORA_ERROR

	if (int_l_num_rows == 0)
		APL_GOBACK_SUCCESS
	else
		APL_GOBACK_FAIL

	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrEvent SUCCESS\n",NULL,NULL);
		return(APL_SUCCESS);
	}
	
	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrEvent FAILURE\n",NULL,NULL);
		if (sqlca.sqlcode == 0)
			return(APL_RECS_EXIST);
		else
			return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrTrd                                                               *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code, and debug pointer.                     *
 *                         Checks whether Instrument exists n Trades.							               *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code                        char *                           I      Instrument Code           *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrTrd(		char *p_instr_code,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	EXEC SQL BEGIN DECLARE SECTION;

	struct sqlca sqlca;
	int			 int_l_num_rows = 0;
	
	EXEC SQL END DECLARE SECTION;
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrTrd \n",NULL,NULL);

	EXEC SQL SELECT NVL(COUNT(*),0) INTO :int_l_num_rows
	FROM DL_DEAL
	WHERE INSTR_CODE = :p_instr_code;

	IS_ANY_ORA_ERROR

	if (int_l_num_rows == 0)
		APL_GOBACK_SUCCESS
	else
		APL_GOBACK_FAIL

	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrTrd SUCCESS\n",NULL,NULL);
		return(APL_SUCCESS);
	}
	
	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrTrd FAILURE\n",NULL,NULL);
		if (sqlca.sqlcode == 0)
			return(APL_RECS_EXIST);
		else
			return(APL_FAILURE);
	}
}	

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrPos                                                               *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code, and debug pointer.                     *
 *                         Checks whether Instrument has Open Positions.						               *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code                        char *                           I      Instrument Code           *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrPos(		char *p_instr_code,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	EXEC SQL BEGIN DECLARE SECTION;

	struct sqlca sqlca;
	int			 int_l_num_rows = 0;
	
	EXEC SQL END DECLARE SECTION;
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrPos \n",NULL,NULL);

	EXEC SQL SELECT NVL(COUNT(*),0) INTO :int_l_num_rows
	FROM DL_SAFEK
	WHERE INSTR_CODE = :p_instr_code;

	IS_ANY_ORA_ERROR

	if (int_l_num_rows == 0)
		APL_GOBACK_SUCCESS
	else
		APL_GOBACK_FAIL

	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrPos SUCCESS\n",NULL,NULL);
		return(APL_SUCCESS);
	}
	
	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrPos FAILURE\n",NULL,NULL);
		if (sqlca.sqlcode == 0)
			return(APL_RECS_EXIST);
		else
			return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrPosPosnstat                                                       *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code, and debug pointer.                     *
 *                         Checks whether Instrument has safekeeping positions. 					            *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code                        char *                           I      Instrument Code           *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrPosPosnstat(		char *p_instr_code,
											DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	EXEC SQL BEGIN DECLARE SECTION;

	struct sqlca sqlca;
	int			 int_l_num_rows = 0;
	
	EXEC SQL END DECLARE SECTION;
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrPosPosnstat \n",NULL,NULL);

	EXEC SQL SELECT NVL(COUNT(*),0) INTO :int_l_num_rows
	FROM DL_SAFEK
	WHERE INSTR_CODE = :p_instr_code
	AND STATUS IN ('001','002','003');

	IS_ANY_ORA_ERROR

	if (int_l_num_rows == 0)
		APL_GOBACK_SUCCESS
	else
		APL_GOBACK_FAIL

	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrPosPosnstat SUCCESS\n",NULL,NULL);

		return(APL_SUCCESS);
	}
	
	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrPosPosnstat FAILURE\n",NULL,NULL);

		if (sqlca.sqlcode == 0)
			return(APL_RECS_EXIST);
		else
			return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrLRRpt                                                             *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code, and debug pointer.                     *
 *                         Checks whether Instrument needs Local Reporting.					               *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code                        char *                           I      Instrument Code           *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrLRRpt(		char *p_instr_code,
									DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	EXEC SQL BEGIN DECLARE SECTION;

	struct sqlca sqlca;
	int			 int_l_num_rows = 0;
	
	EXEC SQL END DECLARE SECTION;
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrLRRpt \n",NULL,NULL);

	EXEC SQL SELECT NVL(COUNT(*),0) INTO :int_l_num_rows
	FROM DL_LOCALREPSAFEK
	WHERE INSTR_CODE = :p_instr_code;

	IS_ANY_ORA_ERROR

	if (int_l_num_rows == 0)
		APL_GOBACK_SUCCESS
	else
		APL_GOBACK_FAIL

	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrLRRpt SUCCESS\n",NULL,NULL);
		return(APL_SUCCESS);
	}
	
	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrLRRpt FAILURE\n",NULL,NULL);
		if (sqlca.sqlcode == 0)
			return(APL_RECS_EXIST);
		else
			return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrPymtTrd                                                           *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code, and debug pointer.                     *
 *                         Checks whether Instrument exists in Trades.							               *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code                        char *                           I      Instrument Code           *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrPymtTrd(		char *p_instr_code,
										DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	EXEC SQL BEGIN DECLARE SECTION;

	struct sqlca sqlca;
	int			 int_l_num_rows = 0;
	
	EXEC SQL END DECLARE SECTION;
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrPymtTrd \n",NULL,NULL);

	EXEC SQL SELECT NVL(COUNT(*),0) INTO :int_l_num_rows
	FROM DL_DEAL
	WHERE INSTR_CODE = :p_instr_code
	AND deal_cd IN ('3','4','5','6','7','8');

	IS_ANY_ORA_ERROR

	if (int_l_num_rows == 0)
		APL_GOBACK_SUCCESS
	else
		APL_GOBACK_FAIL

	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrPymtTrd SUCCESS\n",NULL,NULL);
		return(APL_SUCCESS);
	}
	
	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrPymtTrd FAILURE\n",NULL,NULL);

		if (sqlca.sqlcode == 0)
			return(APL_RECS_EXIST);
		else
			return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrOrd                                                               *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code, and debug pointer.                     *
 *                         Checks whether Instrument exists in Orders.							               *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code                        char *                           I      Instrument Code           *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrOrd(		char *p_instr_code,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	EXEC SQL BEGIN DECLARE SECTION;

	struct sqlca sqlca;
	int			 int_l_num_rows = 0;
	
	EXEC SQL END DECLARE SECTION;
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrOrd \n",NULL,NULL);
	EXEC SQL SELECT NVL(COUNT(*),0) INTO :int_l_num_rows
	FROM OR_ORDERDETAILS
	WHERE INSTR_CODE = :p_instr_code;

	IS_ANY_ORA_ERROR

	if (int_l_num_rows == 0)
		APL_GOBACK_SUCCESS
	else
		APL_GOBACK_FAIL

	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrOrd SUCCESS\n",NULL,NULL);

		return(APL_SUCCESS);
	}
	
	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrOrd FAILURE\n",NULL,NULL);
		if (sqlca.sqlcode == 0)
			return(APL_RECS_EXIST);
		else
			return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrISINUnique                                                        *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code, ISIN Code and debug pointer.           *
 *                         Checks whether Instrument ISIN already exists for another Instrument.         *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code                        char *                           I      Instrument Code           *
 *                                                                                                       *
 * chr_p_isin									char *									I		 Instrument ISIN				*
 *																																			*
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrISINUnique(		char *p_instr_code,
											char *chr_p_isin,
											DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	EXEC SQL BEGIN DECLARE SECTION;

	struct sqlca sqlca;
	int			 int_l_num_rows = 0;
	
	EXEC SQL END DECLARE SECTION;
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrISINUnique \n",NULL,NULL);

	EXEC SQL SELECT NVL(COUNT(*),0) INTO :int_l_num_rows
	FROM MT_INSTRUMENT
	WHERE INSTR_ISIN = :chr_p_isin
	AND	INSTR_CODE != :p_instr_code;

	IS_ANY_ORA_ERROR

	if (int_l_num_rows == 0)
		APL_GOBACK_SUCCESS
	else
		APL_GOBACK_FAIL

	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrISINUnique SUCCESS\n",NULL,NULL);
		return(APL_SUCCESS);
	}
	
	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrISINUnique FAILURE\n",NULL,NULL);

		if (sqlca.sqlcode == 0)
			return(APL_RECS_EXIST);
		else
			return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrCodeUnique                                                        *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code, Table Name,Env String & debug pointer. *
 *                         Checks whether Instrument Code is Unique in the table 				            *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code                        char *                           I      Instrument Code           *
 *                                                                                                       *
 * p_table_name								char *									I		 Table Name						*
 *																																			*
 *	p_intl_env_data_struct_h				INTL_ENV_DATA_STRUCT_H *			I		 Environment Structure		*
 *																																			*
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrCodeUnique(		char *p_instr_code,
											char *p_table_name,
											INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
											DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca			sqlca;
	char						chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;
	int			 			int_l_num_rows = 0;
	VARCHAR					sqlstmt[APL_SQLSTMT_LEN];
	VARCHAR					h_fld_value[APL_INSTRUMENTCODE_LEN];
	
	#ifdef APL_THREADS
		APL_SET_CONTEXT
		EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	sqlca.sqlcode = 0;

	APL_IF_DEBUG
	{
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrCodeUnique \n",NULL,NULL);
		memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
		sprintf(chr_l_buf,"Instrument h_code is |%s| \n",p_instr_code);
		CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,NULL);
		
		memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
		sprintf(chr_l_buf,"Table is |%s| \n",p_table_name);
		CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,NULL);
	}

	strcpy(h_fld_value.arr,p_instr_code);
	h_fld_value.len = strlen(p_instr_code);

	sprintf(sqlstmt.arr,"SELECT NVL(COUNT(*),0) FROM %s WHERE INSTR_CODE='%s'",p_table_name,p_instr_code);

	sqlstmt.len = strlen(sqlstmt.arr);
	sqlstmt.arr[sqlstmt.len] = '\0';
	sqlstmt.len++;

	printf("sqlstmt.arr is %s\n",sqlstmt.arr);
	fflush(stdout);

	EXEC SQL PREPARE s FROM :sqlstmt;
		printf("sqlca.sqlcode is %d\n",sqlca.sqlcode);
	IS_ANY_ORA_ERROR

	EXEC SQL DECLARE c CURSOR FOR s;
		printf("sqlca.sqlcode is %d\n",sqlca.sqlcode);
	IS_ANY_ORA_ERROR

	EXEC SQL OPEN c ;
		printf("sqlca.sqlcode is %d\n",sqlca.sqlcode);
	IS_ANY_ORA_ERROR
	
	EXEC SQL FETCH c INTO :int_l_num_rows;
		printf("sqlca.sqlcode is %d\n",sqlca.sqlcode);
	IS_ANY_ORA_ERROR

		printf("sqlca.sqlcode is %d\n",sqlca.sqlcode);
	fflush(stdout);

	if (int_l_num_rows == 0)
		APL_GOBACK_SUCCESS
	else
		APL_GOBACK_FAIL

	RETURN_SUCCESS :
	{
		EXEC SQL CLOSE c;
		IS_ANY_ORA_ERROR

		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrCodeUnique SUCCESS\n",NULL,NULL);
		return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
		EXEC SQL CLOSE c;
		IS_ANY_ORA_ERROR

		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrCodeUnique FAILURE\n",NULL,NULL);
		
		if (sqlca.sqlcode == 0)
			return(APL_RECS_EXIST);
		else
			return(APL_FAILURE);
	}
}

/* Smita - HDFCMT_003 - Pick the Currency Code from Common Sys Parameters - Function not required
int CR_GetCcyCode(	char *p_ccycode,
							DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	strcpy(p_ccycode,"INR");
	return (APL_SUCCESS);
}
*/

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_GetTotalPaidCap                                                            *
 *                                                                                                       *
 * Description           : This Function Accepts Company Code, and debug pointer.                     	*
 *                         Gets the Total Paid Up Captial for the Company from Company Master Table.     *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_total_paid_cap                    double *                         I      Total Paid Up Capital     *
 *                                                                                                       *
 * p_cmp_code									char *									I		 Company Code					*
 *																																			*
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *  p_total_paid_cap - Total Paid Up Capital																					*
 *                                                                                                       *
 ********************************************************************************************************/
int CR_GetTotalPaidCap(		double *p_total_paid_cap,
									char *p_cmp_code,
									DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	double	l_total_paid_cap=0;
	APL_IF_DEBUG
	{	
		CO_ProcMonitor(APL_OUT_FILE,"Entering Process CR_GetTotalPaidCap \n",NULL,NULL);
	}

	EXEC SQL SELECT NVL(CMP_TPCAPITAL,0) INTO :l_total_paid_cap
				FROM MT_COMPANY
				WHERE CMP_CODE=:p_cmp_code
				AND   STATUS ='AA';

	IS_ANY_ORA_ERROR;

	*p_total_paid_cap = l_total_paid_cap;

	APL_IF_DEBUG
	{
		printf("Company Code = |%s|\n",p_cmp_code);
		printf("Total Paid Up Capital = |%lf|\n",l_total_paid_cap);
	}
	
	APL_GOBACK_SUCCESS

	RETURN_SUCCESS :
   {
    	APL_IF_DEBUG
        	CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_GetTotalPaidCap SUCCESS\n",NULL,NULL);
      	return(APL_SUCCESS);
   }

  	RETURN_FAILURE :
  	{
     	APL_IF_DEBUG
        	CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_GetTotalPaidCap FAILURE\n",NULL,NULL);
  	   	return(APL_FAILURE);
	}
}

/*Smita - HDFCMT_003 - Instrument Master Maintenance */
/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrRedDep                                                            *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Redemption Mapping Structure,                *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_red_dep_struct_h    MT_INSTRUMENT_RED_DEP_STRUCT_H   I      Instrument Redemption     *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrRedDep(		MT_INSTRUMENT_RED_DEP_STRUCT_H *p_mt_instrument_red_dep_struct_h,
									INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
									DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca 	sqlca;
	int 		l_instr_count 	= 	0;
	int		l_ipa_count		=	0;
	char		l_pty_status[3] = APL_NULL_STRING;
	char		l_pty_type[3] = APL_NULL_STRING;
		
	CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrRedDep \n",NULL,NULL);
	APL_IF_DEBUG
	{
		printf("Instrument Code = |%s|\n",p_mt_instrument_red_dep_struct_h->h_instr_code);
		printf("IPA Code = |%s|\n",p_mt_instrument_red_dep_struct_h->h_ipa_code);
		printf("Mode = |%s|\n",p_intl_env_data_struct_h->h_mode);
	}

	sqlca.sqlcode = 0;
	/*In case of Modify Mode, check whether record exists for the instrument code passed*/
	if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_INPUT) != 0)
	{
		EXEC SQL SELECT NVL(COUNT(*),0) INTO :l_instr_count 
					FROM 	 MT_RED_DP_DET
					WHERE 	INSTR_CODE 		=:p_mt_instrument_red_dep_struct_h->h_instr_code 
					AND		RD_CLIENT_ID	=:p_mt_instrument_red_dep_struct_h->h_rd_client_id
					AND		RD_DEPO_CODE	=:p_mt_instrument_red_dep_struct_h->h_rd_depo_code;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
		
  if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
		APL_GOBACK_FAIL

  APL_GOBACK_SUCCESS

  RETURN_SUCCESS :
  {
   	APL_IF_DEBUG
    		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrRedDep with Success\n",NULL,p_intl_env_data_struct_h);
      	return(APL_SUCCESS);
  }

  RETURN_FAILURE :
  {
     APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrRedDep with Failure\n",NULL,p_intl_env_data_struct_h);
      	return(APL_FAILURE);
  }
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Mod_InstrRedDep                                                            *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Redemption Structure, Row Id,                *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_red_dep_struct_h    MT_INSTRUMENT_RED_DEP_STRUCT_H   I      Instrument Redemption     *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_row_id_instr                      char *                           I      Row Id of Instrument      *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Mod_InstrRedDep(		MT_INSTRUMENT_RED_DEP_STRUCT_H *p_mt_instrument_red_dep_struct_h,
									char *p_row_id_instr,
									INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
									DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca                     sqlca;
 	int                              int_retval=0;
 	char                             chr_h_sys_access_stamp[APL_DATE_LEN] = APL_NULL_STRING;
	MT_INSTRUMENT_RED_DEP_STRUCT_I   *l_mt_instrument_red_dep_struct_i = NULL;
 	char                             h_status[APL_STATUS_LEN] = APL_NULL_STRING;
 	char                             chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;

	p_key_codes[0] = "INSTR_CODE";
   p_key_codes[1] = APL_NULL_STRING;

   p_key_values[0] = p_mt_instrument_red_dep_struct_h->h_instr_code;
	p_key_values[1] = APL_NULL_STRING;

 	#ifdef APL_THREADS
    	APL_SET_CONTEXT
    	EXEC SQL CONTEXT USE :my_ctx_local;
 	#endif

 	APL_IF_DEBUG
 	{
    	CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Mod_InstrRedDep \n",NULL,p_intl_env_data_struct_h);
    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Instrument Code is |%s| \n",p_mt_instrument_red_dep_struct_h->h_instr_code);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);

    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Mode is |%s| \n",p_intl_env_data_struct_h->h_mode);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
 	}

	l_mt_instrument_red_dep_struct_i = (MT_INSTRUMENT_RED_DEP_STRUCT_I *)calloc(1,sizeof(MT_INSTRUMENT_RED_DEP_STRUCT_I));
	APL_MALLOC_FAIL(l_mt_instrument_red_dep_struct_i)

	/*Initialize Indicator Variables*/
	l_mt_instrument_red_dep_struct_i->i_instr_code       = 0;
 	l_mt_instrument_red_dep_struct_i->i_instr_seq_num    = 0;
	l_mt_instrument_red_dep_struct_i->i_rd_client_id  = 0;
	l_mt_instrument_red_dep_struct_i->i_rd_dp_id      = 0;
	l_mt_instrument_red_dep_struct_i->i_rd_depo_code  = 0;
	l_mt_instrument_red_dep_struct_i->i_ipa_code      = 0;
	l_mt_instrument_red_dep_struct_i->i_access_stamp  = 0;

	if (CO_RtvSysDtTime(chr_h_sys_access_stamp, l_debug_info_ptr) != APL_SUCCESS)
	{
	      APL_GOBACK_FAIL
	}
	else
		strcpy(p_mt_instrument_red_dep_struct_h->h_access_stamp,chr_h_sys_access_stamp);

	if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_INPUT) == 0)
	{
		int_retval = CO_RtvChldNxtSeqNum 	(	p_key_codes,
															p_key_values,
															g_chld_table_names[0],
															p_field_name,
															&p_next_seq_num,
															l_debug_info_ptr);
  		if (int_retval != APL_FAILURE)
     		p_mt_instrument_red_dep_struct_h->h_instr_seq_num = p_next_seq_num;
  		else
     		APL_GOBACK_FAIL

		APL_IF_DEBUG
		{
			printf("Sequence No Returned = |%d|\n",p_next_seq_num);
			printf("Sequence No Generated = |%d|\n",p_mt_instrument_red_dep_struct_h->h_instr_seq_num);
		}
		p_next_seq_num = 0;

  		strcpy(p_mt_instrument_red_dep_struct_h->h_status,STATUS_UAUTH);
  		strcpy(p_mt_instrument_red_dep_struct_h->h_maker, p_intl_env_data_struct_h->usr);
  		strcpy(p_mt_instrument_red_dep_struct_h->h_maker_dt, chr_h_sys_access_stamp);
  		strcpy(p_mt_instrument_red_dep_struct_h->h_checker, APL_NULL_STRING);
  		strcpy(p_mt_instrument_red_dep_struct_h->h_checker_dt, APL_NULL_STRING);
 		strcpy(p_mt_instrument_red_dep_struct_h->h_access_stamp, chr_h_sys_access_stamp);

  		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
     		APL_GOBACK_FAIL

  		EXEC SQL INSERT INTO MT_RED_DP_DET
  		VALUES(:p_mt_instrument_red_dep_struct_h:l_mt_instrument_red_dep_struct_i);

  		IS_ANY_ORA_ERROR_AND_DUPLICATE(ERR_REC_EXIST,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
	{
		APL_IF_DEBUG
		{
			printf("Mode is MODIFY for Redemption Depository Details.....\n");
			printf("Status of Recors is |%s|\n",p_mt_instrument_red_dep_struct_h->h_status);
		}

      if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
        	APL_GOBACK_FAIL

	   strcpy((char *)h_status,STATUS_UAUTH);

   	EXEC SQL UPDATE MT_RED_DP_DET
   	SET
      RD_CLIENT_ID = :p_mt_instrument_red_dep_struct_h->h_rd_client_id:l_mt_instrument_red_dep_struct_i->i_rd_client_id,
      RD_DP_ID = :p_mt_instrument_red_dep_struct_h->h_rd_dp_id:l_mt_instrument_red_dep_struct_i->i_rd_dp_id,
		IPA_CODE= :p_mt_instrument_red_dep_struct_h->h_ipa_code:l_mt_instrument_red_dep_struct_i->i_ipa_code,
      MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_red_dep_struct_i->i_maker,
      MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_red_dep_struct_i->i_maker_dt,
      ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_red_dep_struct_i->i_access_stamp,
      CHECKER = NULL,
      CHECKER_DT = NULL,
		STATUS 	=:h_status

		WHERE ROWID = :p_row_id_instr;

   	IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_DELETE) == 0)
	{
		APL_IF_DEBUG
		{
			printf("Mode is DELETE for Redemption Depository Details.....\n");
			printf("Status of Recors is |%s|\n",p_mt_instrument_red_dep_struct_h->h_status);
		}
		
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
		APL_GOBACK_FAIL
		
		strcpy((char *)h_status,STATUS_DEL_UAUTH);

		EXEC SQL UPDATE MT_RED_DP_DET
		SET
		MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_red_dep_struct_i->i_maker,
		MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_red_dep_struct_i->i_maker_dt,
		ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_red_dep_struct_i->i_access_stamp,
		CHECKER = NULL,
		CHECKER_DT = NULL,
		STATUS   =:h_status

		WHERE ROWID = :p_row_id_instr;
		
		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_RESET) == 0)
	{
		APL_IF_DEBUG
		{
			printf("Mode is RESET for Redemption Depository Details.....\n");
			printf("Status of Recors is |%s|\n",p_mt_instrument_red_dep_struct_h->h_status);
		}

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
				APL_GOBACK_FAIL

		strcpy((char *)h_status,STATUS_AUTH);
	
		EXEC SQL UPDATE MT_RED_DP_DET
		SET
		CHECKER = :p_intl_env_data_struct_h->usr,
		CHECKER_DT = :chr_h_sys_access_stamp,
		ACCESS_STAMP = :chr_h_sys_access_stamp,
		STATUS   =:h_status

		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_AUTHORISE) == 0)
	{
		APL_IF_DEBUG
		{
			printf("Mode is AUTHORISE for Redemption Depository Details.....\n");
			printf("Status of Recors is |%s|\n",p_mt_instrument_red_dep_struct_h->h_status);
		}
		
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
			APL_GOBACK_FAIL
	
		EXEC SQL SELECT STATUS
		INTO :h_status
		FROM MT_RED_DP_DET
		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)	
			 APL_GOBACK_FAIL

		if (strcmp(h_status, STATUS_DEL_UAUTH) == 0)
		{
			EXEC SQL DELETE FROM MT_RED_DP_DET
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
		}
		else 
		{
			strcpy((char *)h_status, STATUS_AUTH);
		
			EXEC SQL UPDATE MT_RED_DP_DET
			SET
			CHECKER =:p_intl_env_data_struct_h->usr,
			CHECKER_DT =:chr_h_sys_access_stamp,
			STATUS =:h_status,
			ACCESS_STAMP =:chr_h_sys_access_stamp
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
		}
	}

	int_retval = CR_Mod_UpdMastStatus(	p_key_codes,
													p_key_values,
	                                    g_mst_table_name,
                                       g_chld_table_names,
                                       APL_CHILD_IND,
                                       p_status,
                                       chr_h_sys_access_stamp,
                                       p_intl_env_data_struct_h,
                                       l_debug_info_ptr);

	APL_IF_DEBUG
	{
        	printf("Returned Status Value = |%s|\n",p_status);
	}
/*ISKB-430 - ASP,Shailesh*/		
	if ( APL_FAILURE == IV_Upd_DataGrp(p_key_values[0], p_status, p_intl_env_data_struct_h, l_debug_info_ptr))
	{
		CO_InsertErr(   l_debug_info_ptr,
                  "Error in Updating IV_DATA_GRP",
							p_key_values[0],
							APL_NULL_STRING,
							APL_NULL_STRING,
							__LINE__,
							__FILE__);

		APL_GOBACK_FAIL;
	
	}
		
	if (int_retval != APL_SUCCESS)
		APL_GOBACK_FAIL

	APL_GOBACK_SUCCESS
															
	RETURN_SUCCESS :
	{
  		APL_IF_DEBUG
    		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrRedDep with Success\n",NULL,p_intl_env_data_struct_h);
    		return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
  		APL_IF_DEBUG
   		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrRedDep with FAILURE \n",NULL,p_intl_env_data_struct_h);
   		return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrExch                                                              *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Exchange Structure, 	                        *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_exch_struct_h       MT_INSTRUMENT_EXCH_STRUCT_H      I      Instrument Exchange       *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrExch(	MT_INSTRUMENT_EXCH_STRUCT_H *p_mt_instrument_exch_struct_h,
								INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
  	struct 	sqlca   sqlca;
  	int      	l_instr_count  =  0;
	
	APL_IF_DEBUG
  		CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrExch \n",NULL,NULL);

   APL_IF_DEBUG
   {
      printf("Instrument Code = |%s|\n",p_mt_instrument_exch_struct_h->h_instr_code);
      printf("Sequence No = |%d|\n",p_mt_instrument_exch_struct_h->h_instr_seq_num);
   }

   sqlca.sqlcode = 0;
   /*In case of Modify Mode, check whether record exists for the instrument code passed*/
   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
   {
      EXEC SQL SELECT NVL(COUNT(*),0) INTO :l_instr_count
               FROM   MT_INSTR_EXCH_DET
               WHERE    INSTR_CODE     =:p_mt_instrument_exch_struct_h->h_instr_code
               AND      INSTR_SEQ_NUM =:p_mt_instrument_exch_struct_h->h_instr_seq_num
					AND		EXCH_CODE	=:p_mt_instrument_exch_struct_h->h_exch_code;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
   }

   if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
         APL_GOBACK_FAIL

   APL_GOBACK_SUCCESS

   RETURN_SUCCESS :
   {
      APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrExch with Success\n",NULL,p_intl_env_data_struct_h);
      return(APL_SUCCESS);
   }

   RETURN_FAILURE :
   {
      APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrExch with Failure\n",NULL,p_intl_env_data_struct_h);
      return(APL_FAILURE);
   }
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Mod_Instr                                                                  *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Exchnage Structure, Row Id,                  *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_exch_struct_h       MT_INSTRUMENT_EXCH_STRUCT_H      I      Instrument Exchange       *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_row_id_instr                      char *                           I      Row Id of Instrument      *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Mod_InstrExch(		MT_INSTRUMENT_EXCH_STRUCT_H *p_mt_instrument_exch_struct_h,
									char *p_row_id_instr,
									INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
									DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
   struct sqlca                     sqlca;
 	int                              int_retval=0;
 	char                             chr_h_sys_access_stamp[APL_DATE_LEN] = APL_NULL_STRING;
   MT_INSTRUMENT_EXCH_STRUCT_I   	*l_mt_instrument_exch_struct_i = NULL;
 	char                             h_status[APL_STATUS_LEN] = APL_NULL_STRING;
 	char                             chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;
	int l_int_exchScrptFlg = 0; 

 	#ifdef APL_THREADS
    	APL_SET_CONTEXT
    	EXEC SQL CONTEXT USE :my_ctx_local;
 	#endif

	p_key_codes[0] = "INSTR_CODE";
   p_key_codes[1] = APL_NULL_STRING;

   p_key_values[0] = p_mt_instrument_exch_struct_h->h_instr_code;
	p_key_values[1] = APL_NULL_STRING;

 	APL_IF_DEBUG
 	{
    	CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Mod_InstrExch \n",NULL,p_intl_env_data_struct_h);

    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Instrument Code is |%s| \n",p_mt_instrument_exch_struct_h->h_instr_code);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);

    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Mode is |%s| \n",p_intl_env_data_struct_h->h_mode);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
 	}

   l_mt_instrument_exch_struct_i = (MT_INSTRUMENT_EXCH_STRUCT_I *)calloc(1,sizeof(MT_INSTRUMENT_EXCH_STRUCT_I));
   APL_MALLOC_FAIL(l_mt_instrument_exch_struct_i)
  //T0 changes Start by Rahul6 23 AUG 2024
Alert("p_intl_env_data_struct_h->h_process |%s|",p_intl_env_data_struct_h->h_process);
    if(strcmp(p_intl_env_data_struct_h->h_process,"U")== 0)
   {
		Alert("Inside script code upload");
	   if (strlen(p_mt_instrument_exch_struct_h->h_scrip_code) != 0 && strlen(p_mt_instrument_exch_struct_h->h_scrip_code) < 6)
	   {
			 Alert("Inside script code <100000");
			 if(CO_InsertErr
					  (l_debug_info_ptr,
						   ERR_SCRPT_LIMIT_VAL,
						   APL_NULL_STRING,
						   APL_NULL_STRING,
						   APL_NULL_STRING,
						   __LINE__,
						   __FILE__
						  ) != APL_SUCCESS)
						  APL_GOBACK_FAIL	
					  APL_GOBACK_FAIL	
	 }
	  
	  Alert("eND");
	//The code checks for upload and it validates exchange code, scrip group, and market type; if any are invalid, it sets the scrip code to 0	
        if ((strcmp(p_mt_instrument_exch_struct_h->h_exch_code, "BSE") != 0) &&   
           (strcmp(p_mt_instrument_exch_struct_h->h_mkt_type, "41") != 0 ||   
            strcmp(p_mt_instrument_exch_struct_h->h_mkt_type, "17") != 0))  
         {  
             strcpy(p_mt_instrument_exch_struct_h->h_scrip_code, APL_NULL_STRING);	  
             Alert("After");			  
         }
  }
  
  //T0 changes End by Rahul 23 AUG 2024

   /*Initialize Indicator Variables*/
   l_mt_instrument_exch_struct_i->i_instr_code       = 0;
 	l_mt_instrument_exch_struct_i->i_instr_seq_num    = 0;
   l_mt_instrument_exch_struct_i->i_exch_code  		= 0;
   l_mt_instrument_exch_struct_i->i_scrip_grp      	= 0;
   l_mt_instrument_exch_struct_i->i_mkt_type  			= 0;
   l_mt_instrument_exch_struct_i->i_exch_instr_code  = 0;
	l_mt_instrument_exch_struct_i->i_listing_status 	= 0;
	l_mt_instrument_exch_struct_i->i_listing_date 		= 0;
   l_mt_instrument_exch_struct_i->i_access_stamp  	= 0;
   l_mt_instrument_exch_struct_i->i_scrip_code    = 0; // T0 changes by Rahul6 23 Aug 2024

   if (CO_RtvSysDtTime(chr_h_sys_access_stamp, l_debug_info_ptr) != APL_SUCCESS)
   {
     APL_GOBACK_FAIL
   }
   else
	strcpy(p_mt_instrument_exch_struct_h->h_access_stamp,chr_h_sys_access_stamp);

   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_INPUT) == 0)
   {
      int_retval = CO_RtvChldNxtSeqNum    (  p_key_codes,
                                             p_key_values,
                                             g_chld_table_names[1],
                                             p_field_name,
                                             &p_next_seq_num,
                                             l_debug_info_ptr);
      if (int_retval != APL_FAILURE)
         p_mt_instrument_exch_struct_h->h_instr_seq_num = p_next_seq_num;
      else
         APL_GOBACK_FAIL

      APL_IF_DEBUG
      {
         printf("Sequence No Returned = |%d|\n",p_next_seq_num);
         printf("Sequence No Generated = |%d|\n",p_mt_instrument_exch_struct_h->h_instr_seq_num);
      }
      p_next_seq_num = 0;

  		strcpy(p_mt_instrument_exch_struct_h->h_status,STATUS_UAUTH);
  		strcpy(p_mt_instrument_exch_struct_h->h_maker, p_intl_env_data_struct_h->usr);
  		strcpy(p_mt_instrument_exch_struct_h->h_maker_dt, chr_h_sys_access_stamp);
  		strcpy(p_mt_instrument_exch_struct_h->h_checker, APL_NULL_STRING);
  		strcpy(p_mt_instrument_exch_struct_h->h_checker_dt, APL_NULL_STRING);
  		strcpy(p_mt_instrument_exch_struct_h->h_access_stamp, chr_h_sys_access_stamp);

  		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
     		APL_GOBACK_FAIL

		/*  Rahul6 started to verfiy Script code start*/	
            if (strlen(p_mt_instrument_exch_struct_h->h_scrip_code) != 0)
	    {	
	        EXEC SQL SELECT NVL(COUNT(*),0) INTO :l_int_exchScrptFlg
			FROM MT_INSTR_EXCH_DET 
			WHERE 
		    SCRIP_CODE = :p_mt_instrument_exch_struct_h->h_scrip_code 
			AND (:p_mt_instrument_exch_struct_h->h_exch_code = 'BSE' 
			AND EXCH_CODE = :p_mt_instrument_exch_struct_h->h_exch_code ) ;

			printf("\n l_int_exchScrptFlg ---  |%d| \n",l_int_exchScrptFlg);

			if(l_int_exchScrptFlg > 0)
			{
				if(CO_InsertErr
					  (l_debug_info_ptr,
						   MAP_DET_EXIST,
						   APL_NULL_STRING,
						   APL_NULL_STRING,
						   APL_NULL_STRING,
						   __LINE__,
						   __FILE__
						  ) != APL_SUCCESS)
						  APL_GOBACK_FAIL	
					  APL_GOBACK_FAIL	
			}	
		}
     /*  Rahul6 started to verfiy Script code End T0*/

  		EXEC SQL INSERT INTO MT_INSTR_EXCH_DET
  		VALUES(:p_mt_instrument_exch_struct_h:l_mt_instrument_exch_struct_i);

  		IS_ANY_ORA_ERROR_AND_DUPLICATE(ERR_REC_EXIST,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
   {
      APL_IF_DEBUG
      {
         printf("Mode is MODIFY for Exchange Instrument Mapping Details.....\n");
			printf("Instrument Code = |%s|\n",p_mt_instrument_exch_struct_h->h_instr_code);
         printf("Sequence No is |%d|\n",p_mt_instrument_exch_struct_h->h_instr_seq_num);
			printf("Exchange Code = |%s|\n",p_mt_instrument_exch_struct_h->h_exch_code);
      }

      if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
         APL_GOBACK_FAIL

      strcpy((char *)h_status,STATUS_UAUTH);

      EXEC SQL UPDATE MT_INSTR_EXCH_DET
      SET
      SCRIP_GRP = :p_mt_instrument_exch_struct_h->h_scrip_grp:l_mt_instrument_exch_struct_i->i_scrip_grp,
      MKT_TYPE = :p_mt_instrument_exch_struct_h->h_mkt_type:l_mt_instrument_exch_struct_i->i_mkt_type,
      EXCH_INSTR_CODE = :p_mt_instrument_exch_struct_h->h_exch_instr_code:l_mt_instrument_exch_struct_i->i_exch_instr_code,
		LISTING_STATUS =:p_mt_instrument_exch_struct_h->h_listing_status:l_mt_instrument_exch_struct_i->i_listing_status,
		LISTING_DATE =:p_mt_instrument_exch_struct_h->h_listing_date:l_mt_instrument_exch_struct_i->i_listing_date,
      MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_exch_struct_i->i_maker,
      MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_exch_struct_i->i_maker_dt,
      ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_exch_struct_i->i_access_stamp,
      CHECKER = NULL,
      CHECKER_DT = NULL,
      STATUS 	=:h_status,
      SCRIP_CODE =:p_mt_instrument_exch_struct_h->h_scrip_code:l_mt_instrument_exch_struct_i->i_scrip_code   // T0 changes by Rahul6 23 Aug 2024

      WHERE ROWID = :p_row_id_instr;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
   else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_DELETE) == 0)
   {
      APL_IF_DEBUG
      {
         printf("Mode is DELETE for Exchange Instrument Mapping Details.....\n");
			printf("Instrument Code = |%s|\n",p_mt_instrument_exch_struct_h->h_instr_code);
         printf("Sequence No is |%d|\n",p_mt_instrument_exch_struct_h->h_instr_seq_num);
			printf("Exchange Code = |%s|\n",p_mt_instrument_exch_struct_h->h_exch_code);
      }

      if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
      APL_GOBACK_FAIL

      strcpy((char *)h_status,STATUS_DEL_UAUTH);

      EXEC SQL UPDATE MT_INSTR_EXCH_DET
      SET
      MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_exch_struct_i->i_maker,
      MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_exch_struct_i->i_maker_dt,
      ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_exch_struct_i->i_access_stamp,
      CHECKER = NULL,
      CHECKER_DT = NULL,
      STATUS   =:h_status

      WHERE ROWID = :p_row_id_instr;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
   }
   else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_RESET) == 0)
   {
      APL_IF_DEBUG
      {
         printf("Mode is RESET for Exchange Instrument Mapping Details.....\n");
			printf("Instrument Code = |%s|\n",p_mt_instrument_exch_struct_h->h_instr_code);
         printf("Sequence No is |%d|\n",p_mt_instrument_exch_struct_h->h_instr_seq_num);
			printf("Exchange Code = |%s|\n",p_mt_instrument_exch_struct_h->h_exch_code);
      }

      if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
            APL_GOBACK_FAIL

      strcpy((char *)h_status,STATUS_AUTH);

      EXEC SQL UPDATE MT_INSTR_EXCH_DET
      SET
      CHECKER = :p_intl_env_data_struct_h->usr,
      CHECKER_DT = :chr_h_sys_access_stamp,
      ACCESS_STAMP = :chr_h_sys_access_stamp,
      STATUS   =:h_status

      WHERE ROWID = :p_row_id_instr;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
   }
   else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_AUTHORISE) == 0)
   {
      APL_IF_DEBUG
      {
         printf("Mode is AUTHORISE for Exchange Instrument Mapping Details.....\n");
			printf("Instrument Code = |%s|\n",p_mt_instrument_exch_struct_h->h_instr_code);
         printf("Sequence No is |%d|\n",p_mt_instrument_exch_struct_h->h_instr_seq_num);
			printf("Exchange Code = |%s|\n",p_mt_instrument_exch_struct_h->h_exch_code);
      }

      if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
         APL_GOBACK_FAIL

      EXEC SQL SELECT STATUS
      INTO :h_status
      FROM MT_INSTR_EXCH_DET
      WHERE ROWID = :p_row_id_instr;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

      if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
          APL_GOBACK_FAIL

      if (strcmp(h_status, STATUS_DEL_UAUTH) == 0)
      {
         EXEC SQL DELETE FROM MT_INSTR_EXCH_DET
         WHERE ROWID = :p_row_id_instr;

         IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
      }
      else
      {
         strcpy((char *)h_status, STATUS_AUTH);

         EXEC SQL UPDATE MT_INSTR_EXCH_DET
         SET
         CHECKER =:p_intl_env_data_struct_h->usr,
         CHECKER_DT =:chr_h_sys_access_stamp,
         STATUS =:h_status,
         ACCESS_STAMP =:chr_h_sys_access_stamp
         WHERE ROWID = :p_row_id_instr;

         IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
      }
   }
	
   int_retval = CR_Mod_UpdMastStatus(  p_key_codes,
                                       p_key_values,
                                       g_mst_table_name,
                                       g_chld_table_names,
                                       APL_CHILD_IND,
                                       p_status,
                                       chr_h_sys_access_stamp,
                                       p_intl_env_data_struct_h,
                                       l_debug_info_ptr);
	
	APL_IF_DEBUG
	{
        	printf("Returned Status Value = |%s|\n",p_status);
	}
/*ISKB-430 - ASP,Shailesh*/
	if ( APL_FAILURE == IV_Upd_DataGrp(p_key_values[0], p_status, p_intl_env_data_struct_h, l_debug_info_ptr))
	{
		CO_InsertErr(   l_debug_info_ptr,
                   "Error in Updating IV_DATA_GRP",
							p_key_values[0],
							APL_NULL_STRING,
							APL_NULL_STRING,
							__LINE__,
							__FILE__);

		APL_GOBACK_FAIL;

	}

   if (int_retval != APL_SUCCESS)
       APL_GOBACK_FAIL

   APL_GOBACK_SUCCESS

	RETURN_SUCCESS :
	{
  		APL_IF_DEBUG
    		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrExch with Success\n",NULL,p_intl_env_data_struct_h);
    		return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
  		APL_IF_DEBUG
   		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrExch with FAILURE \n",NULL,p_intl_env_data_struct_h);
   		return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Mod_InstrCrd                                                               *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Credit Rating Agency Structure, Row Id,      *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_cr_agency_struct_h  MT_INSTRUMENT_CR_AGENCY_STRUCT_H I      Instrument Crd Details    *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_row_id_instr                      char *                           I      Row Id of Instrument      *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Mod_InstrCrd(		MT_INSTRUMENT_CR_AGENCY_STRUCT_H *p_mt_instrument_cr_agency_struct_h,
								char *p_row_id_instr,
								INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
 	struct sqlca                     sqlca;
 	int                              int_retval=0;
 	char                             chr_h_sys_access_stamp[APL_DATE_LEN] = APL_NULL_STRING;
 	MT_INSTRUMENT_CR_AGENCY_STRUCT_I *l_mt_instrument_cr_agency_struct_i = NULL;
 	char                             h_status[APL_STATUS_LEN] = APL_NULL_STRING;
 	char                             chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;
	char										chr_i_val_exists,chr_i_val_authorised,chr_i_val_deleted;

 	#ifdef APL_THREADS
    	APL_SET_CONTEXT
    	EXEC SQL CONTEXT USE :my_ctx_local;
 	#endif
   
	p_key_codes[0] = "INSTR_CODE";
   p_key_codes[1] = APL_NULL_STRING;

   p_key_values[0] = p_mt_instrument_cr_agency_struct_h->h_instr_code;
	p_key_values[1] = APL_NULL_STRING;

	chr_i_val_exists = 'Y';
	chr_i_val_authorised = 'Y';
	chr_i_val_deleted = 'N';

 	APL_IF_DEBUG
	 {
   	CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Mod_InstrCrd \n",NULL,p_intl_env_data_struct_h);
    	
		memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Instrument Code is |%s| \n",p_mt_instrument_cr_agency_struct_h->h_instr_code);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);

    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
   	sprintf(chr_l_buf,"Mode is |%s| \n",p_intl_env_data_struct_h->h_mode);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
 	}

   l_mt_instrument_cr_agency_struct_i = (MT_INSTRUMENT_CR_AGENCY_STRUCT_I *)calloc(1,sizeof(MT_INSTRUMENT_CR_AGENCY_STRUCT_I));
   APL_MALLOC_FAIL(l_mt_instrument_cr_agency_struct_i)

   /*Initialize Indicator Variables*/
   l_mt_instrument_cr_agency_struct_i->i_instr_code       	= 0;
   l_mt_instrument_cr_agency_struct_i->i_instr_seq_num    	= 0;
   l_mt_instrument_cr_agency_struct_i->i_cr_agency_code   	= 0;
   l_mt_instrument_cr_agency_struct_i->i_rating_code      	= 0;
   l_mt_instrument_cr_agency_struct_i->i_effdt_fr  		 	= 0;
   l_mt_instrument_cr_agency_struct_i->i_effdt_to  		 	= 0;
   l_mt_instrument_cr_agency_struct_i->i_access_stamp  		= 0;

   if (CO_RtvSysDtTime(chr_h_sys_access_stamp, l_debug_info_ptr) != APL_SUCCESS)
   {
      APL_GOBACK_FAIL
   }
   else
	strcpy(p_mt_instrument_cr_agency_struct_h->h_access_stamp,chr_h_sys_access_stamp);

	int_retval = CO_Chk_CrdRatAgnValid(	p_mt_instrument_cr_agency_struct_h->h_cr_agency_code,
													chr_i_val_exists,
													chr_i_val_authorised,
													chr_i_val_deleted,
													l_debug_info_ptr);

	if (int_retval !=APL_SUCCESS)
		APL_GOBACK_FAIL

	int_retval = CO_Chk_RatingCdValid(	p_mt_instrument_cr_agency_struct_h->h_cr_agency_code,
													p_mt_instrument_cr_agency_struct_h->h_rating_code,
												 	l_debug_info_ptr);

	if (int_retval !=APL_SUCCESS)
		APL_GOBACK_FAIL

   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_INPUT) == 0)
   {
      int_retval = CO_RtvChldNxtSeqNum    (  p_key_codes,
                                             p_key_values,
                                             g_chld_table_names[2],
                                             p_field_name,
                                             &p_next_seq_num,
                                             l_debug_info_ptr);
      if (int_retval != APL_FAILURE)
         p_mt_instrument_cr_agency_struct_h->h_instr_seq_num = p_next_seq_num;
      else
         APL_GOBACK_FAIL

      APL_IF_DEBUG
      {
         printf("Sequence No Returned = |%d|\n",p_next_seq_num);
         printf("Sequence No Generated = |%d|\n",p_mt_instrument_cr_agency_struct_h->h_instr_seq_num);
      }
      p_next_seq_num = 0;

  		strcpy(p_mt_instrument_cr_agency_struct_h->h_status,STATUS_UAUTH);
  		strcpy(p_mt_instrument_cr_agency_struct_h->h_maker, p_intl_env_data_struct_h->usr);
  		strcpy(p_mt_instrument_cr_agency_struct_h->h_maker_dt, chr_h_sys_access_stamp);
  		strcpy(p_mt_instrument_cr_agency_struct_h->h_checker, APL_NULL_STRING);
  		strcpy(p_mt_instrument_cr_agency_struct_h->h_checker_dt, APL_NULL_STRING);
  		strcpy(p_mt_instrument_cr_agency_struct_h->h_access_stamp, chr_h_sys_access_stamp);

  		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
     		APL_GOBACK_FAIL

  		EXEC SQL INSERT INTO MT_INSTR_RATING_DET
  		VALUES(:p_mt_instrument_cr_agency_struct_h:l_mt_instrument_cr_agency_struct_i);

  		IS_ANY_ORA_ERROR_AND_DUPLICATE(ERR_REC_EXIST,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
   {
      APL_IF_DEBUG
      {
         printf("Mode is MODIFY for Credit Rating Agency Details.....\n");
         printf("Sequence No is |%d|\n",p_mt_instrument_cr_agency_struct_h->h_instr_seq_num);
      }

      if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
         APL_GOBACK_FAIL

      strcpy((char *)h_status,STATUS_UAUTH);

      EXEC SQL UPDATE MT_INSTR_RATING_DET
      SET
      CR_AGENCY_CODE = :p_mt_instrument_cr_agency_struct_h->h_cr_agency_code:l_mt_instrument_cr_agency_struct_i->i_cr_agency_code,
      RATING_CODE = :p_mt_instrument_cr_agency_struct_h->h_rating_code:l_mt_instrument_cr_agency_struct_i->i_rating_code,
      EFFDT_FR = :p_mt_instrument_cr_agency_struct_h->h_effdt_fr:l_mt_instrument_cr_agency_struct_i->i_effdt_fr,
      EFFDT_TO = :p_mt_instrument_cr_agency_struct_h->h_effdt_to:l_mt_instrument_cr_agency_struct_i->i_effdt_to,
      MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_cr_agency_struct_i->i_maker,
      MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_cr_agency_struct_i->i_maker_dt,
      ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_cr_agency_struct_i->i_access_stamp,
      CHECKER = NULL,
      CHECKER_DT = NULL,
      STATUS =:h_status
		
      WHERE ROWID = :p_row_id_instr;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
   }
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_DELETE) == 0)
	{
		APL_IF_DEBUG
		{
         printf("Mode is DELETE for Credit Rating Agency Details.....\n");
         printf("Sequence No is |%d|\n",p_mt_instrument_cr_agency_struct_h->h_instr_seq_num);
		}
		
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
		APL_GOBACK_FAIL
		
		strcpy((char *)h_status,STATUS_DEL_UAUTH);

		EXEC SQL UPDATE MT_INSTR_RATING_DET
		SET
		MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_cr_agency_struct_i->i_maker,
		MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_cr_agency_struct_i->i_maker_dt,
		ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_cr_agency_struct_i->i_access_stamp,
		CHECKER = NULL,
		CHECKER_DT = NULL,
		STATUS   =:h_status

		WHERE ROWID = :p_row_id_instr;
		
		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_RESET) == 0)
	{
		APL_IF_DEBUG
		{
         printf("Mode is RESET for Credit Rating Agency Details.....\n");
         printf("Sequence No is |%d|\n",p_mt_instrument_cr_agency_struct_h->h_instr_seq_num);
		}

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
				APL_GOBACK_FAIL

		strcpy((char *)h_status,STATUS_AUTH);
	
		EXEC SQL UPDATE MT_INSTR_RATING_DET
		SET
		CHECKER = :p_intl_env_data_struct_h->usr,
		CHECKER_DT = :chr_h_sys_access_stamp,
		ACCESS_STAMP = :chr_h_sys_access_stamp,
		STATUS   =:h_status

		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_AUTHORISE) == 0)
	{
		APL_IF_DEBUG
		{
         printf("Mode is AUTHORISE for Credit Rating Agency Details.....\n");
         printf("Sequence No is |%d|\n",p_mt_instrument_cr_agency_struct_h->h_instr_seq_num);
		}
		
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
			APL_GOBACK_FAIL
	
		EXEC SQL SELECT STATUS
		INTO :h_status
		FROM MT_INSTR_RATING_DET
		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)	
			 APL_GOBACK_FAIL

		if (strcmp(h_status, STATUS_DEL_UAUTH) == 0)
		{
			EXEC SQL DELETE FROM MT_INSTR_RATING_DET
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
		}
		else 
		{
			strcpy((char *)h_status, STATUS_AUTH);
		
			EXEC SQL UPDATE MT_INSTR_RATING_DET
			SET
			CHECKER =:p_intl_env_data_struct_h->usr,
			CHECKER_DT =:chr_h_sys_access_stamp,
			STATUS =:h_status,
			ACCESS_STAMP =:chr_h_sys_access_stamp
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
		}
	}
	
   int_retval = CR_Mod_UpdMastStatus(  p_key_codes,
                                       p_key_values,
                                       g_mst_table_name,
                                       g_chld_table_names,
                                       APL_CHILD_IND,
                                       p_status,
                                       chr_h_sys_access_stamp,
                                       p_intl_env_data_struct_h,
                                       l_debug_info_ptr);

	APL_IF_DEBUG
	{
         	printf("Returned Status Value = |%s|\n",p_status);
	}
/*ISKB-430 - ASP,Shailesh*/
	if ( APL_FAILURE == IV_Upd_DataGrp(p_key_values[0], p_status, p_intl_env_data_struct_h, l_debug_info_ptr))
	{
		CO_InsertErr(   l_debug_info_ptr,
                   "Error in Updating IV_DATA_GRP",
							p_key_values[0],
							APL_NULL_STRING,
							APL_NULL_STRING,
							__LINE__,
							__FILE__);

		APL_GOBACK_FAIL;
	
	}


   if (int_retval != APL_SUCCESS)
      APL_GOBACK_FAIL

   APL_GOBACK_SUCCESS

	RETURN_SUCCESS :
	{
  		APL_IF_DEBUG
    		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrCrd with Success\n",NULL,p_intl_env_data_struct_h);
    		return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
  		APL_IF_DEBUG
   		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrCrd with FAILURE \n",NULL,p_intl_env_data_struct_h);
   		return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrCrd                                                               *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Cerdit Rating Agency Structure,              *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_cr_agency_struct_h  MT_INSTRUMENT_CR_AGENCY_STRUCT_H I      Instrument Crd Details    *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrCrd(		MT_INSTRUMENT_CR_AGENCY_STRUCT_H *p_mt_instrument_cr_agency_struct_h,
								INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
   struct 	sqlca   sqlca;
   int      l_instr_count = 0;

   APL_IF_DEBUG
   {
      CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrCrd \n",NULL,NULL);

      printf("Instrument Code = |%s|\n",p_mt_instrument_cr_agency_struct_h->h_instr_code);
      printf("Sequence No = |%d|\n",p_mt_instrument_cr_agency_struct_h->h_instr_seq_num);
   }

   sqlca.sqlcode = 0;
   /*In case of Modify Mode, check whether record exists for the instrument code passed*/
   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
   {
      EXEC SQL SELECT NVL(COUNT(*),0) INTO :l_instr_count
               FROM   MT_INSTR_RATING_DET
               WHERE    INSTR_CODE     =:p_mt_instrument_cr_agency_struct_h->h_instr_code
               AND      INSTR_SEQ_NUM =:p_mt_instrument_cr_agency_struct_h->h_instr_seq_num;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
   }

   if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
      APL_GOBACK_FAIL

   APL_GOBACK_SUCCESS

   RETURN_SUCCESS :
   {
    	APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrCrd with Success\n",NULL,p_intl_env_data_struct_h);
      	return(APL_SUCCESS);
   }

   RETURN_FAILURE :
   {
      APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrCrd with Failure\n",NULL,p_intl_env_data_struct_h);
			return(APL_FAILURE);
  	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Mod_InstrPC                                                                *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Put Call Structure, Row Id,                  *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_pc_struct_h         MT_INSTRUMENT_PC_STRUCT_H        I      Instrument Put Call       *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_row_id_instr                      char *                           I      Row Id of Instrument      *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Mod_InstrPC(		MT_INSTRUMENT_PC_STRUCT_H *p_mt_instrument_pc_struct_h,
								char *p_row_id_instr,
								INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
  	struct sqlca                     sqlca;
 	int                              int_retval=0;
 	char                             chr_h_sys_access_stamp[APL_DATE_LEN] = APL_NULL_STRING;
  	MT_INSTRUMENT_PC_STRUCT_I   		*l_mt_instrument_pc_struct_i = NULL;
 	char                             h_status[APL_STATUS_LEN] = APL_NULL_STRING;
 	char                             chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;

 	#ifdef APL_THREADS
    	APL_SET_CONTEXT
    	EXEC SQL CONTEXT USE :my_ctx_local;
 	#endif

   p_key_codes[0] = "INSTR_CODE";
   p_key_codes[1] = APL_NULL_STRING;

   p_key_values[0] = p_mt_instrument_pc_struct_h->h_instr_code;
	p_key_values[1] = APL_NULL_STRING;

 	APL_IF_DEBUG
 	{
    	CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Mod_InstrPC \n",NULL,p_intl_env_data_struct_h);
    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Instrument Code is |%s| \n",p_mt_instrument_pc_struct_h->h_instr_code);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);

    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Mode is |%s| \n",p_intl_env_data_struct_h->h_mode);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
 	}

  	l_mt_instrument_pc_struct_i = (MT_INSTRUMENT_PC_STRUCT_I *)calloc(1,sizeof(MT_INSTRUMENT_PC_STRUCT_I));
  	APL_MALLOC_FAIL(l_mt_instrument_pc_struct_i)

  	/*Initialize Indicator Variables*/
  	l_mt_instrument_pc_struct_i->i_instr_code       	= 0;
  	l_mt_instrument_pc_struct_i->i_instr_seq_num    	= 0;
  	l_mt_instrument_pc_struct_i->i_pc_flag  		= 0;
  	l_mt_instrument_pc_struct_i->i_pc_date      		= 0;
  	l_mt_instrument_pc_struct_i->i_instr_pc_effdt     	= 0;
  	l_mt_instrument_pc_struct_i->i_instr_pc_cutofftime	= 0;
  	l_mt_instrument_pc_struct_i->i_pc_notice_date  		= 0;
  	l_mt_instrument_pc_struct_i->i_access_stamp  		= 0;

  	if (CO_RtvSysDtTime(chr_h_sys_access_stamp, l_debug_info_ptr) != APL_SUCCESS)
	{
	      APL_GOBACK_FAIL
	}
	else
		strcpy(p_mt_instrument_pc_struct_h->h_access_stamp,chr_h_sys_access_stamp);
		

  	if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_INPUT) == 0)
  	{
      int_retval = CO_RtvChldNxtSeqNum    (  p_key_codes,
                                             p_key_values,
                                             g_chld_table_names[3],
                                             p_field_name,
                                             &p_next_seq_num,
                                             l_debug_info_ptr);
      if (int_retval != APL_FAILURE)
         p_mt_instrument_pc_struct_h->h_instr_seq_num = p_next_seq_num;
      else
         APL_GOBACK_FAIL

      APL_IF_DEBUG
      {
         printf("Sequence No Returned = |%d|\n",p_next_seq_num);
         printf("Sequence No Generated = |%d|\n",p_mt_instrument_pc_struct_h->h_instr_seq_num);
      }
      p_next_seq_num = 0;
  		strcpy(p_mt_instrument_pc_struct_h->h_status,STATUS_UAUTH);
  		strcpy(p_mt_instrument_pc_struct_h->h_maker, p_intl_env_data_struct_h->usr);
  		strcpy(p_mt_instrument_pc_struct_h->h_maker_dt, chr_h_sys_access_stamp);
  		strcpy(p_mt_instrument_pc_struct_h->h_checker, APL_NULL_STRING);
  		strcpy(p_mt_instrument_pc_struct_h->h_checker_dt, APL_NULL_STRING);
  		strcpy(p_mt_instrument_pc_struct_h->h_access_stamp, chr_h_sys_access_stamp);

  		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
     		APL_GOBACK_FAIL

  		EXEC SQL INSERT INTO MT_PC_DET
  		VALUES(:p_mt_instrument_pc_struct_h:l_mt_instrument_pc_struct_i);

  		IS_ANY_ORA_ERROR_AND_DUPLICATE(ERR_REC_EXIST,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
   {
      APL_IF_DEBUG
      {
          printf("Mode is MODIFY for Put Call Details.....\n");
          printf("Sequence No is |%d|\n",p_mt_instrument_pc_struct_h->h_instr_seq_num);
      }

      if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
         APL_GOBACK_FAIL

      strcpy((char *)h_status,STATUS_UAUTH);

		/*Added Fields Effective Date & Cut Off Time for Put Call as Daily - Smita - HDFCMT_003 */
      EXEC SQL UPDATE MT_PC_DET
      SET
      PC_FLAG = :p_mt_instrument_pc_struct_h->h_pc_flag:l_mt_instrument_pc_struct_i->i_pc_flag,
      PC_DATE = :p_mt_instrument_pc_struct_h->h_pc_date:l_mt_instrument_pc_struct_i->i_pc_date,
      PC_NOTICE_DATE =:p_mt_instrument_pc_struct_h->h_pc_notice_date:l_mt_instrument_pc_struct_i->i_pc_notice_date,
		INSTR_PC_EFFDT =:p_mt_instrument_pc_struct_h->h_instr_pc_effdt:l_mt_instrument_pc_struct_i->i_instr_pc_effdt,
		INSTR_PC_CUTOFFTIME =:p_mt_instrument_pc_struct_h->h_instr_pc_cutofftime:l_mt_instrument_pc_struct_i->i_instr_pc_cutofftime,
      MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_pc_struct_i->i_maker,
      MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_pc_struct_i->i_maker_dt,
      ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_pc_struct_i->i_access_stamp,
      CHECKER = NULL,
      CHECKER_DT = NULL,
      STATUS =:h_status

      WHERE ROWID = :p_row_id_instr;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
   }
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_DELETE) == 0)
	{
		APL_IF_DEBUG
		{
          printf("Mode is DELETE for Put Call Details.....\n");
          printf("Sequence No is |%d|\n",p_mt_instrument_pc_struct_h->h_instr_seq_num);
		}
		
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
		APL_GOBACK_FAIL
		
		strcpy((char *)h_status,STATUS_DEL_UAUTH);

		EXEC SQL UPDATE MT_PC_DET
		SET
		MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_pc_struct_i->i_maker,
		MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_pc_struct_i->i_maker_dt,
		ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_pc_struct_i->i_access_stamp,
		CHECKER = NULL,
		CHECKER_DT = NULL,
		STATUS   =:h_status

		WHERE ROWID = :p_row_id_instr;
		
		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_RESET) == 0)
	{
		APL_IF_DEBUG
		{
          printf("Mode is RESET for Put Call Details.....\n");
          printf("Sequence No is |%d|\n",p_mt_instrument_pc_struct_h->h_instr_seq_num);
		}

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
				APL_GOBACK_FAIL

		strcpy((char *)h_status,STATUS_AUTH);
	
		EXEC SQL UPDATE MT_PC_DET
		SET
		CHECKER = :p_intl_env_data_struct_h->usr,
		CHECKER_DT = :chr_h_sys_access_stamp,
		ACCESS_STAMP = :chr_h_sys_access_stamp,
		STATUS   =:h_status

		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_AUTHORISE) == 0)
	{
		APL_IF_DEBUG
		{
          printf("Mode is AUTHORISE for Put Call Details.....\n");
          printf("Sequence No is |%d|\n",p_mt_instrument_pc_struct_h->h_instr_seq_num);
		}
		
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
			APL_GOBACK_FAIL
	
		EXEC SQL SELECT STATUS
		INTO :h_status
		FROM MT_PC_DET
		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)	
			 APL_GOBACK_FAIL

		if (strcmp(h_status, STATUS_DEL_UAUTH) == 0)
		{
			EXEC SQL DELETE FROM MT_PC_DET
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
		}
		else 
		{
			strcpy((char *)h_status, STATUS_AUTH);
		
			EXEC SQL UPDATE MT_PC_DET
			SET
			CHECKER =:p_intl_env_data_struct_h->usr,
			CHECKER_DT =:chr_h_sys_access_stamp,
			STATUS =:h_status,
			ACCESS_STAMP =:chr_h_sys_access_stamp
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
		}
	}
	
   int_retval = CR_Mod_UpdMastStatus(  p_key_codes,
                                       p_key_values,
                                       g_mst_table_name,
                                       g_chld_table_names,
                                       APL_CHILD_IND,
                                       p_status,
                                       chr_h_sys_access_stamp,
                                       p_intl_env_data_struct_h,
                                       l_debug_info_ptr);

	APL_IF_DEBUG
	{
        	printf("Returned Status Value = |%s|\n",p_status);
	}
/*ISKB-430 - ASP,Shailesh*/
	if ( APL_FAILURE == IV_Upd_DataGrp(p_key_values[0], p_status, p_intl_env_data_struct_h, l_debug_info_ptr))
	{
		CO_InsertErr(   l_debug_info_ptr,
                   "Error in Updating IV_DATA_GRP",
							p_key_values[0],
							APL_NULL_STRING,
							APL_NULL_STRING,
							__LINE__,
							__FILE__);

		APL_GOBACK_FAIL;
	
	}


   if (int_retval != APL_SUCCESS)
      APL_GOBACK_FAIL

   APL_GOBACK_SUCCESS

	RETURN_SUCCESS :
	{
  		APL_IF_DEBUG
    		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrPC with Success\n",NULL,p_intl_env_data_struct_h);
    	return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
  		APL_IF_DEBUG
   		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrPC with FAILURE \n",NULL,p_intl_env_data_struct_h);
   	return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrPC                                                                *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Put Call Structure,                          *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_pc_struct_h         MT_INSTRUMENT_PC_STRUCT_H        I      Instrument PC Details     *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrPC(		MT_INSTRUMENT_PC_STRUCT_H *p_mt_instrument_pc_struct_h,
								INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
   struct sqlca   sqlca;
   int      l_instr_count = 0;
   
	APL_IF_DEBUG
   {
      CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrPC \n",NULL,NULL);

      printf("Instrument Code = |%s|\n",p_mt_instrument_pc_struct_h->h_instr_code);
      printf("Sequence No = |%d|\n",p_mt_instrument_pc_struct_h->h_instr_seq_num);
   }

   sqlca.sqlcode = 0;
   /*In case of Modify Mode, check whether record exists for the instrument code passed*/
   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
   {
      EXEC SQL SELECT NVL(COUNT(*),0) INTO :l_instr_count
               FROM   MT_PC_DET
               WHERE    INSTR_CODE     =:p_mt_instrument_pc_struct_h->h_instr_code
               AND      INSTR_SEQ_NUM =:p_mt_instrument_pc_struct_h->h_instr_seq_num;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
   }

   if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
      APL_GOBACK_FAIL

   APL_GOBACK_SUCCESS

   RETURN_SUCCESS :
   {
     APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrPC with Success\n",NULL,p_intl_env_data_struct_h);
		   return(APL_SUCCESS);
   }

   RETURN_FAILURE :
   {
      APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrPC with Failure\n",NULL,p_intl_env_data_struct_h);
			return(APL_FAILURE);
   }
}	

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Mod_InstrPartRed                                                           *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Partial Redemption Structure, Row Id,        *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_part_red_struct_h   MT_INSTRUMENT_PART_RED_STRUCT_H  I      Instrument Part Red       *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_row_id_instr                      char *                           I      Row Id of Instrument      *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Mod_InstrPartRed(		MT_INSTRUMENT_PART_RED_STRUCT_H *p_mt_instrument_part_red_struct_h,
										char *p_row_id_instr,
										INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
										DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
   struct sqlca                     sqlca;
 	int                              int_retval=0;
 	char                             chr_h_sys_access_stamp[APL_DATE_LEN] = APL_NULL_STRING;
   MT_INSTRUMENT_PART_RED_STRUCT_I  *l_mt_instrument_part_red_struct_i = NULL;
 	char                             h_status[APL_STATUS_LEN] = APL_NULL_STRING;
 	char                             chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;

 	#ifdef APL_THREADS
    	APL_SET_CONTEXT
    	EXEC SQL CONTEXT USE :my_ctx_local;
 	#endif

   p_key_codes[0] = "INSTR_CODE";
   p_key_codes[1] = APL_NULL_STRING;

   p_key_values[0] = p_mt_instrument_part_red_struct_h->h_instr_code;
	p_key_values[1] = APL_NULL_STRING;

 	APL_IF_DEBUG
 	{
    	CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Mod_InstrPartRed \n",NULL,p_intl_env_data_struct_h);
	
    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Instrument Code is |%s| \n",p_mt_instrument_part_red_struct_h->h_instr_code);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);

    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Mode is |%s| \n",p_intl_env_data_struct_h->h_mode);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
 	}

   l_mt_instrument_part_red_struct_i = (MT_INSTRUMENT_PART_RED_STRUCT_I *)calloc(1,sizeof(MT_INSTRUMENT_PART_RED_STRUCT_I));
   APL_MALLOC_FAIL(l_mt_instrument_part_red_struct_i)

   /*Initialize Indicator Variables*/
   l_mt_instrument_part_red_struct_i->i_instr_code       	= 0;
   l_mt_instrument_part_red_struct_i->i_instr_seq_num    	= 0;
   l_mt_instrument_part_red_struct_i->i_red_dt  				= 0;
   l_mt_instrument_part_red_struct_i->i_red_pct      		= 0;
   l_mt_instrument_part_red_struct_i->i_red_value  			= 0;
   l_mt_instrument_part_red_struct_i->i_access_stamp  		= 0;

   if (CO_RtvSysDtTime(chr_h_sys_access_stamp, l_debug_info_ptr) != APL_SUCCESS)
    {
      APL_GOBACK_FAIL
    }
    else
	strcpy(p_mt_instrument_part_red_struct_h->h_access_stamp,chr_h_sys_access_stamp);


   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_INPUT) == 0)
   {
	   int_retval = CO_RtvChldNxtSeqNum    (  p_key_codes,
                                             p_key_values,
                                             g_chld_table_names[5],
                                             p_field_name,
                                             &p_next_seq_num,
                                             l_debug_info_ptr);
      if (int_retval != APL_FAILURE)
         p_mt_instrument_part_red_struct_h->h_instr_seq_num = p_next_seq_num;
      else
         APL_GOBACK_FAIL

      APL_IF_DEBUG
      {
         printf("Sequence No Returned = |%d|\n",p_next_seq_num);
         printf("Sequence No Generated = |%d|\n",p_mt_instrument_part_red_struct_h->h_instr_seq_num);
      }
      p_next_seq_num = 0;

  		strcpy(p_mt_instrument_part_red_struct_h->h_status,STATUS_UAUTH);
  		strcpy(p_mt_instrument_part_red_struct_h->h_maker, p_intl_env_data_struct_h->usr);
  		strcpy(p_mt_instrument_part_red_struct_h->h_maker_dt, chr_h_sys_access_stamp);
  		strcpy(p_mt_instrument_part_red_struct_h->h_checker, APL_NULL_STRING);
  		strcpy(p_mt_instrument_part_red_struct_h->h_checker_dt, APL_NULL_STRING);
  		strcpy(p_mt_instrument_part_red_struct_h->h_access_stamp, chr_h_sys_access_stamp);

  		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
     		APL_GOBACK_FAIL

  		EXEC SQL INSERT INTO MT_RED_DET
  		VALUES(:p_mt_instrument_part_red_struct_h:l_mt_instrument_part_red_struct_i);

  		IS_ANY_ORA_ERROR_AND_DUPLICATE(ERR_REC_EXIST,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
   {
      APL_IF_DEBUG
      {
         printf("Mode is MODIFY for Partial Redemption Details.....\n");
         printf("Sequence No is |%d|\n",p_mt_instrument_part_red_struct_h->h_instr_seq_num);
      }

      if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
         APL_GOBACK_FAIL

      strcpy((char *)h_status,STATUS_UAUTH);

      EXEC SQL UPDATE MT_RED_DET
      SET
      RED_DT = :p_mt_instrument_part_red_struct_h->h_red_dt:l_mt_instrument_part_red_struct_i->i_red_dt,
      RED_PCT = :p_mt_instrument_part_red_struct_h->h_red_pct:l_mt_instrument_part_red_struct_i->i_red_pct,
      RED_VALUE = :p_mt_instrument_part_red_struct_h->h_red_value:l_mt_instrument_part_red_struct_i->i_red_value,
      MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_part_red_struct_i->i_maker,
      MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_part_red_struct_i->i_maker_dt,
      ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_part_red_struct_i->i_access_stamp,
      CHECKER = NULL,
      CHECKER_DT = NULL,
      STATUS =:h_status

      WHERE ROWID = :p_row_id_instr;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
   }
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_DELETE) == 0)
	{
		APL_IF_DEBUG
		{
         printf("Mode is DELETE for Partial Redemption Details.....\n");
         printf("Sequence No is |%d|\n",p_mt_instrument_part_red_struct_h->h_instr_seq_num);
		}
		
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
		APL_GOBACK_FAIL
		
		strcpy((char *)h_status,STATUS_DEL_UAUTH);

		EXEC SQL UPDATE MT_RED_DET
		SET
		MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_part_red_struct_i->i_maker,
		MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_part_red_struct_i->i_maker_dt,
		ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_part_red_struct_i->i_access_stamp,
		CHECKER = NULL,
		CHECKER_DT = NULL,
		STATUS   =:h_status

		WHERE ROWID = :p_row_id_instr;
		
		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_RESET) == 0)
	{
		APL_IF_DEBUG
		{
         printf("Mode is RESET for Partial Redemption Details.....\n");
         printf("Sequence No is |%d|\n",p_mt_instrument_part_red_struct_h->h_instr_seq_num);
		}

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
				APL_GOBACK_FAIL

		strcpy((char *)h_status,STATUS_AUTH);
	
		EXEC SQL UPDATE MT_RED_DET
		SET
		CHECKER = :p_intl_env_data_struct_h->usr,
		CHECKER_DT = :chr_h_sys_access_stamp,
		ACCESS_STAMP = :chr_h_sys_access_stamp,
		STATUS   =:h_status

		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_AUTHORISE) == 0)
	{
		APL_IF_DEBUG
		{
         printf("Mode is AUTHORISE for Partial Redemption Details.....\n");
         printf("Sequence No is |%d|\n",p_mt_instrument_part_red_struct_h->h_instr_seq_num);
		}
		
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
			APL_GOBACK_FAIL
	
		EXEC SQL SELECT STATUS
		INTO :h_status
		FROM MT_RED_DET
		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)	
			 APL_GOBACK_FAIL

		if (strcmp(h_status, STATUS_DEL_UAUTH) == 0)
		{
			EXEC SQL DELETE FROM MT_RED_DET
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
		}
		else 
		{
			strcpy((char *)h_status, STATUS_AUTH);
		
			EXEC SQL UPDATE MT_RED_DET
			SET
			CHECKER =:p_intl_env_data_struct_h->usr,
			CHECKER_DT =:chr_h_sys_access_stamp,
			STATUS =:h_status,
			ACCESS_STAMP =:chr_h_sys_access_stamp
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
		}
	}

   int_retval = CR_Mod_UpdMastStatus(  p_key_codes,
                                       p_key_values,
                                       g_mst_table_name,
                                       g_chld_table_names,
                                       APL_CHILD_IND,
                                       p_status,
                                       chr_h_sys_access_stamp,
                                       p_intl_env_data_struct_h,
                                       l_debug_info_ptr);

	APL_IF_DEBUG
	{
        	printf("Returned Status Value = |%s|\n",p_status);
	}
/*ISKB-430 - ASP,Shailesh*/
	if ( APL_FAILURE == IV_Upd_DataGrp(p_key_values[0], p_status, p_intl_env_data_struct_h, l_debug_info_ptr))
	{
		CO_InsertErr(   l_debug_info_ptr,
                   "Error in Updating IV_DATA_GRP",
							p_key_values[0],
							APL_NULL_STRING,
							APL_NULL_STRING,
							__LINE__,
							__FILE__);

		APL_GOBACK_FAIL;
	
	}

   if (int_retval != APL_SUCCESS)
      APL_GOBACK_FAIL

   APL_GOBACK_SUCCESS

	RETURN_SUCCESS :
	{
  		APL_IF_DEBUG
    		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrPartRed with Success\n",NULL,p_intl_env_data_struct_h);
    		return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
  		APL_IF_DEBUG
   		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrPartRed with FAILURE \n",NULL,p_intl_env_data_struct_h);
   		return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrPartRed                                                           *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Partial Redemption Structure,                *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_part_red_struct_h   MT_INSTRUMENT_PART_RED_STRUCT_H  I      Instrument Part Red       *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrPartRed(		MT_INSTRUMENT_PART_RED_STRUCT_H *p_mt_instrument_part_red_struct_h,
										INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
										DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
   struct sqlca   sqlca;
	int      l_instr_count = 0;
   
	APL_IF_DEBUG
   {
      CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrPartRed \n",NULL,NULL);

      printf("Instrument Code = |%s|\n",p_mt_instrument_part_red_struct_h->h_instr_code);
      printf("Sequence No = |%d|\n",p_mt_instrument_part_red_struct_h->h_instr_seq_num);
   }

   sqlca.sqlcode = 0;
   /*In case of Modify Mode, check whether record exists for the instrument code passed*/
   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
   {
      EXEC SQL SELECT NVL(COUNT(*),0) INTO :l_instr_count
               FROM   MT_RED_DET
               WHERE    INSTR_CODE     =:p_mt_instrument_part_red_struct_h->h_instr_code
               AND      INSTR_SEQ_NUM =:p_mt_instrument_part_red_struct_h->h_instr_seq_num;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
    }

    if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
        APL_GOBACK_FAIL

    APL_GOBACK_SUCCESS

    RETURN_SUCCESS :
    {
      APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrPartRed with Success\n",NULL,p_intl_env_data_struct_h);
      return(APL_SUCCESS);
    }

    RETURN_FAILURE :
    {
      APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrPartRed with Failure\n",NULL,p_intl_env_data_struct_h);
    }
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Mod_InstrPTC                                                               *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument PTC Structure, Row Id,                       *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_ptc_struct_h        MT_INSTRUMENT_PTC_STRUCT_H       I      Instrument PTC Details    *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_row_id_instr                      char *                           I      Row Id of Instrument      *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Mod_InstrPTC(		MT_INSTRUMENT_PTC_STRUCT_H *p_mt_instrument_ptc_struct_h,
								char *p_row_id_instr,
								INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
   struct sqlca                     sqlca;
 	int                              int_retval=0;
 	char                             chr_h_sys_access_stamp[APL_DATE_LEN] = APL_NULL_STRING;
   MT_INSTRUMENT_PTC_STRUCT_I   		*l_mt_instrument_ptc_struct_i = NULL;
 	char                             h_status[APL_STATUS_LEN] = APL_NULL_STRING;
 	char                             chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;

 	#ifdef APL_THREADS
    	APL_SET_CONTEXT
    	EXEC SQL CONTEXT USE :my_ctx_local;
 	#endif

   p_key_codes[0] = "INSTR_CODE";
   p_key_codes[1] = APL_NULL_STRING;

   p_key_values[0] = p_mt_instrument_ptc_struct_h->h_instr_code;
	p_key_values[1] = APL_NULL_STRING;

 	APL_IF_DEBUG
 	{
    	CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Mod_InstrPTC \n",NULL,p_intl_env_data_struct_h);
	
    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Instrument Code is |%s| \n",p_mt_instrument_ptc_struct_h->h_instr_code);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);

    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Mode is |%s| \n",p_intl_env_data_struct_h->h_mode);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
 	}

   l_mt_instrument_ptc_struct_i = (MT_INSTRUMENT_PTC_STRUCT_I *)calloc(1,sizeof(MT_INSTRUMENT_PTC_STRUCT_I));
   APL_MALLOC_FAIL(l_mt_instrument_ptc_struct_i)

   /*Initialize Indicator Variables*/
   l_mt_instrument_ptc_struct_i->i_instr_code       		= 0;
 	l_mt_instrument_ptc_struct_i->i_instr_seq_num    		= 0;
   l_mt_instrument_ptc_struct_i->i_ptc_dt					= 0;
   l_mt_instrument_ptc_struct_i->i_ptc_prin_amt      	= 0;
   l_mt_instrument_ptc_struct_i->i_ptc_int_amt  			= 0;
   l_mt_instrument_ptc_struct_i->i_ptc_value      		= 0;
   l_mt_instrument_ptc_struct_i->i_ptc_paid_flg      	= 0;
   l_mt_instrument_ptc_struct_i->i_access_stamp  			= 0;

   if (CO_RtvSysDtTime(chr_h_sys_access_stamp, l_debug_info_ptr) != APL_SUCCESS)
   {
     APL_GOBACK_FAIL
   }
   else
	strcpy(p_mt_instrument_ptc_struct_h->h_access_stamp,chr_h_sys_access_stamp);

   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_INPUT) == 0)
   {
      int_retval = CO_RtvChldNxtSeqNum    (  p_key_codes,
                                             p_key_values,
                                             g_chld_table_names[4],
                                             p_field_name,
                                             &p_next_seq_num,
                                             l_debug_info_ptr);
      if (int_retval != APL_FAILURE)
         p_mt_instrument_ptc_struct_h->h_instr_seq_num = p_next_seq_num;
      else
         APL_GOBACK_FAIL

      APL_IF_DEBUG
      {
         printf("Sequence No Returned = |%d|\n",p_next_seq_num);
         printf("Sequence No Generated = |%d|\n",p_mt_instrument_ptc_struct_h->h_instr_seq_num);
      }
      p_next_seq_num = 0;

  		strcpy(p_mt_instrument_ptc_struct_h->h_status,STATUS_UAUTH);
  		strcpy(p_mt_instrument_ptc_struct_h->h_maker, p_intl_env_data_struct_h->usr);
  		strcpy(p_mt_instrument_ptc_struct_h->h_maker_dt, chr_h_sys_access_stamp);
  		strcpy(p_mt_instrument_ptc_struct_h->h_checker, APL_NULL_STRING);
  		strcpy(p_mt_instrument_ptc_struct_h->h_checker_dt, APL_NULL_STRING);
  		strcpy(p_mt_instrument_ptc_struct_h->h_access_stamp, chr_h_sys_access_stamp);

  		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
     		APL_GOBACK_FAIL

  		EXEC SQL INSERT INTO MT_PTC_DET
  		VALUES(:p_mt_instrument_ptc_struct_h:l_mt_instrument_ptc_struct_i);

  		IS_ANY_ORA_ERROR_AND_DUPLICATE(ERR_REC_EXIST,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
   {
      APL_IF_DEBUG
      {
         printf("Mode is MODIFY for PTC Details.....\n");
         printf("Sequence No is |%d|\n",p_mt_instrument_ptc_struct_h->h_instr_seq_num);
      }

      if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
          APL_GOBACK_FAIL

      strcpy((char *)h_status,STATUS_UAUTH);

      EXEC SQL UPDATE MT_PTC_DET
      SET
      PTC_DT = :p_mt_instrument_ptc_struct_h->h_ptc_dt:l_mt_instrument_ptc_struct_i->i_ptc_dt,
      PTC_PRIN_AMT = :p_mt_instrument_ptc_struct_h->h_ptc_prin_amt:l_mt_instrument_ptc_struct_i->i_ptc_prin_amt,
      PTC_INT_AMT = :p_mt_instrument_ptc_struct_h->h_ptc_int_amt:l_mt_instrument_ptc_struct_i->i_ptc_int_amt,
      PTC_VALUE = :p_mt_instrument_ptc_struct_h->h_ptc_value:l_mt_instrument_ptc_struct_i->i_ptc_value,
      MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_ptc_struct_i->i_maker,
      MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_ptc_struct_i->i_maker_dt,
      ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_ptc_struct_i->i_access_stamp,
      CHECKER = NULL,
      CHECKER_DT = NULL,
      STATUS =:h_status,
      PTC_BAL_VAL =:p_mt_instrument_ptc_struct_h->h_ptc_bal_val:l_mt_instrument_ptc_struct_i->i_ptc_bal_val,
	  PTC_PAID_FLG =:p_mt_instrument_ptc_struct_h->h_ptc_paid_flg:l_mt_instrument_ptc_struct_i->i_ptc_paid_flg /*SKB-242-PTC Paid up flag Issue - RahulC 9-Aug-2007*/

      WHERE ROWID = :p_row_id_instr;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
   }
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_DELETE) == 0)
	{
		APL_IF_DEBUG
		{
         printf("Mode is DELETE for PTC Details.....\n");
         printf("Sequence No is |%d|\n",p_mt_instrument_ptc_struct_h->h_instr_seq_num);
		}
		
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
		APL_GOBACK_FAIL
		
		strcpy((char *)h_status,STATUS_DEL_UAUTH);

		EXEC SQL UPDATE MT_PTC_DET
		SET
		MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_ptc_struct_i->i_maker,
		MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_ptc_struct_i->i_maker_dt,
		ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_ptc_struct_i->i_access_stamp,
		CHECKER = NULL,
		CHECKER_DT = NULL,
		STATUS   =:h_status

		WHERE ROWID = :p_row_id_instr;
		
		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_RESET) == 0)
	{
		APL_IF_DEBUG
		{
         printf("Mode is RESET for PTC Details.....\n");
         printf("Sequence No is |%d|\n",p_mt_instrument_ptc_struct_h->h_instr_seq_num);
		}

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
				APL_GOBACK_FAIL

		strcpy((char *)h_status,STATUS_AUTH);
	
		EXEC SQL UPDATE MT_PTC_DET
		SET
		CHECKER = :p_intl_env_data_struct_h->usr,
		CHECKER_DT = :chr_h_sys_access_stamp,
		ACCESS_STAMP = :chr_h_sys_access_stamp,
		STATUS   =:h_status

		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_AUTHORISE) == 0)
	{
		APL_IF_DEBUG
		{
         printf("Mode is AUTHORISE for PTC Details.....\n");
         printf("Sequence No is |%d|\n",p_mt_instrument_ptc_struct_h->h_instr_seq_num);
		}
		
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
			APL_GOBACK_FAIL
	
		EXEC SQL SELECT STATUS
		INTO :h_status
		FROM MT_PTC_DET
		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)	
			 APL_GOBACK_FAIL

		if (strcmp(h_status, STATUS_DEL_UAUTH) == 0)
		{
			EXEC SQL DELETE FROM MT_PTC_DET
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
		}
		else 
		{
			strcpy((char *)h_status, STATUS_AUTH);
		
			EXEC SQL UPDATE MT_PTC_DET
			SET
			CHECKER =:p_intl_env_data_struct_h->usr,
			CHECKER_DT =:chr_h_sys_access_stamp,
			STATUS =:h_status,
			ACCESS_STAMP =:chr_h_sys_access_stamp
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
		}
	}
   
	int_retval = CR_Mod_UpdMastStatus(  p_key_codes,
                                       p_key_values,
                                       g_mst_table_name,
                                       g_chld_table_names,
                                       APL_CHILD_IND,
                                       p_status,
                                       chr_h_sys_access_stamp,
                                       p_intl_env_data_struct_h,
                                       l_debug_info_ptr);

	APL_IF_DEBUG
	{
        	printf("Returned Status Value = |%s|\n",p_status);
	}
/*ISKB-430 - ASP,Shailesh*/
	if ( APL_FAILURE == IV_Upd_DataGrp(p_key_values[0], p_status, p_intl_env_data_struct_h, l_debug_info_ptr))
	{
		CO_InsertErr(   l_debug_info_ptr,
                   "Error in Updating IV_DATA_GRP",
							p_key_values[0],
							APL_NULL_STRING,
							APL_NULL_STRING,
							__LINE__,
							__FILE__);

		APL_GOBACK_FAIL;
	
	}


   if (int_retval != APL_SUCCESS)
      APL_GOBACK_FAIL

   APL_GOBACK_SUCCESS

	RETURN_SUCCESS :
	{
  		APL_IF_DEBUG
    		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrPTC with Success\n",NULL,p_intl_env_data_struct_h);
    		return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
  		APL_IF_DEBUG
   		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrPTC with FAILURE \n",NULL,p_intl_env_data_struct_h);
   		return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrPTC                                                               *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument PTC Structure, 	                           *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_ptc_struct_h        MT_INSTRUMENT_PTC_STRUCT_H       I      Instrument PTC Details    *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrPTC(		MT_INSTRUMENT_PTC_STRUCT_H *p_mt_instrument_ptc_struct_h,
								INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
   struct sqlca   sqlca;
   int      l_instr_count = 0;
	char		l_ptc_paid_flg[2] = APL_NULL_STRING; 
	short		i_ptc_paid_flg = 0;

	EXEC SQL BEGIN DECLARE SECTION;
			EXEC SQL VAR l_ptc_paid_flg IS STRING;
	EXEC SQL END DECLARE SECTION;
   
	APL_IF_DEBUG
   {
      CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrPTC \n",NULL,NULL);

      printf("Instrument Code = |%s|\n",p_mt_instrument_ptc_struct_h->h_instr_code);
      printf("Sequence No = |%d|\n",p_mt_instrument_ptc_struct_h->h_instr_seq_num);
   }

   sqlca.sqlcode = 0;
   /*In case of Modify Mode, check whether record exists for the instrument code passed*/
   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
   {
      EXEC SQL SELECT NVL(COUNT(*),0) INTO :l_instr_count
               FROM   MT_PTC_DET
               WHERE  INSTR_CODE     	=:p_mt_instrument_ptc_struct_h->h_instr_code
               AND    INSTR_SEQ_NUM 	=:p_mt_instrument_ptc_struct_h->h_instr_seq_num;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

		APL_IF_DEBUG
		{
			printf("Check Paid Up Flag .... \n");
		}

		EXEC SQL SELECT PTC_PAID_FLG INTO :l_ptc_paid_flg:i_ptc_paid_flg
					FROM   MT_PTC_DET
					WHERE  INSTR_CODE       =:p_mt_instrument_ptc_struct_h->h_instr_code
					AND    INSTR_SEQ_NUM    =:p_mt_instrument_ptc_struct_h->h_instr_seq_num;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

		APL_IF_DEBUG
		{
			printf("PTC Paid Up Flag = |%s|\n",l_ptc_paid_flg);
		}

		if (strcmp(l_ptc_paid_flg,"Y") == 0)
		{
			CO_InsertErr	(	l_debug_info_ptr,
									ERR_PTC_PAID_FLG_CANT_MOD,
									APL_NULL_STRING,
									APL_NULL_STRING,
									APL_NULL_STRING,
									__LINE__,
									__FILE__);
		}
   }

   if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
      APL_GOBACK_FAIL

   APL_GOBACK_SUCCESS

   RETURN_SUCCESS :
   {
      APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrPTC with Success\n",NULL,p_intl_env_data_struct_h);
      return(APL_SUCCESS);
   }

   RETURN_FAILURE :
   {
      APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrPTC with Failure\n",NULL,p_intl_env_data_struct_h);
			return(APL_FAILURE);
   }
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Mod_InstrReset                                                             *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Reset Structure, Row Id,                     *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_reset_struct_h      MT_INSTRUMENT_RESET_STRUCT_H     I      Instrument Reset Details  *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_row_id_instr                      char *                           I      Row Id of Instrument      *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Mod_InstrReset(		MT_INSTRUMENT_RESET_STRUCT_H *p_mt_instrument_reset_struct_h,
									char *p_row_id_instr,
									INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
									DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
   struct sqlca                     sqlca;
 	int                              int_retval=0;
 	char                             chr_h_sys_access_stamp[APL_DATE_LEN] = APL_NULL_STRING;
   MT_INSTRUMENT_RESET_STRUCT_I   	*l_mt_instrument_reset_struct_i = NULL;
 	char                             h_status[APL_STATUS_LEN] = APL_NULL_STRING;
 	char                             chr_l_buf[BUFFER_LEN] = APL_NULL_STRING;

 	#ifdef APL_THREADS
    	APL_SET_CONTEXT
    	EXEC SQL CONTEXT USE :my_ctx_local;
 	#endif

   p_key_codes[0] = "INSTR_CODE";
   p_key_codes[1] = APL_NULL_STRING;

   p_key_values[0] = p_mt_instrument_reset_struct_h->h_instr_code;
	p_key_values[1] = APL_NULL_STRING;

 	APL_IF_DEBUG
 	{
    	CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Mod_InstrReset \n",NULL,p_intl_env_data_struct_h);
	
    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Instrument Code is |%s| \n",p_mt_instrument_reset_struct_h->h_instr_code);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);

    	memset(chr_l_buf,APL_NULL_CHAR,BUFFER_LEN);
    	sprintf(chr_l_buf,"Mode is |%s| \n",p_intl_env_data_struct_h->h_mode);
    	CO_ProcMonitor(APL_OUT_FILE,chr_l_buf,NULL,p_intl_env_data_struct_h);
 	}

   l_mt_instrument_reset_struct_i = (MT_INSTRUMENT_RESET_STRUCT_I *)calloc(1,sizeof(MT_INSTRUMENT_RESET_STRUCT_I));
   APL_MALLOC_FAIL(l_mt_instrument_reset_struct_i)

   /*Initialize Indicator Variables*/
   l_mt_instrument_reset_struct_i->i_instr_code       	= 0;
   l_mt_instrument_reset_struct_i->i_instr_seq_num    	= 0;
   l_mt_instrument_reset_struct_i->i_reset_dt  			= 0;
   l_mt_instrument_reset_struct_i->i_reset_rate      	= 0;
   l_mt_instrument_reset_struct_i->i_reset_frdt  			= 0;
   l_mt_instrument_reset_struct_i->i_reset_todt      	= 0;
   l_mt_instrument_reset_struct_i->i_access_stamp  		= 0;

   if (CO_RtvSysDtTime(chr_h_sys_access_stamp, l_debug_info_ptr) != APL_SUCCESS)
   {
      APL_GOBACK_FAIL
   }
   else
	strcpy(p_mt_instrument_reset_struct_h->h_access_stamp,chr_h_sys_access_stamp);

   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_INPUT) == 0)
   {
      int_retval = CO_RtvChldNxtSeqNum    (  p_key_codes,
                                             p_key_values,
                                             g_chld_table_names[6],
                                             p_field_name,
                                             &p_next_seq_num,
                                             l_debug_info_ptr);
      if (int_retval != APL_FAILURE)
         p_mt_instrument_reset_struct_h->h_instr_seq_num = p_next_seq_num;
      else
         APL_GOBACK_FAIL

      APL_IF_DEBUG
      {
         printf("Sequence No Returned = |%d|\n",p_next_seq_num);
         printf("Sequence No Generated = |%d|\n",p_mt_instrument_reset_struct_h->h_instr_seq_num);
      }
      p_next_seq_num = 0;
  		strcpy(p_mt_instrument_reset_struct_h->h_status,STATUS_UAUTH);
  		strcpy(p_mt_instrument_reset_struct_h->h_maker, p_intl_env_data_struct_h->usr);
  		strcpy(p_mt_instrument_reset_struct_h->h_maker_dt, chr_h_sys_access_stamp);
  		strcpy(p_mt_instrument_reset_struct_h->h_checker, APL_NULL_STRING);
  		strcpy(p_mt_instrument_reset_struct_h->h_checker_dt, APL_NULL_STRING);
  		strcpy(p_mt_instrument_reset_struct_h->h_access_stamp, chr_h_sys_access_stamp);

  		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
     		APL_GOBACK_FAIL

  		EXEC SQL INSERT INTO MT_RESET_DET
  		VALUES(:p_mt_instrument_reset_struct_h:l_mt_instrument_reset_struct_i);

  		IS_ANY_ORA_ERROR_AND_DUPLICATE(ERR_REC_EXIST,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
   {
      APL_IF_DEBUG
      {
         printf("Mode is MODIFY for Reset Details.....\n");
         printf("Sequence Number is |%d|\n",p_mt_instrument_reset_struct_h->h_instr_seq_num);
      }

      if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
         APL_GOBACK_FAIL

      strcpy((char *)h_status,STATUS_UAUTH);

      EXEC SQL UPDATE MT_RESET_DET
      SET
      RESET_DT = :p_mt_instrument_reset_struct_h->h_reset_dt:l_mt_instrument_reset_struct_i->i_reset_dt,
      RESET_RATE =:p_mt_instrument_reset_struct_h->h_reset_rate:l_mt_instrument_reset_struct_i->i_reset_rate,
      RESET_FRDT =:p_mt_instrument_reset_struct_h->h_reset_frdt:l_mt_instrument_reset_struct_i->i_reset_frdt,
      RESET_TODT =:p_mt_instrument_reset_struct_h->h_reset_todt:l_mt_instrument_reset_struct_i->i_reset_todt,
      MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_reset_struct_i->i_maker,
      MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_reset_struct_i->i_maker_dt,
      ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_reset_struct_i->i_access_stamp,
      CHECKER = NULL,
      CHECKER_DT = NULL,
      STATUS =:h_status

      WHERE ROWID = :p_row_id_instr;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
   }

	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_DELETE) == 0)
	{
		APL_IF_DEBUG
		{
         printf("Mode is DELETE for Reset Details.....\n");
         printf("Sequence Number is |%d|\n",p_mt_instrument_reset_struct_h->h_instr_seq_num);
		}
		
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
		APL_GOBACK_FAIL
		
		strcpy((char *)h_status,STATUS_DEL_UAUTH);

		EXEC SQL UPDATE MT_RESET_DET
		SET
		MAKER = :p_intl_env_data_struct_h->usr:l_mt_instrument_reset_struct_i->i_maker,
		MAKER_DT = :chr_h_sys_access_stamp:l_mt_instrument_reset_struct_i->i_maker_dt,
		ACCESS_STAMP = :chr_h_sys_access_stamp:l_mt_instrument_reset_struct_i->i_access_stamp,
		CHECKER = NULL,
		CHECKER_DT = NULL,
		STATUS   =:h_status

		WHERE ROWID = :p_row_id_instr;
		
		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_RESET) == 0)
	{
		APL_IF_DEBUG
		{
         printf("Mode is RESET for Reset Details.....\n");
         printf("Sequence Number is |%d|\n",p_mt_instrument_reset_struct_h->h_instr_seq_num);
		}

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
				APL_GOBACK_FAIL

		strcpy((char *)h_status,STATUS_AUTH);
	
		EXEC SQL UPDATE MT_RESET_DET
		SET
		CHECKER = :p_intl_env_data_struct_h->usr,
		CHECKER_DT = :chr_h_sys_access_stamp,
		ACCESS_STAMP = :chr_h_sys_access_stamp,
		STATUS   =:h_status

		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
	}
	else if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_AUTHORISE) == 0)
	{
		APL_IF_DEBUG
		{
         printf("Mode is AUTHORISE for Reset Details.....\n");
         printf("Sequence Number is |%d|\n",p_mt_instrument_reset_struct_h->h_instr_seq_num);
		}
		
		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
			APL_GOBACK_FAIL
	
		EXEC SQL SELECT STATUS
		INTO :h_status
		FROM MT_RESET_DET
		WHERE ROWID = :p_row_id_instr;

		IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

		if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)	
			 APL_GOBACK_FAIL

		if (strcmp(h_status, STATUS_DEL_UAUTH) == 0)
		{
			EXEC SQL DELETE FROM MT_RESET_DET
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
		}
		else 
		{
			strcpy((char *)h_status, STATUS_AUTH);
		
			EXEC SQL UPDATE MT_RESET_DET
			SET
			CHECKER =:p_intl_env_data_struct_h->usr,
			CHECKER_DT =:chr_h_sys_access_stamp,
			STATUS =:h_status,
			ACCESS_STAMP =:chr_h_sys_access_stamp
			WHERE ROWID = :p_row_id_instr;

			IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
		}
	}
         
	int_retval = CR_Mod_UpdMastStatus(  p_key_codes,
                                       p_key_values,
                                       g_mst_table_name,
                                       g_chld_table_names,
                                       APL_CHILD_IND,
                                       p_status,
                                       chr_h_sys_access_stamp,
                                       p_intl_env_data_struct_h,
                                       l_debug_info_ptr);

	APL_IF_DEBUG
	{
        	printf("Returned Status Value = |%s|\n",p_status);
	}
/*ISKB-430 - ASP,Shailesh*/
	if ( APL_FAILURE == IV_Upd_DataGrp(p_key_values[0], p_status, p_intl_env_data_struct_h, l_debug_info_ptr))
	{
		CO_InsertErr(   l_debug_info_ptr,
                   "Error in Updating IV_DATA_GRP",
							p_key_values[0],
							APL_NULL_STRING,
							APL_NULL_STRING,
							__LINE__,
							__FILE__);

		APL_GOBACK_FAIL;
	
	}


   if (int_retval != APL_SUCCESS)
      APL_GOBACK_FAIL

   APL_GOBACK_SUCCESS

	RETURN_SUCCESS :
	{
  		APL_IF_DEBUG
    		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrReset with Success\n",NULL,p_intl_env_data_struct_h);
    		return(APL_SUCCESS);
	}

	RETURN_FAILURE :
	{
  		APL_IF_DEBUG
   		CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Mod_InstrReset with FAILURE \n",NULL,p_intl_env_data_struct_h);
   		return(APL_FAILURE);
	}
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_Chk_InstrReset                                                             *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Reset Structure,                             *
 *                         Env String and debug pointer.                                                 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_mt_instrument_reset_struct_h      MT_INSTRUMENT_RESET_STRUCT_H     I      Instrument Reset Details  *
 *                                                                             Structure                 *
 *                                                                                                       *
 * p_intl_env_data_struct_h_d          INTL_ENV_DATA_STRUCT_H *         I      Environment String        *
 *                                                                             Structure                 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_Chk_InstrReset(		MT_INSTRUMENT_RESET_STRUCT_H *p_mt_instrument_reset_struct_h,
									INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
									DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
   struct sqlca   sqlca;
   int      l_instr_count = 0;
   
	APL_IF_DEBUG
   {
      CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_Chk_InstrReset \n",NULL,NULL);

      printf("Instrument Code = |%s|\n",p_mt_instrument_reset_struct_h->h_instr_code);
      printf("Sequence No = |%d|\n",p_mt_instrument_reset_struct_h->h_instr_seq_num);
   }

   sqlca.sqlcode = 0;
   /*In case of Modify Mode, check whether record exists for the instrument code passed*/
   if (strcmp(p_intl_env_data_struct_h->h_mode,APL_FUNC_MODIFY) == 0)
   {
      EXEC SQL SELECT NVL(COUNT(*),0) INTO :l_instr_count
               FROM   MT_RESET_DET
               WHERE    INSTR_CODE     =:p_mt_instrument_reset_struct_h->h_instr_code
               AND      INSTR_SEQ_NUM =:p_mt_instrument_reset_struct_h->h_instr_seq_num;

      IS_ANY_ORA_ERROR_AND_ZERO_RESULTSET(ERR_REC_NOTFND,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)
   }

   if (CO_ChkErr(*l_debug_info_ptr) == APL_SUCCESS)
      APL_GOBACK_FAIL

   APL_GOBACK_SUCCESS

   RETURN_SUCCESS :
   {
     APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrReset with Success\n",NULL,p_intl_env_data_struct_h);
      return(APL_SUCCESS);
   }

   RETURN_FAILURE :
   {
      APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_Chk_InstrReset with Failure\n",NULL,p_intl_env_data_struct_h);
			return(APL_FAILURE);
   }
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_ChkInstrNomVal                                                             *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code,Env String  and debug pointer.				*
 *                         Gets Nominal Value for the given Instrument and compares with Redemption Value*
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_red_value							double									I		 Redemption  Value			*
 *																																			*
 * p_instr_code                        char *                           I      Instrument Code           *
 *                                                                                                       *
 * p_intl_env_data_struct_h				INTL_ENV_DATA_STRUCT_H *			I		 Environment String			*
 *																																		   *		
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_ChkInstrNomVal(	double p_instr_red_value,
								char *p_instr_code,
								INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
								DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
   double  p_instr_nom_val = 0;

  	CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_ChkInstrNomVal\n",NULL,p_intl_env_data_struct_h);

 	APL_IF_DEBUG
	{	
		printf("Redemption Value = |%lf|\n",p_instr_red_value);
		printf("Instr code = |%s|\n",p_instr_code);
	}

	EXEC SQL SELECT NVL(NOMINAL_VALUE,0) INTO :p_instr_nom_val
				FROM MT_INSTRUMENT
				WHERE INSTR_CODE = :p_instr_code;

	IS_ANY_ORA_ERROR

	if (p_instr_red_value > p_instr_nom_val)
	{
		APL_GOBACK_FAIL
	}
		
	APL_GOBACK_SUCCESS

   RETURN_SUCCESS :
   {
      APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_ChkInstrNomVal with Success\n",NULL,p_intl_env_data_struct_h);
      return(APL_SUCCESS);
   }

   RETURN_FAILURE :
   {
      APL_IF_DEBUG
         CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_ChkInstrNomVal with Failure\n",NULL,p_intl_env_data_struct_h);
         return(APL_FAILURE);
   }
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_ChkPTCVal	                                                               *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument PTC Value,PTC Principal Amt, Interest Amt, 	*
 *									Env String and debug pointer.            													*
 *                         Checks whether Instrument PTC Val = Principal+Interest.			               *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_ptc_value							double									I		 PTC Value                 *
 *																																			*
 * p_instr_ptc_prin							double									I		 PTC Principal					*
 *																																			*
 *	p_instr_ptc_int							double									I		 PTC Interest					*
 *																																		   *
 * p_intl_env_data_struct_h				INTL_ENV_DATA_STRUCT_H *			I		 Environment Structure		*
 *																																			*	
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_ChkPTCVal(	double p_instr_ptc_value,
						double p_instr_ptc_prin,
						double p_instr_ptc_int,
						INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
						DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_ChkPTCVal\n",NULL,p_intl_env_data_struct_h);	

	APL_IF_DEBUG
	{
		printf("PTC Value = |%lf|\n",p_instr_ptc_value);
		printf("PTC Principal = |%lf|\n",p_instr_ptc_prin);
		printf("PTC Interest = |%lf|\n",p_instr_ptc_int);
	}

	if ((float)(p_instr_ptc_prin + p_instr_ptc_int) != (float)p_instr_ptc_value)  /*SKB-242-Two Decimal point in Amount field Issue - RahulC 9-Aug-2007*/
	{
		APL_GOBACK_FAIL
	}

	APL_GOBACK_SUCCESS

   RETURN_SUCCESS :
   {
       APL_IF_DEBUG
	     	CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_ChkPTCVal with Success\n",NULL,p_intl_env_data_struct_h);
       	return(APL_SUCCESS);
   }

   RETURN_FAILURE :
   {
       APL_IF_DEBUG
        	CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_ChkPTCVal with Failure\n",NULL,p_intl_env_data_struct_h);
        	return(APL_FAILURE);
   }
}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : CR_ChkPTCValNomVal                                                            *
 *                                                                                                       *
 * Description           : This Function Accepts Instrument Code,Instrument PTC Value,		 	 *
 *		 	   Env String and debug pointer.            					 *
 *                         Checks whether Instrument PTC Val = Principal+Interest.			 *
 *                         returns Success/Failure depending upon validn.                                *
 *                                                                                                       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_instr_code			       char *				I	 Instrument Code         										*
 *													 																						*
 * p_instr_ptc_value		       double				I	 PTC Value               										*
 * p_instr_seq_num		       int					I	 Seq Num		             										*
 *													 																						*
 * p_intl_env_data_struct_h	       INTL_ENV_DATA_STRUCT_H *		I	 Environment Structure	 				*
 *													 																						*	
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/
int CR_ChkPTCValNomVal(	char* p_instr_code,
			double p_instr_ptc_value,
			double p_instr_ptc_prin_amt,/*ISKB-242 PTC Prin. Amt & Nominal Val comarision - Rahul 22-Aug-2007 */
			int p_instr_seq_num,
			INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
			DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	double l_instr_total_nom_value =0;
	double l_instr_total_ptc_value = 0;
	double l_instr_tot_ptc_val = 0;
	double l_instr_total_prnc_value = 0; /* Change:Check Principle Amt < Nom Val :06/11/2006 */ 
	CO_ProcMonitor(APL_OUT_FILE,"Entered Process CR_ChkPTCValNomVal",NULL,p_intl_env_data_struct_h);	

	APL_IF_DEBUG
	{
		printf("Instrument Code = |%s|\n",p_instr_code);
		printf("PTC Value = |%lf|\n",p_instr_ptc_value);
		printf("SEQ Num = |%d|\n",p_instr_seq_num);
	}
	
	/* ISKB-242 : ASHISH 11-09-2007 Start */
	IF_COND_EXISTS("MT_PTC","PTC_PRINC>NOMINAL")
	{
	EXEC SQL SELECT NVL(NOMINAL_VALUE,0) INTO :l_instr_total_nom_value
		 FROM MT_INSTRUMENT
		 WHERE INSTR_CODE =:p_instr_code;
	  printf("\n Error to calculate nominal value = |%d| \n",sqlca.sqlcode);
	  IS_ANY_ORA_ERROR;
	  printf("\n Nominal value of Instrument %s = |%lf| \n",p_instr_code,l_instr_total_nom_value);
	}

	else IF_COND_EXISTS("MT_PTC","PTC_PRINC>TOTAL_FACE_VAL")
	{
	  EXEC SQL SELECT NVL(INSTR_TOT_NOM_VAL,0) INTO :l_instr_total_nom_value
	           FROM MT_INSTRUMENT
		       WHERE INSTR_CODE =:p_instr_code;
	  printf("\n Error to calculate total nominal value = |%d| \n",sqlca.sqlcode);
	IS_ANY_ORA_ERROR;
	  printf("\n Total Nominal value of Instrument %s = |%lf| \n",p_instr_code,l_instr_total_nom_value);
	}
    /* ISKB-242 : ASHISH 11-09-2007 End */

	/*	Addition of Sequence no to calculate instrument's total PTC value UAT Rohit	*/
	EXEC SQL SELECT NVL(SUM(PTC_VALUE),0) INTO :l_instr_total_ptc_value
		 FROM MT_PTC_DET 
		 WHERE INSTR_CODE =:p_instr_code
		 AND INSTR_SEQ_NUM !=:p_instr_seq_num;

	IS_ANY_ORA_ERROR;
	/* Change:Check Principle Amt < Nom Val :06/11/2006 */ 
	EXEC SQL SELECT NVL(SUM(PTC_PRIN_AMT),0) INTO :l_instr_total_prnc_value
		 FROM MT_PTC_DET 
		 WHERE INSTR_CODE =:p_instr_code
		 AND INSTR_SEQ_NUM !=:p_instr_seq_num;

	IS_ANY_ORA_ERROR;

	APL_IF_DEBUG
	{
		printf("Total Principle Value from table = |%lf|\n",l_instr_total_prnc_value);
		printf("Nominal Value from table = |%lf|\n",l_instr_total_nom_value);
		printf("Total PTC Values from table = |%lf|\n",l_instr_total_ptc_value);
	}

	l_instr_tot_ptc_val = l_instr_total_ptc_value + p_instr_ptc_value;

	APL_IF_DEBUG
	{
		printf("Sum of PTC Values already Existing = |%lf|\n",l_instr_total_ptc_value);
		printf("PTC Value to be inserted = |%lf|\n",p_instr_ptc_value);
		printf("Total PTC Value = |%lf|\n",l_instr_tot_ptc_val);
	}

	l_instr_total_prnc_value =  l_instr_total_prnc_value + p_instr_ptc_prin_amt;/*ISKB-242 PTC Prin. Amt & Nominal Val comarision - Rahul 22-Aug-2007 */ 
	/* Change:Check Principle Amt < Nom Val :06/11/2006 */ 
	IF_COND_EXISTS("MT_PTC","PTC_PRINC>NOMINAL")
	{
		if(l_instr_total_nom_value < l_instr_total_prnc_value)
		{
			APL_GOBACK_FAIL
		}
	}

	/* ISKB-242 : PTC Principal amount should not be greater than Total Face Value : ASHISH 11-09-2007 */
	else IF_COND_EXISTS("MT_PTC","PTC_PRINC>TOTAL_FACE_VAL")
	{
		if(l_instr_total_nom_value < l_instr_total_prnc_value)
		{
			APL_GOBACK_FAIL
		}
	}

	else
	{
		if(l_instr_total_nom_value < l_instr_tot_ptc_val)
		{
			APL_GOBACK_FAIL
		}
	}
	
	APL_GOBACK_SUCCESS

   RETURN_SUCCESS :
   {
       APL_IF_DEBUG
	     	CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_ChkPTCValNomVal with Success\n",NULL,p_intl_env_data_struct_h);
       	return(APL_SUCCESS);
   }

   RETURN_FAILURE :
   {
       APL_IF_DEBUG
        	CO_ProcMonitor(APL_OUT_FILE,"Leaving Process CR_ChkPTCValNomVal with Failure\n",NULL,p_intl_env_data_struct_h);
        	return(APL_FAILURE);
   }
}

/* Bageshri for updating Instrument ALL group for Billing -- START */
/*ISKB-430 - ASP,Shailesh*/
/******************************************************************************************
 *                                                                                        *
 * Function Name         : IV_Upd_DataGrp						*
 *                                                                                        *
 * Description           : This Function Accepts instr code(Primary Keys), its new status,*
 *                         environmental data struct, debug pointer.  						*
 *                         returns Success/Failure depending upon validn.                 *
 *                                                                                        *
 *                                                                                        *
 * Parameter                  Type                       Mode     Description             *
 * ------------               --------                   -----    ---------------         *
 * p_instr_code			char *                     I        instr code value	*
 *                                                                	                  *
 * p_status			char *                     I         its status after processing *
 *                                                                these details.          *
 * p_chld_table_name          INTL_ENV_DATA_STRUCT_H *     I         env data struct	*
 *                                                                                        *
 * l_debug_info_ptr     DEBUG_INFO_STRUCT_H **           I        Debug Info Structure    *
 *                                                                                        *
 * Return Values        :                                                                 *
 *                                                                                        *
 *  APL_SUCCESS  - SUCCESS                                                                *
 *  APL_FAILURE  - FAILURE                                                                *
 *                                                                                        *
 ******************************************************************************************/

int IV_Upd_DataGrp ( 	char* p_instr_code,
			char* p_status,
			INTL_ENV_DATA_STRUCT_H *p_intl_env_data_struct_h,
			DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
   EXEC SQL BEGIN DECLARE SECTION;

	int h_count = 0;
	short i_count = 0;

	char chr_l_param_cd[11] = APL_NULL_STRING;
	char chr_l_grp_prm_cd[4] = APL_NULL_STRING;

   EXEC SQL VAR chr_l_param_cd IS STRING;
   EXEC SQL VAR chr_l_grp_prm_cd IS STRING;

   EXEC SQL END DECLARE SECTION;

   #ifdef APL_THREADS
      APL_SET_CONTEXT
      EXEC SQL CONTEXT USE :my_ctx_local;
   #endif

	APL_IF_DEBUG
		CO_ProcMonitor(APL_OUT_FILE,"Entered Process IV_Upd_DataGrp \n",NULL,p_intl_env_data_struct_h);

   memset(chr_l_param_cd,APL_NULL_CHAR,sizeof(chr_l_param_cd));
   memset(chr_l_grp_prm_cd,APL_NULL_CHAR,sizeof(chr_l_grp_prm_cd));

   strcpy(chr_l_param_cd,IV_INSTR_PARAM_CD);
   strcpy(chr_l_grp_prm_cd,IV_INSTR_GRP_PARAM_CD);

	APL_IF_DEBUG
		printf("\ngetting count from IV_DATA_GRP : |%s|,|%s|,|%s|",chr_l_param_cd,chr_l_grp_prm_cd,p_instr_code);

	EXEC SQL SELECT COUNT(*) INTO :h_count:i_count
		FROM IV_DATA_GRP
		WHERE PARAMETER_CD = :chr_l_param_cd
		AND GROUP_PRM_CD = :chr_l_grp_prm_cd
		AND GROUP_MEM_VAL = :p_instr_code;

  	IS_ANY_ORA_ERROR

	Alert("h_count |%d| p_status |%s|",h_count,p_status);
		if(!strcmp(p_status,STATUS_AUTH))
		{
			if(h_count == 0)
			{
   				APL_IF_DEBUG
      					printf("\nInserting into IV_DATA_GRP : |%s|,|%s|,|%s|",chr_l_param_cd,chr_l_grp_prm_cd,p_instr_code);

				EXEC SQL INSERT INTO IV_DATA_GRP values(:chr_l_param_cd,:chr_l_grp_prm_cd,:p_instr_code);
	
   				IS_ANY_ORA_ERROR
			}
		}
		else
		{
			if(h_count == 1)
			{
   				APL_IF_DEBUG
      					printf("\nDeleting from IV_DATA_GRP : |%s|,|%s|,|%s|",chr_l_param_cd,chr_l_grp_prm_cd,p_instr_code);

				EXEC SQL DELETE FROM IV_DATA_GRP 
                			WHERE PARAMETER_CD = :chr_l_param_cd
                			AND GROUP_PRM_CD = :chr_l_grp_prm_cd
                			AND GROUP_MEM_VAL = :p_instr_code;
	
   				IS_ANY_ORA_ERROR
			}
		}
	RETURN_SUCCESS :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process IV_Upd_DataGrp \n",NULL,p_intl_env_data_struct_h);
		return(APL_SUCCESS);
	}
	
	RETURN_FAILURE :
	{
		APL_IF_DEBUG
			CO_ProcMonitor(APL_OUT_FILE,"Leaving Process IV_Upd_DataGrp \n",NULL,p_intl_env_data_struct_h);
		return(APL_FAILURE);
	}

}

/* Bageshri for updating Instrument ALL group for Billing -- END */
