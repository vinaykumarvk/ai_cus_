/*
 *    COPYRIGHT NOTICE
 *
 *   Copyright 2005 Polaris Software Lab Limited. All rights reserved.
 *
 *   These materials are confidential and proprietary to
 *    Polaris Software Lab Limited and no part of these materials should
 *    be reproduced, published, transmitted or distributed in any form or
 *    by any means, electronic, mechanical, photocopying, recording or
 *    otherwise, or stored in any information storage or retrieval system
 *    of any nature nor should the materials be disclosed to third parties
 *    or used in any other manner for which this is not authorized, without
 *    the prior express written authorization of Polaris Software Lab Limited.
 */
/*********************************************************************
 *
 * Module Name         : Utility
 *
 * File Name           : GF_Upload.pc
 *
 * Description         : Main file for Generic File Upload processing.
 *
 *
 *
 *            Version Control Block
 *
 * Date        Version          Author               Description
 * ---------   --------  ---------------  ---------------------------
 * 07/12/2005  1.0		 Biju George		Generic File Upload Main 
 *											          Functions
 * 29/03/2006  1.1       Amol Kulkarni    Functions Added
 * 24/03/2022  1.2       kotubabu         Linux Migration    Kotak Implementation
 *
 *********************************************************************/
 

#include "stdio_64.h"
#include <unistd.h>
/*** AIX Migration Changes -START*/
/*#include <sys/iso/signal_iso.h>*/
#if !defined(_AIXVERSION_430) || !defined(_AIXVERSION_431) || !defined(_AIXVERSION_434) || !defined(_AIXVERSION_510) || !defined(_AIXVERSION_520) || !defined(_AIXVERSION_530) || !defined(_AIXVERSION_610)
//#include <sys/iso/signal_iso.h>
#ifdef OS_LINUX                    /* Added by kotubabu for Linux Migration*/
      #include <bits/signum.h>
   #else
#include <sys/iso/signal_iso.h>
#endif
#endif
/*** AIX Migration Changes -END*/
#include <sys/wait.h>
#include <ctype.h>
#include <GF_Common_mig.h>
#include <BT_Common.h>
#include <oci.h> /* Added by Kalyan*/
EXEC SQL INCLUDE SQLCA.H;
#define MAIN_ARG \
{\
	int i =0;\
	for(i = 0;i<argc;i++)\
	{\
		printf("Arguement\t[%d]\t=\t[%s]\n",i,argv[i]);\
	}\
}
#define MICRO_SECONDS 110000


/* Added bykotubabu for Linux Migration-START*/
#ifdef OS_LINUX
FILE *l_logfile; 
FILE *l_skipped_file;
FILE *l_userfile;
FILE *l_format_file;
FILE *l_bk_file;
FILE *l_faillog;
FILE *l_statvallog;
#else
FILE *l_logfile = APL_OUT_FILE;
FILE *l_skipped_file= APL_OUT_FILE;
FILE *l_userfile= APL_OUT_FILE;
FILE *l_format_file = APL_OUT_FILE;
FILE *l_bk_file = APL_OUT_FILE;
FILE *l_faillog = APL_OUT_FILE;
FILE *l_statvallog = APL_OUT_FILE;
#endif
/* Added by kotubabu for Linux Migration -END*/


/*
FILE *l_failurelog= APL_OUT_FILE;

*/

char g_file_name[GFU_FILE_NAME_LEN];
char g_param_data[2000];
char g_sys_date[APL_DATE_LEN];
char g_line[GFU_LINE_LEN] = APL_NULL_STRING;
GFU_FILE_MAP_STRUCT_H *g_gfu_file_map_h = (GFU_FILE_MAP_STRUCT_H *)NULL;

int Rtv_C_E_T(char *p_file_type,
					char *p_refno,
					C_E_T_STRUCT_H **p_c_e_t_struct_h,
					DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;
	char l_label[500];
	char l_seq[500];
	short i_label,i_seq;
	int l_start_pos = 0, l_end_pos = 0;
	C_E_T_STRUCT_H **l_temp_ptr = p_c_e_t_struct_h;

	APL_FUNCTION_ENTER(l_logfile)
		sqlca.sqlcode=0;
	if(!strcmp(p_file_type,CSV))
	{
		/**printf(" p_refno is %s\n",p_refno);**/
		EXEC SQL DECLARE l_rtv_csv_cur CURSOR
				FOR
				SELECT CSV_FIELD_NAME, CSV_REFERENCE_VALUE
				FROM MT_GFU_CSV_SETUP
				WHERE	REF_NO = :p_refno
				AND STATUS = 'AA';
		/**printf("\n\nError Code%d",sqlca.sqlcode);**/
		IS_ANY_ORA_ERROR
		EXEC SQL OPEN l_rtv_csv_cur;
		IS_ANY_ORA_ERROR

	}
	else if(!strcmp(p_file_type,EXCEL))
	{
		EXEC SQL DECLARE l_rtv_exl_cur CURSOR
				FOR
				SELECT EXCEL_FIELD_NAME,
						EXCEL_REFERENCE_VALUE
				FROM mt_gfu_excel_setup
				WHERE REF_NO = :p_refno
				AND STATUS = 'AA';
		IS_ANY_ORA_ERROR
		EXEC SQL OPEN l_rtv_exl_cur;
		IS_ANY_ORA_ERROR
		

	}
	else if(!strcmp(p_file_type,TEXT))
	{
		EXEC SQL DECLARE l_rtv_txt_cur CURSOR
				FOR
				SELECT TXT_FIELD_NAME,
						NVL(START_POS,0),
						NVL(END_POS,0)
				FROM mt_gfu_txt_setup
				WHERE REF_NO = :p_refno
				AND STATUS = 'AA';
		IS_ANY_ORA_ERROR
		EXEC SQL OPEN l_rtv_txt_cur;
		IS_ANY_ORA_ERROR

	}

	for(;;)
	{
		memset(l_label,APL_NULL_CHAR,sizeof(l_label));
		memset(l_seq,APL_NULL_CHAR,sizeof(l_seq));
		i_label = 0; i_seq = 0; l_start_pos = 0; l_end_pos = 0;
		if(!strcmp(p_file_type,CSV))
		{
			EXEC SQL FETCH l_rtv_csv_cur
						INTO :l_label:i_label,
							  :l_seq:i_seq;
			IS_ANY_ORA_ERROR
		}	
		else if(!strcmp(p_file_type,EXCEL))
		{
			EXEC SQL FETCH l_rtv_exl_cur
						INTO :l_label:i_label,
							  :l_seq:i_seq;
			IS_ANY_ORA_ERROR
		}
		else if(!strcmp(p_file_type,TEXT))
		{
			EXEC SQL FETCH l_rtv_txt_cur
						INTO :l_label:i_label,
							  :l_start_pos,
							  :l_end_pos;
			IS_ANY_ORA_ERROR
		}
		/**printf("sqlca.sqlcode |%d|\n",sqlca.sqlcode);**/
		if(sqlca.sqlcode == 1403)break;

		while((*l_temp_ptr) != (C_E_T_STRUCT_H *)NULL)
		{
			l_temp_ptr = &((*l_temp_ptr)->h_next);
		}
		if(((*l_temp_ptr) = (C_E_T_STRUCT_H *)calloc(1,sizeof(C_E_T_STRUCT_H))) == NULL)
		{
			APL_GOBACK_FAIL
		}
		strcpy((*l_temp_ptr) -> h_label,l_label);
		strcpy((*l_temp_ptr) -> h_seq,l_seq);
		(*l_temp_ptr) -> h_start_pos	=	l_start_pos;
		(*l_temp_ptr) -> h_end_pos	=	l_end_pos;
		(*l_temp_ptr) -> h_next = NULL;

	}
		if(!strcmp(p_file_type,CSV))
		{
			EXEC SQL CLOSE l_rtv_csv_cur;

		}	
		else if(!strcmp(p_file_type,EXCEL))
		{
			EXEC SQL CLOSE l_rtv_exl_cur;
			IS_ANY_ORA_ERROR
		}
		else if(!strcmp(p_file_type,TEXT))
		{
			EXEC SQL CLOSE l_rtv_txt_cur;
			IS_ANY_ORA_ERROR
		}

APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}


int Add_Rpl_Format_Lst(char *p_file_type,
							 	GFU_FORMAT_MAP_STRUCT_LST **p_gfu_format_map_lst,
							 C_E_T_STRUCT_H **p_c_e_t_struct_h,
							 DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	C_E_T_STRUCT_H **l_temp_cet = p_c_e_t_struct_h ;
	GFU_FORMAT_MAP_STRUCT_LST **l_temp_format;

	APL_FUNCTION_ENTER(l_logfile)
	while(*l_temp_cet)
	{
		l_temp_format = p_gfu_format_map_lst;
		while(*l_temp_format)
		{
			if(!strcmp((*l_temp_format) -> h_label , (*l_temp_cet)->h_label))
			{
				strcpy((*l_temp_format) -> h_seq,(*l_temp_cet)->h_seq);
				strcpy((*l_temp_format) -> h_start,ltoa((*l_temp_cet)->h_start_pos));
				strcpy((*l_temp_format) -> h_end,ltoa((*l_temp_cet)->h_end_pos));
			}
			l_temp_format = &((*l_temp_format)->h_next);
		}
		l_temp_cet = &((*l_temp_cet)->h_next);
	}

APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)


}
int Process_C_E_T(	GFU_FORMAT_MAP_STRUCT_LST **p_gfu_format_map_lst,
							char *p_refno,
							char *p_module,
							char *p_vendor,
							DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;
	C_E_T_STRUCT_H **l_c_e_t_struct_h = (C_E_T_STRUCT_H **)NULL;
	C_E_T_STRUCT_H *l_c_e_t_struct_free = (C_E_T_STRUCT_H *)NULL;
	char l_file_type[4] = APL_NULL_STRING;

	l_c_e_t_struct_h = (C_E_T_STRUCT_H **) calloc(1,sizeof(C_E_T_STRUCT_H *));

	APL_FUNCTION_ENTER(l_logfile)
	/*Changes done by AMOL*/
/*
	EXEC SQL SELECT FILE_TYPE
				INTO :l_file_type
				FROM MT_GFU_FORMAT_SETUP
				WHERE	VENDOR_ID = :p_vendor
				AND  FUNCTION_ID	= :p_module
				AND STATUS = 'AA';
*/
/*	printf("\nBefore retriving file type ref_no=|%s|",p_refno);*/
	
	EXEC SQL SELECT FILE_TYPE INTO :l_file_type FROM  MT_GFU_FORMAT_SETUP WHERE REF_NO=:p_refno AND STATUS='AA';
	/**printf("\nSQL Code for File Type=%d",sqlca.sqlcode);**/
	IS_ANY_ORA_ERROR

	if(sqlca.sqlcode == 1403) APL_GOBACK_SUCCESS

	if(Rtv_C_E_T(	l_file_type,
					p_refno,
					l_c_e_t_struct_h,
					l_debug_info_ptr) == APL_FAILURE)
			{
				printf("\n\nError during Rtv_C_E_T function");
			APL_GOBACK_FAIL
			}
/*	printf("After Rtv_C_E_T function");*/
	if(Add_Rpl_Format_Lst(l_file_type,
							 p_gfu_format_map_lst,
							 l_c_e_t_struct_h,
							 l_debug_info_ptr) == APL_FAILURE)
	{
				printf("\n\nError during Add_Rpl_Format_Lst function");
	APL_GOBACK_FAIL
	}
							
							
APL_GOBACK_SUCCESS
RETURN_FAILURE:
	while(*l_c_e_t_struct_h)
	{
		l_c_e_t_struct_free = (*l_c_e_t_struct_h) -> h_next;
		APL_FREE((*l_c_e_t_struct_h))
		*l_c_e_t_struct_h = l_c_e_t_struct_free;
	}
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	while(*l_c_e_t_struct_h)
	{
		l_c_e_t_struct_free = (*l_c_e_t_struct_h) -> h_next;
		APL_FREE((*l_c_e_t_struct_h))
		*l_c_e_t_struct_h = l_c_e_t_struct_free;
	}
	APL_FUNCTION_RET_SUCCESS(l_logfile)


}
							


/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : Call_Stored_Proc																 *
 *                                                                                                       *
 * Description           : This Function is used for calling stored procedure for specific module.       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_gfu_req_map_h                     GFU_REQ_MAP_STRUCT_H *           I      Containing Wrapper/SP name*
 *                                                                                                       *
 * p_env_data                          char *                           I      Environment String		 *
 *                                                                                                       *
 * p_param_data                        char *                           I      Parameter String			 *
 *                                                                                                       *
 * p_line_no                           int                              I      Line number of the record *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/

int Call_Stored_Proc(	GFU_REQ_MAP_STRUCT_H *p_gfu_req_map_h,
			char *p_env_data, 
			char *p_param_data,
			int p_line_no,
			DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;
	char l_error[GFU_ERR_DATA_LEN] = APL_NULL_STRING;
	char l_reason[GFU_ERR_DATA_LEN] = APL_NULL_STRING;
	char l_mis_info[4000] = APL_NULL_STRING;
BT_IF_DEBUG
	fprintf(l_logfile,"Environ Data\n|%s|\n",p_env_data);

BT_IF_DEBUG
	fprintf(l_logfile,"Param Data\n|%s|\n",p_param_data);
	
	APL_FUNCTION_ENTER(l_logfile)
	printf("Store Procedure Name |%s|\n",p_gfu_req_map_h -> h_sp_name);
	if(!strcmp(p_gfu_req_map_h -> h_sp_name,"SP_INTL_MT_DM"))
	{
		EXEC SQL CALL SP_INTL_MT_DM(:p_gfu_req_map_h -> h_wrapper,:p_env_data,:p_param_data,:p_gfu_req_map_h -> h_user,:l_error);
	}
	else if(!strcmp(p_gfu_req_map_h -> h_sp_name,"SP_INTL_MT"))
	{
		EXEC SQL CALL SP_INTL_MT(:p_gfu_req_map_h -> h_wrapper,:p_env_data,:p_param_data,:p_gfu_req_map_h -> h_user,:l_error);
	}
	else if(!strcmp(p_gfu_req_map_h -> h_sp_name,"SP_INTL_CA"))
	{
		EXEC SQL CALL SP_INTL_CA(:p_gfu_req_map_h -> h_wrapper,:p_env_data,:p_param_data,:p_gfu_req_map_h -> h_user,:l_error);
	}
	else if(!strcmp(p_gfu_req_map_h -> h_sp_name,"SP_INTL_DEAL"))
	{
		printf(" Entering sp_intl_deal:\n\t|%s|\n\t|%s|\n\t|%s|\n\t|%s|\n\t|%s|\n\t|%s|",p_gfu_req_map_h -> h_wrapper,p_env_data,p_param_data,p_gfu_req_map_h -> h_user,l_mis_info,l_error);
		EXEC SQL CALL SP_INTL_DEAL(:p_gfu_req_map_h -> h_wrapper,:p_env_data,:p_param_data,:p_gfu_req_map_h -> h_user,:l_mis_info,:l_error);
	}
	IS_ANY_ORA_ERROR
BT_IF_DEBUG
		fprintf(l_logfile,"Return From Daemon : %s \n",l_error);
		/** It can be added in the same way for other stored procedures **/
	/** there May be cases where the daemon outputs some value along with SUCCESS, So changed strcmp to strstr **/
	if(!strstr(l_error,"SUCCESS"))
	{
		if(APL_FAILURE ==	GFU_Rtv_DelStr(	l_error, 
						"|", 
						10,
						l_reason,
						l_debug_info_ptr))
			APL_GOBACK_FAIL
		if(APL_FAILURE == GFU_UpdErrorDet(	p_line_no,
							"N",
							"FAILURE",
							APL_NULL_STRING,
							APL_NULL_STRING,
							l_reason,
							l_debug_info_ptr))
		APL_GOBACK_FAIL

		if(APL_FAILURE == GFU_Write_Skipped(	p_line_no,
							l_debug_info_ptr))
		APL_GOBACK_FAIL



	}
	else
	{
		if(APL_FAILURE == GFU_UpdErrorDet(	p_line_no,
							"N",
							"SUCCESS",
							APL_NULL_STRING,
							APL_NULL_STRING,
							APL_NULL_STRING,
							l_debug_info_ptr))
		APL_GOBACK_FAIL
	}


	APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}




/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Lst_To_Data																 *
 *                                                                                                       *
 * Description           : This Function is used for making string from linked list						 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_token_value_lst                   GFU_TOKEN_VAL_STRUCT_LST **      I      Linked list Token/Value   *
 *                                                                                                       *
 * p_data							   char *                           O      Converted String		     *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/


int GFU_Lst_To_Data(GFU_TOKEN_VAL_STRUCT_LST **p_token_value_lst, char *p_data,DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	
	char l_line[GFU_LINE_LEN] = APL_NULL_STRING;
	GFU_TOKEN_VAL_STRUCT_LST **l_temp_ptr = p_token_value_lst;
	APL_FUNCTION_ENTER(l_logfile)
	memset(p_data,APL_NULL_CHAR,sizeof(p_data));

	while((*l_temp_ptr)!=NULL)
	{
		memset(l_line,APL_NULL_CHAR,sizeof(l_line));
		sprintf(l_line,"%c%s%c%s",DATA_FIELD_SEPRTR,(*l_temp_ptr) -> h_token,DATA_VALUE_SEPRTR,(*l_temp_ptr) -> h_value);
BT_IF_DEBUG
		fprintf(l_logfile,"\t|%s|\t\t=\t\t|%s|\n",(*l_temp_ptr) -> h_token,(*l_temp_ptr) -> h_value);
		strcat(p_data,l_line);
		l_temp_ptr = &((*l_temp_ptr) -> h_next);
	}

APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)


}


/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Process_Rec																 *
 *                                                                                                       *
 * Description           : This Function is used to process single record								 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_gfu_env_map_lst                   GFU_TOKEN_VAL_STRUCT_LST **      I      Environment list			 *
 *                                                                                                       *
 * p_gfu_val_map_lst				   GFU_VAL_MAP_STRUCT_LST **        I      Validation List		     *
 *																										 *
 * p_gfu_req_map_h					   GFU_REQ_MAP_STRUCT_H *			I	   Request Map Structure     *
 *																										 *
 * p_gfu_param_data_lst				   GFU_TOKEN_VAL_STRUCT_LST **		I	   Parameter Data List		 *
 *																										 *
 * p_line_no						   int								I	   Line number of record	 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/



int GFU_Process_Rec(	GFU_TOKEN_VAL_STRUCT_LST **p_gfu_env_map_lst,
						GFU_VAL_MAP_STRUCT_LST **p_gfu_val_map_lst,
						GFU_REQ_MAP_STRUCT_H *p_gfu_req_map_h,
						GFU_TOKEN_VAL_STRUCT_LST **p_gfu_param_data_lst,
						int p_line_no,
						DEBUG_INFO_STRUCT_H **l_debug_info_ptr)


{
	char l_param_data[GFU_PARAM_DATA_LEN];
	char l_env_data[GFU_ENV_DATA_LEN];

	APL_FUNCTION_ENTER(l_logfile)
	memset(l_param_data,APL_NULL_CHAR,sizeof(l_param_data));
	memset(l_env_data,APL_NULL_CHAR,sizeof(l_env_data));

	if(GF_FnlProc(p_gfu_param_data_lst,p_gfu_env_map_lst,p_line_no,p_gfu_req_map_h -> h_module,l_debug_info_ptr) == APL_FAILURE)
		APL_GOBACK_FAIL

	if(APL_FAILURE == GFU_Lst_To_Data(p_gfu_param_data_lst,l_param_data,l_debug_info_ptr))
		APL_GOBACK_FAIL

	if(APL_FAILURE == GFU_Lst_To_Data(p_gfu_env_map_lst,l_env_data,l_debug_info_ptr))
		APL_GOBACK_FAIL

	if(APL_FAILURE == Call_Stored_Proc(p_gfu_req_map_h,l_env_data,l_param_data,p_line_no,l_debug_info_ptr))
		APL_GOBACK_FAIL


APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)

}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Process_Lst																 *
 *                                                                                                       *
 * Description           : This Function is used to process whole file converted as list				 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_file_lst						   GFU_FILE_LST						I	   Full List				 *
 *																										 *
 * p_process_name					   char *							I      Name of the process		 *
 *																									     *
 * p_process_key					   char *							I      Key of the Process		 *
 *																										 *
 * p_start_date						   char *							I	   Started Date				 *
 *																										 *
 * p_gfu_val_map_lst				   GFU_VAL_MAP_STRUCT_LST **        I      Validation List		     *
 *																										 *
 * p_gfu_req_map_h					   GFU_REQ_MAP_STRUCT_H *			I	   Request Map Structure     *
 *																										 *
 * p_gfu_env_map_lst                   GFU_TOKEN_VAL_STRUCT_LST **      I      Environment list			 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/

int GFU_Process_Lst(GFU_FILE_LST **p_file_lst,
					char *p_process_name,
					char *p_process_key,
					char *p_start_date,
					GFU_VAL_MAP_STRUCT_LST **p_gfu_val_map_lst,
					GFU_REQ_MAP_STRUCT_H *p_gfu_req_map_h,
					GFU_TOKEN_VAL_STRUCT_LST **p_gfu_env_map_lst,
					DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	GFU_FILE_LST **l_temp_ptr = p_file_lst;
	char l_status_info[100];

	APL_FUNCTION_ENTER(l_logfile)
	while((*l_temp_ptr)!=NULL)
	{
	        fputs("\n",stdin);
                fflush(stdin);
			
		if(APL_FAILURE == CO_FreeErrLst(l_debug_info_ptr))
			APL_GOBACK_FAIL

		if(!(((*l_temp_ptr) -> h_line_no)%GFU_COMMIT_COUNT))
		{
			memset(l_status_info,APL_NULL_CHAR,sizeof(l_status_info));
			sprintf(l_status_info," Processed Till Line |%d| Record |%d|\n",(*l_temp_ptr) -> h_line_no,(*l_temp_ptr) -> h_rec_no);

			if(APL_FAILURE == BT_Status_Update(	p_process_name,
											p_process_key,
											p_start_date,
											l_status_info,
											l_debug_info_ptr))
			APL_GOBACK_FAIL
		}

		if(APL_FAILURE == GFU_Process_Rec(	p_gfu_env_map_lst,
							p_gfu_val_map_lst,
							p_gfu_req_map_h,
							(*l_temp_ptr)-> h_token_val,
							(*l_temp_ptr)-> h_line_no,
							l_debug_info_ptr))
		{
			if(APL_FAILURE == GFU_UpdErrorDet(	(*l_temp_ptr) -> h_line_no,
							"N",
							"FAILURE",
							APL_NULL_STRING,
							APL_NULL_STRING,
							APL_NULL_STRING,
							l_debug_info_ptr))
			APL_GOBACK_FAIL

			if(APL_FAILURE == GFU_Write_Skipped(	(*l_temp_ptr) -> h_line_no,
								l_debug_info_ptr))
			APL_GOBACK_FAIL 

		}
			
		l_temp_ptr = &((*l_temp_ptr)->h_next);
		/** Reporting Will be done here */
	}
APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}



/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : Read_Ascii																	 *
 *                                                                                                       *
 * Description           : This Function is used to One Ascii line to list								 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_line							   char *							I	   line						 *
 *																										 *
 * p_line_no						   int								I	   line number				 *
 *																										 *
 * p_gfu_file_map_h					   GFU_FILE_MAP_STRUCT_H *			I	   Conatins Details about the file *
 *																										 *
 * p_gfu_format_map_lst				   GFU_FORMAT_MAP_STRUCT_LST **		I      Format List				 *
 *																									     *
 * p_token_value					   GFU_TOKEN_VAL_STRUCT_LST			O      The Output List			 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/

int Read_Ascii(	char *p_line,
		int p_line_no,
					GFU_FILE_MAP_STRUCT_H *p_gfu_file_map_h,
				GFU_FORMAT_MAP_STRUCT_LST **p_gfu_format_map_lst,
				GFU_TOKEN_VAL_STRUCT_LST **p_token_value,
				DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	GFU_FORMAT_MAP_STRUCT_LST **l_temp_ptr = p_gfu_format_map_lst;
	GFU_TOKEN_VAL_STRUCT_LST **l_token_value = p_token_value;

	GFU_FORMAT_MAP_STRUCT_LST *l_curr_format_node = (GFU_FORMAT_MAP_STRUCT_LST *)NULL;
	
	char l_value[GFU_VALUE_LEN];
	
	APL_FUNCTION_ENTER(l_logfile)	

	while((*l_temp_ptr)!=NULL)
	{
		/** Here we have to add Read from file name if Test is F this is for Belav files**/
		memset(l_value,APL_NULL_CHAR,sizeof(l_value));
		BT_IF_DEBUG
			fprintf(l_logfile,"Read From File Name Or Text (F/T) : %s\n",(*l_temp_ptr) -> h_header_text);
		l_curr_format_node = (GFU_FORMAT_MAP_STRUCT_LST *)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_LST));
		memset(l_curr_format_node,APL_NULL_CHAR,sizeof(GFU_FORMAT_MAP_STRUCT_LST));  //AIX - Warnings Removal
		strcpy(l_curr_format_node -> h_refno,(*l_temp_ptr) -> h_refno);
		strcpy(l_curr_format_node -> h_valid,(*l_temp_ptr) ->h_valid);
		strcpy(l_curr_format_node -> h_header_text,(*l_temp_ptr) ->h_header_text);
		strcpy(l_curr_format_node -> h_field_type,(*l_temp_ptr) ->h_field_type);
		strcpy(l_curr_format_node -> h_label,(*l_temp_ptr) ->h_label);
		strcpy(l_curr_format_node -> h_seq,(*l_temp_ptr) ->h_seq);
		strcpy(l_curr_format_node -> h_start,(*l_temp_ptr) ->h_start);
		strcpy(l_curr_format_node -> h_end,(*l_temp_ptr) ->h_end);
		strcpy(l_curr_format_node -> h_remove_char,(*l_temp_ptr) ->h_remove_char);
		strcpy(l_curr_format_node -> h_remove_last_char,(*l_temp_ptr) ->h_remove_last_char);
		strcpy(l_curr_format_node -> h_static_val,(*l_temp_ptr) ->h_static_val);
		strcpy(l_curr_format_node -> h_val_type,(*l_temp_ptr) ->h_val_type);
		strcpy(l_curr_format_node -> h_date_format,(*l_temp_ptr) ->h_date_format);
		strcpy(l_curr_format_node -> h_header,(*l_temp_ptr) ->h_header);
		l_curr_format_node -> h_srl_no = (*l_temp_ptr) ->h_srl_no;
		strcpy(l_curr_format_node -> h_repeat,(*l_temp_ptr) ->h_repeat);
		strcpy(l_curr_format_node -> h_query,(*l_temp_ptr) ->h_query);
		l_curr_format_node -> h_next = (GFU_FORMAT_MAP_STRUCT_LST *)NULL;
		
		switch (l_curr_format_node -> h_header_text[0])
		{

			case 'T':
				if(APL_FAILURE == Rtv_Data_Value(	p_line,
							p_line_no,
							p_gfu_file_map_h -> h_file_type,
							l_curr_format_node -> h_label,
							l_curr_format_node -> h_refno,
							l_curr_format_node -> h_field_type,
							l_curr_format_node -> h_seq,
							l_curr_format_node -> h_start,
							l_curr_format_node -> h_end,
							p_gfu_file_map_h -> h_delimiter,					
							l_curr_format_node -> h_remove_char,
							l_curr_format_node -> h_remove_last_char,
							l_curr_format_node -> h_static_val,
							l_curr_format_node -> h_val_type,
							l_curr_format_node -> h_date_format,
							l_curr_format_node -> h_srl_no,
							l_curr_format_node -> h_repeat,
							l_curr_format_node -> h_query,
							l_value,
							l_debug_info_ptr))
					APL_GOBACK_FAIL
						break;
			case 'F':
				if(APL_FAILURE == Rtv_Data_Value(p_gfu_file_map_h -> h_file_name,
							p_line_no,
							p_gfu_file_map_h -> h_file_type,
							l_curr_format_node -> h_label,
							l_curr_format_node -> h_refno,
							l_curr_format_node -> h_field_type,
							l_curr_format_node -> h_seq,
							l_curr_format_node -> h_start,
							l_curr_format_node -> h_end,
							p_gfu_file_map_h -> h_delimiter,	
							l_curr_format_node -> h_remove_char,
							l_curr_format_node -> h_remove_last_char,
							l_curr_format_node -> h_static_val,
							l_curr_format_node -> h_val_type,
							l_curr_format_node -> h_date_format,
							l_curr_format_node -> h_srl_no,
							l_curr_format_node -> h_repeat,
							l_curr_format_node -> h_query,
							l_value,
							l_debug_info_ptr))
					APL_GOBACK_FAIL
						break;
		}

						
		while((*l_token_value) != NULL)
		{
			l_token_value = &((*l_token_value)->h_next);
		}
		if(((*l_token_value) = (GFU_TOKEN_VAL_STRUCT_LST *)calloc(1,sizeof(GFU_TOKEN_VAL_STRUCT_LST))) == NULL)
		{
BT_IF_DEBUG
			fprintf(l_logfile,"failed in New Allocation\n");
			APL_GOBACK_FAIL
		}
		strcpy((*l_token_value) -> h_token, l_curr_format_node -> h_label);
		strcpy((*l_token_value) -> h_value, l_value);
		(*l_token_value) -> h_next = NULL;
		l_temp_ptr = &((*l_temp_ptr)->h_next);
		APL_FREE(l_curr_format_node);

	}
APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}


/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Conv_Lnk_Lst																 *
 *                                                                                                       *
 * Description           : This Function is used to Convert file to linked list							 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_file							   FILE *							I	   file pointer				 *
 *																										 *
 * p_process_name					   char *							I      Name of the process		 *
 *																									     *
 * p_process_key					   char *							I      Key of the Process		 *
 *																										 *
 * p_start_date						   char *							I	   Started Date				 *
 *																										 *
 * p_gfu_file_map					   GFU_FILE_MAP_STRUCT_H *			I	   Conatins Details about the file *
 *																										 *
 * p_gfu_format_map_lst				   GFU_FORMAT_MAP_STRUCT_LST **		I      Format List				 *
 *																									     *
 * p_file_lst						   GFU_FILE_LST **					O      The Output List			 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/

int Prnt_Format(GFU_FORMAT_MAP_STRUCT_LST **p_gfu_format_map_lst)
{
	GFU_FORMAT_MAP_STRUCT_LST **l_temp_ptr = p_gfu_format_map_lst;
	while(*l_temp_ptr)
	{
		printf("%s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %d\n %s\n %s",
				(*l_temp_ptr) ->  h_refno,
				(*l_temp_ptr) ->  h_valid,
				(*l_temp_ptr) ->  h_header_text,
				(*l_temp_ptr) ->  h_field_type,
				(*l_temp_ptr) ->  h_label,
				(*l_temp_ptr) ->  h_seq,
				(*l_temp_ptr) ->  h_start,
				(*l_temp_ptr) ->  h_end,
				(*l_temp_ptr) ->  h_remove_char,
				(*l_temp_ptr) ->  h_remove_last_char,
				(*l_temp_ptr) ->  h_static_val,
				(*l_temp_ptr) ->  h_val_type,
				(*l_temp_ptr) ->  h_date_format,
				(*l_temp_ptr) ->  h_header,
				(*l_temp_ptr) ->      h_srl_no,
				(*l_temp_ptr) ->  h_repeat,
				(*l_temp_ptr) ->  h_query);
	l_temp_ptr = &((*l_temp_ptr)->h_next);
	}

}
int GFU_Conv_Lnk_Lst(	FILE *p_file,
						char *p_process_name,
						char *p_process_key,
						char *p_start_date,
						GFU_FILE_MAP_STRUCT_H *p_gfu_file_map,
	/**					GFU_FILE_LST **p_file_lst,**/
						GFU_TOKEN_VAL_STRUCT_LST **p_gfu_env_map_lst,
						GFU_VAL_MAP_STRUCT_LST **p_gfu_val_map_lst,
						GFU_REQ_MAP_STRUCT_H *p_gfu_req_map_h,
						DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	/**GFU_FILE_LST **l_temp_ptr = p_file_lst;**/
	GFU_FORMAT_MAP_STRUCT_LST **l_gfu_format_map_lst = (GFU_FORMAT_MAP_STRUCT_LST **)NULL;
	GFU_FORMAT_MAP_STRUCT_LST *l_gfu_format_map_free = (GFU_FORMAT_MAP_STRUCT_LST *)NULL;
	GFU_FORMAT_MAP_STRUCT_LST **l_gfu_header_map_lst = (GFU_FORMAT_MAP_STRUCT_LST **)NULL;
	GFU_FORMAT_MAP_STRUCT_LST *l_gfu_header_map_free = (GFU_FORMAT_MAP_STRUCT_LST *)NULL;

	GFU_TOKEN_VAL_STRUCT_LST **l_token_value = (GFU_TOKEN_VAL_STRUCT_LST **)NULL;
	GFU_TOKEN_VAL_STRUCT_LST	*l_token_value_free = (GFU_TOKEN_VAL_STRUCT_LST *)NULL;
	int l_count = 1;
	int l_line_no = 0;
	char l_skip_line[GFU_SKIP_LINE_LEN];
	char l_line[GFU_LINE_LEN];
	char l_refno[GFU_REFNO_LEN];
	char l_status_info[100];
	
	APL_FUNCTION_ENTER(l_logfile)



	
	l_gfu_header_map_lst = (GFU_FORMAT_MAP_STRUCT_LST **)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_LST *));
	l_token_value = (GFU_TOKEN_VAL_STRUCT_LST **)calloc(1,sizeof(GFU_TOKEN_VAL_STRUCT_LST *));
	l_gfu_format_map_lst = (GFU_FORMAT_MAP_STRUCT_LST **)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_LST *));
	
	if(!strcmp(p_gfu_file_map -> h_check_header,"Y"))
	{
	if(APL_FAILURE == Rtv_Format_Frm_Header(	p_gfu_file_map -> h_refno,
												p_gfu_file_map -> h_header,
												p_gfu_file_map -> h_format_no,
												l_gfu_header_map_lst,
												l_debug_info_ptr))

	{	
		printf("Failed in Rtv_Format_Frm_Header\n");
		APL_GOBACK_FAIL
	}
	}
	IF_COND_NOT_EXISTS("GFU_PROCESS","LINE_FORMATS")
	{
		if(APL_FAILURE == GFU_Rtv_Format(	p_gfu_file_map -> h_refno,
					p_gfu_file_map,
					l_gfu_format_map_lst,
					l_debug_info_ptr))
		{	
			printf("Failed in GFU_Rtv_Format\n");
			APL_GOBACK_FAIL
		}
	}

	while(!feof(p_file))
	{	
		/**usleep(MICRO_SECONDS);**/
		IF_COND_EXISTS("GFU_PROCESS","LINE_FORMATS")
		{
        while(*l_gfu_format_map_lst)
        {
                l_gfu_format_map_free = (*l_gfu_format_map_lst) -> h_next;
                APL_FREE((*l_gfu_format_map_lst));
                (*l_gfu_format_map_lst) = l_gfu_format_map_free;
        }
		}
       while(*l_token_value)
       {
                l_token_value_free = (*l_token_value) -> h_next;
                APL_FREE((*l_token_value));
                (*l_token_value) = l_token_value_free;
        }
		if(APL_FAILURE == CO_FreeErrLst(l_debug_info_ptr))
			APL_GOBACK_FAIL

		

		l_token_value = (GFU_TOKEN_VAL_STRUCT_LST **)calloc(1,sizeof(GFU_TOKEN_VAL_STRUCT_LST *));
		printf("Line No |%d|\n",l_line_no);
		if(!(l_line_no%GFU_COMMIT_COUNT))
		{
			memset(l_status_info,APL_NULL_CHAR,sizeof(l_status_info));
			/**sprintf(l_status_info," Parsed Till Line |%d| Record |%d|\n",l_line_no,l_count - 1);**/
			sprintf(l_status_info," Processed Till Line |%d| Record |%d|\n",l_line_no,l_count - 1);

			if(APL_FAILURE == BT_Status_Update(	p_process_name,
												p_process_key,
												p_start_date,
												l_status_info,
												l_debug_info_ptr))
				APL_GOBACK_FAIL
		}
											

		l_line_no ++;

/**
		l_gfu_format_map_lst = (GFU_FORMAT_MAP_STRUCT_LST **)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_LST *));
		**/


		switch(p_gfu_file_map -> h_file_type[0])
		{
			case GFU_ASCII:
			case GFU_POSITION:
					memset(l_refno,APL_NULL_CHAR,sizeof(l_refno));
					/**if(feof(p_file))APL_GOBACK_FAIL -- Biju **/
					memset(l_line,APL_NULL_CHAR,sizeof(l_line));	
					fgets(l_line,GFU_LINE_LEN,p_file);
					if(strrchr(l_line,'\n'))*(strrchr(l_line,'\n')) = APL_NULL_CHAR;
					memset(l_skip_line,APL_NULL_CHAR,sizeof(l_skip_line));
					sprintf(l_skip_line,"%s%d%s",GFU_SKIP_LINE_DEL,l_line_no,GFU_SKIP_LINE_DEL);
					/**fprintf(l_logfile,"Line|%d|%s|\n",l_line_no,l_line);**/
					memset(g_line,APL_NULL_CHAR,sizeof(g_line));
					strcpy(g_line,l_line);
					if(strstr(p_gfu_file_map -> h_skip_line,l_skip_line))
					{
						BT_IF_DEBUG
							fprintf(l_logfile,"Skipping Specified Line |%d| \n",l_line_no);

						if(APL_FAILURE == GFU_UpdErrorDet(	l_line_no,
											"Y",
											APL_NULL_STRING,
											APL_NULL_STRING,
											APL_NULL_STRING,
											"Line Should Not Be Processed, Skipped",
											l_debug_info_ptr))
							APL_GOBACK_FAIL
						if(APL_FAILURE == GFU_Write_Skipped(	l_line_no,
											l_debug_info_ptr))
						APL_GOBACK_FAIL


						continue;

					}
					if(l_line_no == p_gfu_file_map -> h_header)
					{
						BT_IF_DEBUG
							fprintf(l_logfile,"Skipping Header Line |%d| \n",l_line_no);

						if(APL_FAILURE == GFU_UpdErrorDet(	l_line_no,
											"Y",
											APL_NULL_STRING,
											APL_NULL_STRING,
											APL_NULL_STRING,
											"Line Is Header, Skipped",
											l_debug_info_ptr))
							APL_GOBACK_FAIL
						if(APL_FAILURE == GFU_Write_Skipped(	l_line_no,
											l_debug_info_ptr))
						APL_GOBACK_FAIL

						continue;
					}
					if(!strlen(l_line))continue;

					IF_COND_EXISTS("GFU_PROCESS","LINE_FORMATS")
					{
						if(APL_FAILURE == Rtv_Format_Refno(	l_line,
									l_line_no,
									l_refno,
									l_debug_info_ptr))
						{	
							printf("Failed in Rtv_Format_Refno\n");
							if(APL_FAILURE == GFU_UpdErrorDet(  l_line_no,"N",
										"FAILURE",
										APL_NULL_STRING,
										APL_NULL_STRING,
										APL_NULL_STRING,
										l_debug_info_ptr))
								APL_GOBACK_FAIL
									if(APL_FAILURE == GFU_Write_Skipped(   l_line_no,
												l_debug_info_ptr))
										APL_GOBACK_FAIL

											continue;
						}
						BT_IF_DEBUG
							fprintf(l_logfile,"Refno |%s|\n",l_refno);

								
						l_gfu_format_map_lst = (GFU_FORMAT_MAP_STRUCT_LST **)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_LST *));
						if(APL_FAILURE == GFU_Rtv_Format(	l_refno,
										p_gfu_file_map,
										l_gfu_format_map_lst,
										l_debug_info_ptr))
						{	
							printf("Failed in GFU_Rtv_Format\n");
							APL_GOBACK_FAIL
						}

					}
			
					/*Prnt_Format(l_gfu_format_map_lst);*/
					/** After Retrieving the format lets Proceeding For CSV/EXCEL/TEXT Setup **/
					if(APL_FAILURE == Process_C_E_T(	l_gfu_format_map_lst,
																l_refno,
																p_gfu_file_map -> h_module,
																p_gfu_file_map -> h_vendor,
																l_debug_info_ptr))
					{
						CO_ProcMonitor(APL_OUT_FILE,"Failed in PCT ",l_debug_info_ptr,NULL);
						APL_GOBACK_FAIL
					}
					/*Prnt_Format(l_gfu_format_map_lst);*/
																	
					if(!strcmp(p_gfu_file_map -> h_check_header,"Y"))
					{
						if(APL_FAILURE == GF_Chk_Header_Format(	p_gfu_file_map,
									l_gfu_format_map_lst,
									l_gfu_header_map_lst,
									l_debug_info_ptr))

						{	
							printf("Failed in Rtv_Format_Frm_Header\n");
							APL_GOBACK_FAIL
						}
					}

					/**if(!strlen(l_line))continue; Already Done Aboive -- Biju **/
					Alert("Before Read Ascii");

			
					if(APL_FAILURE == Read_Ascii(	l_line,
															l_line_no,
															p_gfu_file_map,
															l_gfu_format_map_lst,
															l_token_value,
															l_debug_info_ptr))
					{
						if(APL_FAILURE == GFU_UpdErrorDet(	l_line_no,"N",
											"FAILURE",
											APL_NULL_STRING,
											APL_NULL_STRING,
											APL_NULL_STRING,
											l_debug_info_ptr))
							APL_GOBACK_FAIL
						if(APL_FAILURE == GFU_Write_Skipped(	l_line_no,
											l_debug_info_ptr))
						APL_GOBACK_FAIL

						continue;
					}
					Alert("Before Read Ascii");
					break;
				
			case GFU_BINARY:
							/*Read_Binary(p_file,p_gfu_file_map,l_gfu_format_map_lst,l_token_value);*/
							break;
		}	
		/** l_token_value  Cotains Token And values We need **/
		/**usleep(MICRO_SECONDS);**/
		Alert("Before Specific Fn");
		if(GF_SpecificRecFun( 	l_token_value,
									p_gfu_file_map,
									p_start_date,
									l_debug_info_ptr) == APL_FAILURE)
		{
			APL_GOBACK_FAIL
		}
		Alert("After Specific Fn");

		Alert("Before Process Rec");
		if(APL_FAILURE == GFU_Process_Rec(  p_gfu_env_map_lst,
					p_gfu_val_map_lst,
					p_gfu_req_map_h,
					l_token_value,
					l_line_no,
					l_debug_info_ptr))
		{
			if(APL_FAILURE == GFU_UpdErrorDet(  l_line_no,
						"N",
						"FAILURE",
						APL_NULL_STRING,
						APL_NULL_STRING,
						APL_NULL_STRING,
						l_debug_info_ptr))
				APL_GOBACK_FAIL

			if(APL_FAILURE == GFU_Write_Skipped(   l_line_no,
								l_debug_info_ptr))
				APL_GOBACK_FAIL

		}
		Alert("After Process Rec");
		l_count ++;
		/**
			
		while((*l_temp_ptr) != NULL)
		{
			l_temp_ptr = &((*l_temp_ptr)->h_next);
		}
		if(((*l_temp_ptr) = (GFU_FILE_LST *)calloc(1,sizeof(GFU_FILE_LST))) == NULL)
		{
			APL_GOBACK_FAIL
		}
		(*l_temp_ptr)->h_rec_no = l_count ++;
		(*l_temp_ptr)->h_line_no = l_line_no;
		(*l_temp_ptr)->h_token_val = l_token_value;

		if(GF_SpecificRecFun( 	(*l_temp_ptr),
									p_gfu_file_map,
									p_start_date,
									l_debug_info_ptr) == APL_FAILURE)
		{
			APL_GOBACK_FAIL
		}



		
		(*l_temp_ptr)->h_next = (GFU_FILE_LST *)NULL;
		**/
		
		/**
		IF_COND_EXISTS("GFU_PROCESS","LINE_FORMATS")
		{
        while(*l_gfu_format_map_lst)
        {
                l_gfu_format_map_free = (*l_gfu_format_map_lst) -> h_next;
                APL_FREE((*l_gfu_format_map_lst));
                (*l_gfu_format_map_lst) = l_gfu_format_map_free;
        }
		}
		**/
		
	}
	memset(l_status_info,APL_NULL_CHAR,sizeof(l_status_info));
	sprintf(l_status_info," Processed Till Line |%d| Record |%d|\n",l_line_no,l_count - 1);

	if(APL_FAILURE == BT_Status_Update(	p_process_name,
												p_process_key,
												p_start_date,
												l_status_info,
												l_debug_info_ptr))
		APL_GOBACK_FAIL

APL_GOBACK_SUCCESS
RETURN_FAILURE:
		IF_COND_NOT_EXISTS("GFU_PROCESS","LINE_FORMATS")
		{
        while(*l_gfu_format_map_lst)
        {
                l_gfu_format_map_free = (*l_gfu_format_map_lst) -> h_next;
                APL_FREE((*l_gfu_format_map_lst));
                (*l_gfu_format_map_lst) = l_gfu_format_map_free;
        }
		}
        while(*l_gfu_header_map_lst)
        {
                l_gfu_format_map_free = (*l_gfu_header_map_lst) -> h_next;
                APL_FREE((*l_gfu_header_map_lst));
                (*l_gfu_header_map_lst) = l_gfu_format_map_free;
        }

	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
		IF_COND_NOT_EXISTS("GFU_PROCESS","LINE_FORMATS")
		{
        while(*l_gfu_format_map_lst)
        {
                l_gfu_format_map_free = (*l_gfu_format_map_lst) -> h_next;
                APL_FREE((*l_gfu_format_map_lst));
                (*l_gfu_format_map_lst) = l_gfu_format_map_free;
        }
		}
        while(*l_gfu_header_map_lst)
        {
                l_gfu_format_map_free = (*l_gfu_header_map_lst) -> h_next;
                APL_FREE((*l_gfu_header_map_lst));
                (*l_gfu_header_map_lst) = l_gfu_format_map_free;
        }

	APL_FUNCTION_RET_SUCCESS(l_logfile)
}








/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Rtv_Format																 *
 *                                                                                                       *
 * Description           : This Function is used to Convert file to linked list							 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_format_refno					   char *							I	   gets format specified according to the refno*
 *																										 *
 * p_gfu_file_map_h					   GFU_FILE_MAP_STRUCT_H *			I	   Conatins Details about the file *
 *																										 *
 * p_gfu_format_map_lst				   GFU_FORMAT_MAP_STRUCT_LST **		I      Format List				 *
 *																									     *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/






int GFU_Rtv_Format(	char *p_format_refno,
					GFU_FILE_MAP_STRUCT_H *p_gfu_file_map_h,
					GFU_FORMAT_MAP_STRUCT_LST **p_gfu_format_map_lst,
					DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;
	GFU_FORMAT_MAP_STRUCT_LST **l_temp_ptr = p_gfu_format_map_lst;
	GFU_FORMAT_MAP_STRUCT_I		*l_gfu_format_map_i;
	GFU_FORMAT_MAP_STRUCT_H		*l_gfu_format_map_h;
	int l_cnt = 0;
	sqlca.sqlcode = 0;

	APL_FUNCTION_ENTER(l_logfile)

		/*
	EXEC SQL DECLARE l_cur_format_map CURSOR FOR 
			SELECT *
			FROM GFFORMATMAP
			WHERE REFNO = :p_format_refno
		**	AND HEADER_TEXT_IND = 'T' **
			ORDER BY SERIAL_NO;
*/
		EXEC SQL DECLARE l_cur_format_map CURSOR FOR
			SELECT * FROM GFFORMATMAP 
			WHERE REFNO = :p_gfu_file_map_h->h_module
			/** AND HEADER_TEXT_IND = 'T' **/
			ORDER BY SERIAL_NO;
	/**printf("Error During format Retrival SQLCA sqlcode=%d",sqlca.sqlcode);**/
	IS_ANY_ORA_ERROR

	EXEC SQL OPEN l_cur_format_map;

	IS_ANY_ORA_ERROR

	l_gfu_format_map_h = (GFU_FORMAT_MAP_STRUCT_H *)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_H));
	l_gfu_format_map_i = (GFU_FORMAT_MAP_STRUCT_I *)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_I));	

	for(;;)
	{
		
		memset(l_gfu_format_map_h,APL_NULL_CHAR,sizeof(GFU_FORMAT_MAP_STRUCT_H)); //AIX - Warnings Removal
		memset(l_gfu_format_map_i,APL_NULL_CHAR,sizeof(GFU_FORMAT_MAP_STRUCT_I));
		EXEC SQL FETCH l_cur_format_map
				INTO :l_gfu_format_map_h:l_gfu_format_map_i;
		
		
		if(sqlca.sqlcode == 1403)break;
		IS_ANY_ORA_ERROR

		while((*l_temp_ptr) != (GFU_FORMAT_MAP_STRUCT_LST *)NULL)
		{
			l_temp_ptr = &((*l_temp_ptr)->h_next);
		}
		if(((*l_temp_ptr) = (GFU_FORMAT_MAP_STRUCT_LST *)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_LST))) == NULL)
		{
			APL_GOBACK_FAIL
		}
		strcpy((*l_temp_ptr)->h_refno,l_gfu_format_map_h -> h_refno);
		strcpy((*l_temp_ptr)->h_valid,l_gfu_format_map_h -> h_valid);
		strcpy((*l_temp_ptr) -> h_header_text,l_gfu_format_map_h -> h_header_text);
		strcpy((*l_temp_ptr) -> h_field_type,l_gfu_format_map_h -> h_field_type);
		strcpy((*l_temp_ptr) -> h_label,l_gfu_format_map_h -> h_label);
		strcpy((*l_temp_ptr) -> h_seq,l_gfu_format_map_h -> h_seq);
		strcpy((*l_temp_ptr) -> h_start,l_gfu_format_map_h -> h_start);
		strcpy((*l_temp_ptr) -> h_end,l_gfu_format_map_h -> h_end);
		strcpy((*l_temp_ptr) -> h_remove_char,l_gfu_format_map_h -> h_remove_char);
		strcpy((*l_temp_ptr) -> h_remove_last_char,l_gfu_format_map_h -> h_remove_last_char);
		strcpy((*l_temp_ptr) -> h_static_val,l_gfu_format_map_h -> h_static_val);
		strcpy((*l_temp_ptr) -> h_val_type,l_gfu_format_map_h -> h_val_type);
		strcpy((*l_temp_ptr) -> h_date_format,l_gfu_format_map_h -> h_date_format);
		strcpy((*l_temp_ptr) -> h_header,l_gfu_format_map_h -> h_header);
		(*l_temp_ptr) -> h_srl_no = l_gfu_format_map_h -> h_srl_no;
		strcpy((*l_temp_ptr) -> h_repeat,l_gfu_format_map_h -> h_repeat);
		strcpy((*l_temp_ptr) -> h_query,l_gfu_format_map_h -> h_query);
		(*l_temp_ptr) -> h_next = (GFU_FORMAT_MAP_STRUCT_LST *)NULL;
		l_cnt++;


	}
	EXEC SQL CLOSE l_cur_format_map;
	IS_ANY_ORA_ERROR
	if(!l_cnt)APL_GOBACK_FAIL
	APL_GOBACK_SUCCESS
RETURN_FAILURE:
	
	APL_FREE(l_gfu_format_map_h);
	APL_FREE(l_gfu_format_map_i);
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:

	APL_FREE(l_gfu_format_map_h);
	APL_FREE(l_gfu_format_map_i);
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}



/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GF_Chk_Header_Format															 *
 *                                                                                                       *
 * Description           : This Function is used to Validate Against header							     *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_gfu_file_map_h					   GFU_FILE_MAP_STRUCT_H *			I	   Conatins Details about the file *
 *																										 *
 * p_gfu_format_map_lst				   GFU_FORMAT_MAP_STRUCT_LST **		I      Format List				 *
 *																										 *
 * p_gfu_header_map_lst				   GFU_FORMAT_MAP_STRUCT_LST **		I      Header List				 *
 *																									     *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/

int GF_Chk_Header_Format(	GFU_FILE_MAP_STRUCT_H *p_gfu_file_map_h,
							GFU_FORMAT_MAP_STRUCT_LST **p_gfu_format_map_lst,
							GFU_FORMAT_MAP_STRUCT_LST **p_gfu_header_map_lst,
							DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	GFU_FORMAT_MAP_STRUCT_LST **l_format = p_gfu_format_map_lst;
	GFU_FORMAT_MAP_STRUCT_LST **l_header;
APL_FUNCTION_ENTER(l_logfile)


	if(!strcmp(p_gfu_file_map_h -> h_check_header,"N"))APL_GOBACK_SUCCESS
	while((*l_format))
	{
		l_header = p_gfu_header_map_lst;
		while((*l_header))
		{
			if(!strcmp((*l_header) -> h_header,(*l_format) -> h_header) && strcmp((*l_format) -> h_field_type,"STATIC") && (*((*l_format) -> h_field_type) != GF_DELIM_CHAR_HASH))
			{
				if(strcmp((*l_header) -> h_start,(*l_format) -> h_start))
				{
BT_IF_DEBUG
					fprintf(l_logfile,"Header Format Not Matching |%s| |%s| On Start\n",(*l_header) -> h_start,(*l_format) -> h_start);
					APL_GOBACK_FAIL
				}
				if(strcmp((*l_header) -> h_end,(*l_format) -> h_end))
				{
BT_IF_DEBUG
					fprintf(l_logfile,"Header Format Not Matching |%s| |%s| On End\n",(*l_header) -> h_end,(*l_format) -> h_end);
					APL_GOBACK_FAIL
				}
			}
			printf("Matching |%s| |%s|\n",(*l_header) -> h_header,(*l_format) -> h_header);
			l_header = &((*l_header)->h_next);
			
		}
		l_format = &((*l_format)->h_next);
	}
APL_GOBACK_SUCCESS
RETURN_FAILURE:
	
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}



/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Rtv_File																     *
 *                                                                                                       *
 * Description           : This Function is used parse parametr string, get file pointer				 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_gfu_file_map_h					   GFU_FILE_MAP_STRUCT_H *			I	   Conatins Details about the file *
 *																										 *
 * p_file							   FILE	**							O      File pointer returned	 *
 *																									     *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/

int GFU_Rtv_File(	GFU_FILE_MAP_STRUCT_H *p_gfu_file_map_h,
			FILE **p_file,
			DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;
	char l_skip_line[GFU_SKIP_LINE_LEN];
	char l_cfg_filename[GFU_PATH_LEN];
	char l_param_data[GFU_LINE_LEN];
	char l_upl_dir[GFU_PATH_LEN];
	FILE *fp_cfg = (FILE *)NULL;

	/* Added by Kalyan */
	OCIBlobLocator *l_blob;
	char l_buff[5000];
	int l_len=4294967295; // This is the max length a blob can store
	char l_blobid[9];
	char l_blob_flag[3];
	FILE *l_up_file;
	
	memset(l_buff,NULL,sizeof(l_buff));

	EXEC SQL VAR l_buff IS RAW(5000);
	EXEC SQL ALLOCATE :l_blob;

	/* Till here */

	memset(l_param_data,APL_NULL_CHAR,sizeof(l_param_data));
	strcpy(l_param_data,g_param_data);

	strcpy(l_cfg_filename,getenv("INTL_ROOT_PATH"));
	strcat(l_cfg_filename,"/intl_sun.cfg");
	APL_FUNCTION_ENTER(l_logfile)
	fp_cfg = fopen(l_cfg_filename,"r");
	
	if(fp_cfg == (FILE *)NULL)
	{
BT_IF_DEBUG
		fprintf(l_logfile, "Config File |%s|\n",l_cfg_filename);
BT_IF_DEBUG
		CO_ProcMonitor(l_logfile,"Failed To Open Config File",NULL,NULL);
		
		APL_GOBACK_FAIL
	}
	
	CO_Rtv_DataString(l_param_data,"FILE_NAME",p_gfu_file_map_h -> h_file_name);
	memset(g_file_name,APL_NULL_CHAR,sizeof(g_file_name));
	strcpy(g_file_name,p_gfu_file_map_h -> h_file_name);

	memset(p_gfu_file_map_h -> h_skip_line,APL_NULL_CHAR,sizeof(p_gfu_file_map_h -> h_skip_line));
	strcpy(p_gfu_file_map_h -> h_skip_line,GFU_SKIP_LINE_DEL);
	CO_Rtv_DataString(l_param_data,"SKIP_LINE",l_skip_line);
	strcat(p_gfu_file_map_h -> h_skip_line,l_skip_line);
	strcat(p_gfu_file_map_h -> h_skip_line,GFU_SKIP_LINE_DEL);
	CO_Rtv_DataString(l_param_data,"REFNO",p_gfu_file_map_h -> h_refno);
	CO_Rtv_DataString(l_param_data,"FILE_TYPE",p_gfu_file_map_h -> h_file_type);
	CO_Rtv_DataString(l_param_data,"MODULE",p_gfu_file_map_h -> h_module);
	CO_Rtv_DataString(l_param_data,"DELIM",p_gfu_file_map_h -> h_delimiter);
	CO_Rtv_DataInt(l_param_data,"HEADER",&(p_gfu_file_map_h -> h_header));
	
	CO_Rtv_DataInt(l_param_data,"FORMAT_LINE",&(p_gfu_file_map_h -> h_format_no));
	CO_Rtv_DataString(l_param_data,"MAKER",p_gfu_file_map_h -> h_maker);
	CO_Rtv_DataString(l_param_data,"CHECKHEADER",p_gfu_file_map_h -> h_check_header);
	CO_Rtv_DataString(l_param_data,"MAKERDT",p_gfu_file_map_h -> h_maker_dt);
	CO_Rtv_DataString(l_param_data,"ACCESS_STAMP",p_gfu_file_map_h -> h_access_stamp);
	CO_Rtv_DataString(l_param_data,"VENDOR",p_gfu_file_map_h -> h_vendor);
	if ( CO_ReadToken(fp_cfg,"INTL_UPL_PATH",l_upl_dir,l_debug_info_ptr) == APL_FAILURE)
		APL_GOBACK_FAIL
	/* Added by Kalyan */
	if ( CO_ReadToken(fp_cfg,"INTL_BLOB_FLAG",l_blob_flag,l_debug_info_ptr) == APL_FAILURE)
	{
		printf("KS --- Could not find BLOB FLAG in Config\n");
		printf("KS --- Assuming that the file is local and setting flag to [N] \n");
		strcpy(l_blob_flag,"N");
	}
	printf("\nKS -- INTL_BLOG_FLAG VALUE IS [%s]\n",l_blob_flag);

        CO_Rtv_DataString(l_param_data,"BLOBID",l_blobid);
        printf("KS --- blobid value [%s]\n",l_blobid);

	/* Till here */

	strcat(l_upl_dir,p_gfu_file_map_h -> h_file_name);
BT_IF_DEBUG
	fprintf(l_logfile, "File |%s||%s|\n",l_upl_dir,p_gfu_file_map_h -> h_file_type);

	if(p_file == (FILE **)NULL)APL_GOBACK_SUCCESS;

	/* Added by Kalyan */
	if(strcmp(l_blob_flag,"Y")==0)
	{
		printf("\n Entered [Y] block \n");
	        EXEC SQL SELECT UPLD_DATA into :l_blob FROM PRO_REQUEST_UPLOAD where UPLD_ID = :l_blobid;
               	if (sqlca.sqlcode != 0)
               	{
                       	printf("KS --- error [%d] \n",sqlca.sqlcode);
			APL_GOBACK_FAIL
               	}

        	l_up_file=fopen(l_upl_dir,"w");

        	while(1)
        	{
                	EXEC SQL LOB READ :l_len FROM :l_blob INTO :l_buff;
                	fwrite(l_buff,5000,1,l_up_file);
                	if(sqlca.sqlcode == 1403)
                	{
                        	printf("KS --- BLOB Work completed \n");
                       		break;
                	}
                	else if (sqlca.sqlcode != 0)
                	{
                        	printf("KS --- Ooops..... error [%d] \n",sqlca.sqlcode);
				APL_GOBACK_FAIL
                	}
                	memset(l_buff,APL_NULL_CHAR,sizeof(l_buff)); //AIX - Warnings Removal

        	}

        	fclose(l_up_file);
	}
	/* Till here */

	if(!strcmp(p_gfu_file_map_h -> h_file_type,GFU_BINARY_FILE) )
	{
		*p_file = fopen(l_upl_dir,"rb");
		l_bk_file = fopen(l_upl_dir,"rb");
	}
	else if(!strcmp(p_gfu_file_map_h -> h_file_type,GFU_ASCII_FILE) || !strcmp(p_gfu_file_map_h -> h_file_type,"P"))
	{
		*p_file = fopen(l_upl_dir,"r");
		l_bk_file = fopen(l_upl_dir,"r");
	}

	if (*p_file == (FILE *)NULL || l_bk_file == (FILE *)NULL)
	{
		
		printf("Failed To Open file|%s|\n",p_gfu_file_map_h -> h_file_name);
		APL_GOBACK_FAIL
	}
	APL_GOBACK_SUCCESS

RETURN_FAILURE:
	if(fp_cfg != (FILE *)NULL)fclose(fp_cfg);
	APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	if(fp_cfg != (FILE *)NULL)fclose(fp_cfg);
	APL_FUNCTION_RET_SUCCESS(l_logfile)

}



/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Rtv_ReqMap																 *
 *                                                                                                       *
 * Description           : This Function is used to retrive request details, wrapper,sp name etc.		 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_module							   char *							I	   Module name				 *
 *																										 *
 * p_gfu_file_map_h					   GFU_REQ_MAP_STRUCT_H *			O	   Request Details			 *
 *																										 *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/


int GFU_Rtv_ReqMap(	char *p_module, 
					GFU_REQ_MAP_STRUCT_H *p_gfu_req_map_h,
					DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;

	APL_FUNCTION_ENTER(l_logfile)
	GFU_REQ_MAP_STRUCT_I *l_gfu_req_map_i = (GFU_REQ_MAP_STRUCT_I *)NULL;
	l_gfu_req_map_i = (GFU_REQ_MAP_STRUCT_I *)calloc(1,sizeof(GFU_REQ_MAP_STRUCT_I));
	EXEC SQL SELECT GFREQMAP.*
				INTO :p_gfu_req_map_h:l_gfu_req_map_i
				FROM GFREQMAP
				WHERE MODULE = :p_module;

	IS_ANY_ORA_ERROR

APL_GOBACK_SUCCESS
RETURN_FAILURE:
	APL_FREE(l_gfu_req_map_i);
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FREE(l_gfu_req_map_i);
	APL_FUNCTION_RET_SUCCESS(l_logfile)

}


/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Rtv_Env																 *
 *                                                                                                       *
 * Description           : This Function is used to get details for environment string					 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_module							   char *							I	   Module Name				 *
 *																										 *
 * p_gfu_val_map_lst				   GFU_TOKEN_VAL_STRUCT_LST **		O	   list with details		 *
 *																									     *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/




int GFU_Rtv_Env(	char *p_module,
					GFU_TOKEN_VAL_STRUCT_LST **p_gfu_val_map_lst,
					DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;
	GFU_TOKEN_VAL_STRUCT_LST **l_temp_ptr = p_gfu_val_map_lst;
	GFU_ENV_MAP_STRUCT_I		*l_gfu_env_map_i = (GFU_ENV_MAP_STRUCT_I *)NULL;
	GFU_ENV_MAP_STRUCT_H		*l_gfu_env_map_h =(GFU_ENV_MAP_STRUCT_H *)NULL;

	APL_FUNCTION_ENTER(l_logfile)

	EXEC SQL DECLARE l_cur_env_map CURSOR FOR
			SELECT GFENVMAP.*
			FROM GFENVMAP
			WHERE MODULE = :p_module;
	IS_ANY_ORA_ERROR

	EXEC SQL OPEN l_cur_env_map;
	IS_ANY_ORA_ERROR

	l_gfu_env_map_h = (GFU_ENV_MAP_STRUCT_H *)calloc(1,sizeof(GFU_ENV_MAP_STRUCT_H));
	l_gfu_env_map_i = (GFU_ENV_MAP_STRUCT_I *)calloc(1,sizeof(GFU_ENV_MAP_STRUCT_I));	

	for(;;)
	{
		memset(l_gfu_env_map_h,APL_NULL_CHAR,sizeof(l_gfu_env_map_h)); //AIX - Warnings Removal
		memset(l_gfu_env_map_i,APL_NULL_CHAR,sizeof(l_gfu_env_map_i));
		
		EXEC SQL FETCH l_cur_env_map
					INTO :l_gfu_env_map_h:l_gfu_env_map_i;


		if(sqlca.sqlcode == 1403)break;
		IS_ANY_ORA_ERROR

		while((*l_temp_ptr) != (GFU_TOKEN_VAL_STRUCT_LST *)NULL)
		{
			l_temp_ptr = &((*l_temp_ptr)->h_next);
		}
		if(((*l_temp_ptr) = (GFU_TOKEN_VAL_STRUCT_LST *)calloc(1,sizeof(GFU_TOKEN_VAL_STRUCT_LST))) == NULL)
		{
			APL_GOBACK_FAIL
		}
		strcpy((*l_temp_ptr) -> h_token, l_gfu_env_map_h -> h_token);
		Remove_Last_Char(l_gfu_env_map_h -> h_value,GF_DELIM_STR_SPACE,l_debug_info_ptr);
		strcpy((*l_temp_ptr) -> h_value, l_gfu_env_map_h -> h_value);
	}
	EXEC SQL CLOSE l_cur_env_map;
APL_GOBACK_SUCCESS
RETURN_FAILURE:
	APL_FREE(l_gfu_env_map_h);
	APL_FREE(l_gfu_env_map_i);
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FREE(l_gfu_env_map_h);
	APL_FREE(l_gfu_env_map_i);
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}


/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Process_File																 *
 *                                                                                                       *
 * Description           : This Function is used to Process The file									 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_process_name					   char *							I      Name of the process		 *
 *																									     *
 * p_process_key					   char *							I      Key of the Process		 *
 *																										 *
 * p_start_date						   char *							I	   Started Date				 *
 *																										 *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/




int GFU_Process_File(	char *p_process_name,
			char *p_process_key,
			char *p_start_date,
			char *p_user,
			FILE *p_file,
			DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{

	/**FILE *l_file = p_file;**/
	/**GFU_FILE_MAP_STRUCT_H *g_gfu_file_map_h = (GFU_FILE_MAP_STRUCT_H *)NULL;**/
	/**GFU_FILE_LST **l_file_lst = (GFU_FILE_LST **)NULL;**/
	GFU_VAL_MAP_STRUCT_LST **l_gfu_val_map_lst = (GFU_VAL_MAP_STRUCT_LST **)NULL;
	GFU_REQ_MAP_STRUCT_H *l_gfu_req_map_h = (GFU_REQ_MAP_STRUCT_H *)NULL;
	GFU_TOKEN_VAL_STRUCT_LST **l_gfu_env_map_lst = (GFU_TOKEN_VAL_STRUCT_LST **)NULL;

		
	/** Free............... **/
	GFU_VAL_MAP_STRUCT_LST *l_gfu_val_map_free = (GFU_VAL_MAP_STRUCT_LST *)NULL;
	GFU_TOKEN_VAL_STRUCT_LST *l_gfu_env_map_free = (GFU_TOKEN_VAL_STRUCT_LST *)NULL;
	GFU_FILE_LST *l_file_free = (GFU_FILE_LST *)NULL;
	GFU_TOKEN_VAL_STRUCT_LST *l_token_val_free = (GFU_TOKEN_VAL_STRUCT_LST *)NULL;

	/** Free............... **/

	/**g_gfu_file_map_h = (GFU_FILE_MAP_STRUCT_H *)calloc(1,sizeof(GFU_FILE_MAP_STRUCT_H));**/
	/**l_file_lst = (GFU_FILE_LST **)calloc(1,sizeof(GFU_FILE_LST *));	**/
	l_gfu_val_map_lst = (GFU_VAL_MAP_STRUCT_LST **)calloc(1,sizeof(GFU_VAL_MAP_STRUCT_LST *));
	l_gfu_env_map_lst = (GFU_TOKEN_VAL_STRUCT_LST **)calloc(1,sizeof(GFU_TOKEN_VAL_STRUCT_LST *));
	l_gfu_req_map_h = (GFU_REQ_MAP_STRUCT_H *)calloc(1,sizeof(GFU_REQ_MAP_STRUCT_H));

	APL_FUNCTION_ENTER(l_logfile)

	/**if(APL_FAILURE == GFU_Rtv_File(	g_gfu_file_map_h,
					&l_file,
					l_debug_info_ptr))
	{
		printf("Failed in GFU_Rtv_File\n");
		APL_GOBACK_FAIL
	}*/
	if(APL_FAILURE == GFU_Rtv_ReqMap(	g_gfu_file_map_h -> h_module,
						l_gfu_req_map_h,
						l_debug_info_ptr))
	{
		printf("Failed in GFU_Rtv_ReqMap\n");
		APL_GOBACK_FAIL
	}
	if(APL_FAILURE == GFU_Rtv_Env(	g_gfu_file_map_h -> h_module,
					l_gfu_env_map_lst,
					l_debug_info_ptr))
	{
		printf("Failed in GFU_Rtv_Env\n");
		APL_GOBACK_FAIL
	}
	if(APL_FAILURE == GFU_Conv_Lnk_Lst(	p_file,
						p_process_name,
						p_process_key,
						p_start_date,
						g_gfu_file_map_h,
						l_gfu_env_map_lst,
						l_gfu_val_map_lst,
						l_gfu_req_map_h,
						l_debug_info_ptr))
	{
		printf("Failed in GFU_Conv_Lnk_Lst\n");
		APL_GOBACK_FAIL
	}
	
	


	/**if(APL_FAILURE ==  GFU_Process_Lst(l_file_lst,
					p_process_name,
					p_process_key,
					p_start_date,
					l_gfu_val_map_lst,
					l_gfu_req_map_h,
					l_gfu_env_map_lst,
					l_debug_info_ptr))
	{
		printf("Failed in GFU_Process_Lst\n");
		APL_GOBACK_FAIL
	}
	**/
	
	if( GFU_Summ_Rpt( p_start_date,
							p_process_name,
							p_user,
							l_userfile,
							l_logfile,
							l_skipped_file,
							l_format_file,
							g_gfu_file_map_h -> h_module,
							l_debug_info_ptr) == APL_FAILURE)
	{
		CO_ProcMonitor(l_logfile,"Failed in GFU_Summ_Rpt",NULL,NULL);
		APL_GOBACK_FAIL
	}	

APL_GOBACK_SUCCESS

RETURN_FAILURE:
	/**if(l_file != (FILE *)NULL)fclose(l_file);**/
	
	
	/**APL_FREE(g_gfu_file_map_h)**/
	APL_FREE(l_gfu_req_map_h)

        while(*l_gfu_val_map_lst)
        {
                l_gfu_val_map_free = (*l_gfu_val_map_lst) -> h_next;
                APL_FREE((*l_gfu_val_map_lst));
                (*l_gfu_val_map_lst) = l_gfu_val_map_free;
        }

while(*l_gfu_env_map_lst)
{
	l_gfu_env_map_free = (*l_gfu_env_map_lst) -> h_next;
	APL_FREE((*l_gfu_env_map_lst));
	(*l_gfu_env_map_lst) = l_gfu_env_map_free;
}
/**
while(*l_file_lst)
{
	l_file_free = (*l_file_lst) -> h_next;

	while((*((*l_file_lst) -> h_token_val)))
	{
		l_token_val_free = (*((*l_file_lst) -> h_token_val)) -> h_next;
		APL_FREE((*((*l_file_lst) -> h_token_val)))
			(*((*l_file_lst) -> h_token_val)) =  l_token_val_free;
	}
	APL_FREE((*l_file_lst));
	(*l_file_lst) = l_file_free;
}

**/

APL_FUNCTION_RET_FAILURE(l_logfile)

	RETURN_SUCCESS:
	/**if(l_file != (FILE *)NULL)fclose(l_file);**/

/**	APL_FREE(l_gfu_file_map_h)**/
	APL_FREE(l_gfu_req_map_h)
while(*l_gfu_val_map_lst)
{
	l_gfu_val_map_free = (*l_gfu_val_map_lst) -> h_next;
	APL_FREE((*l_gfu_val_map_lst));
	(*l_gfu_val_map_lst) = l_gfu_val_map_free;
}

while(*l_gfu_env_map_lst)
{
	l_gfu_env_map_free = (*l_gfu_env_map_lst) -> h_next;
	APL_FREE((*l_gfu_env_map_lst));
	(*l_gfu_env_map_lst) = l_gfu_env_map_free;
}
/**
while(*l_file_lst)
{
	l_file_free = (*l_file_lst) -> h_next;

	while((*((*l_file_lst) -> h_token_val)))
	{
		l_token_val_free = (*((*l_file_lst) -> h_token_val)) -> h_next;
		APL_FREE((*((*l_file_lst) -> h_token_val)))
			(*((*l_file_lst) -> h_token_val)) =  l_token_val_free;
	}
	APL_FREE((*l_file_lst));
	(*l_file_lst) = l_file_free;
}
**/
APL_FUNCTION_RET_SUCCESS(l_logfile)
	}




int main(int argc,char **argv)
{
	struct sqlca sqlca;
	int i = 0;

     /* Added by kotubabu for Linux Migration -START*/
		#ifdef OS_LINUX
        l_logfile = APL_OUT_FILE;
        l_skipped_file= APL_OUT_FILE;
        l_userfile= APL_OUT_FILE;
        l_format_file = APL_OUT_FILE;
        l_bk_file = APL_OUT_FILE;
        l_faillog = APL_OUT_FILE;
        l_statvallog = APL_OUT_FILE;
        #endif
     /* Added by kotubabu for Linux Migration -END*/
	FILE *chr_finifile = NULL;
	/**GFU_FILE_MAP_STRUCT_H l_gfu_file_map_h;**/
	char chr_inifile[150],chr_l_uname[APL_USERID_LEN],chr_l_passwd[APL_PASSWD_LEN],chr_custody_id_b[APL_USERID_LEN],chr_buffer[KEY_LENGTH];
	DEBUG_INFO_STRUCT_H  **l_debug_info_ptr = (DEBUG_INFO_STRUCT_H **)NULL;
	INTL_ENV_DATA_STRUCT_H  l_intl_envdatastruct_h;
	char l_rep_name[14]  = APL_NULL_STRING;
	char l_rep_name_temp[1000]  = APL_NULL_STRING; /* changes by amish -21/09/2006 */
	FILE *l_file = (FILE *)NULL;
	char l_failurelog[1000]	 = APL_NULL_STRING; /* changes by amish -21/09/2006 */
	char l_failurelog_rm[1000]	 = APL_NULL_STRING; /* changes by amish -21/09/2006 */
	char l_statlog[1000]	 = APL_NULL_STRING; 
	char l_buf[1000]                    =  APL_NULL_STRING; /* changes by amish -21/09/2006 */
	
	int retval = 0; /* changes by amish -21/09/2006 */
     int int_retval = 0;
	int l_filesize = 0; /* for test - to be deleted */
	char l_fsize_char[10] = APL_NULL_STRING; /* for test - to be deleted */
	char	chr_l_fname[PATH_LENGTH] 	= APL_NULL_STRING;
	
	char l_logfile_name[GFU_PATH_LEN] = APL_NULL_STRING;
		char l_failurelog_tmp[GFU_PATH_LEN]  = APL_NULL_STRING; 
		char l_statlog_tmp[GFU_PATH_LEN]  = APL_NULL_STRING; 
		char l_statlog_rm[GFU_PATH_LEN]  = APL_NULL_STRING; 

	APL_FUNCTION_ENTER(APL_OUT_FILE)
		l_debug_info_ptr = (DEBUG_INFO_STRUCT_H   **)calloc(1,sizeof(DEBUG_INFO_STRUCT_H *));

	fprintf(APL_OUT_FILE,"\n\n\n**********************Enters the Great GFU************************\n");
	MAIN_ARG



		memset(g_param_data,APL_NULL_CHAR,sizeof(g_param_data));
	strcpy(g_param_data,argv[9]);

	memset(chr_inifile,APL_NULL_CHAR,150);
	memset(chr_buffer,APL_NULL_CHAR,KEY_LENGTH);
	memset(chr_l_uname,APL_NULL_CHAR,40);
	memset(chr_l_passwd,APL_NULL_CHAR,40);
	memset(l_failurelog,APL_NULL_CHAR,1000); /* changes by amish -21/09/2006 */
	memset(l_rep_name_temp,APL_NULL_CHAR,1000); /* changes by amish -21/09/2006 */
	memset(l_failurelog_rm,APL_NULL_CHAR,1000); /* changes by amish -21/09/2006 */
	memset(l_logfile_name,APL_NULL_CHAR,GFU_PATH_LEN); /* changes by amish -21/09/2006 */
	memset(l_failurelog_tmp,APL_NULL_CHAR,GFU_PATH_LEN); /* changes by amish -21/09/2006 */
	memset(l_statlog_tmp,APL_NULL_CHAR,GFU_PATH_LEN); /* changes by amish -21/09/2006 */
	memset(l_statlog_rm,APL_NULL_CHAR,GFU_PATH_LEN); /* changes by amish -21/09/2006 */


	memset(l_buf, APL_NULL_CHAR,1000);
	strcpy(chr_inifile,getenv("INTL_ROOT_PATH"));
	strcat(chr_inifile,"/intl_sun.cfg");
	fflush(stdout);
	if ( (chr_finifile = fopen(chr_inifile,"r") ) == NULL)
		APL_GOBACK_FAIL;
	fflush(stdout);
	strcpy(g_sys_date,argv[2]);


	
/*	memset(chr_l_inifile_t, APL_NULL_CHAR, PATH_LENGTH);  PJ */


	/*
	 *    if(APL_FAILURE == CO_Get_DBConnect(l_debug_info_ptr))
	 *       {
	 *             CO_ProcMonitor(APL_OUT_FILE,"Failed in CO_Get_DBConnect",NULL,NULL);
	 *                   APL_GOBACK_FAIL
	 *                      }
	 *                      */

	APL_FETCH_DB_LOGIN_DETAILS(chr_finifile, chr_custody_id_b, chr_l_uname, chr_l_passwd , APL_OUT_FILE , l_debug_info_ptr)
		EXEC SQL CONNECT :chr_l_uname IDENTIFIED BY :chr_l_passwd;

	g_gfu_file_map_h = (GFU_FILE_MAP_STRUCT_H *)calloc(1,sizeof(GFU_FILE_MAP_STRUCT_H));

	if( GFU_Rtv_File( g_gfu_file_map_h,
				&l_file,
				l_debug_info_ptr) == APL_FAILURE)
	{
		APL_GOBACK_FAIL
	}

	strcpy(l_rep_name,"GF_");
	strncat(l_rep_name,g_gfu_file_map_h -> h_refno,10);
	strcat(l_rep_name,APL_NULL_STRING);
	l_rep_name[14] = APL_NULL_CHAR;
	if ( CO_Rtv_RptFileName(l_rep_name,
				"Technical Log",
				100,
				argv[5],
				argv,
				&l_logfile,
				l_debug_info_ptr) == APL_FAILURE)
	{
		/*
		fprintf(l_logfile,"Failed in CO_Rtv_RptFileName",NULL,NULL);
		*/
		printf("\n**************failed in co retrive file name\n");
		APL_GOBACK_FAIL
	}

	sleep(1);
	if ( CO_Rtv_RptFileName(l_rep_name,
				"Skipped/Error Lines",
				500,
				argv[5],
				argv,
				&l_skipped_file,
				l_debug_info_ptr) == APL_FAILURE)
	{
		/*
		fprintf(l_logfile,"Failed in CO_Rtv_RptFileName",NULL,NULL);
		*/
		APL_GOBACK_FAIL
	}
	sleep(1);

	printf("\n***********55amish******************* ");
	if ( CO_Rtv_RptFileName(l_rep_name,
				"User Log",
				500,
				argv[5],
				argv,
				&l_userfile,
				l_debug_info_ptr) == APL_FAILURE)
	{
		/*
		fprintf(l_logfile,"Failed in CO_Rtv_RptFileName",NULL,NULL);
		*/
		APL_GOBACK_FAIL
	}
	BT_IF_DEBUG
		CO_ProcMonitor(l_userfile,"Processing Started",NULL,NULL);
	BT_IF_DEBUG
		fprintf(l_userfile,"%s\t%s\t%s\t%s\t%s\t%s\n","LINE","SKIPPED","TOKEN","VALUE","STATUS","REASON");
	sleep(1);
	
		printf("\n***********BEFORE FAILURE LOG CREATION******************* ");

	if ( CO_Rtv_RptFileName(l_rep_name,
				"FAILURE LOG",
				500,
				argv[5],
				argv,
				&l_faillog,
				l_debug_info_ptr) == APL_FAILURE)
	{
					printf("\n***********in  FAILURE LOG CREATION******************* ");

		/*
		fprintf(l_faillog,"Failed in CO_Rtv_RptFileName",NULL,NULL);
		*/
		APL_GOBACK_FAIL
	}
	BT_IF_DEBUG
		CO_ProcMonitor(l_faillog,"Processing Started",NULL,NULL);
	BT_IF_DEBUG
		fprintf(l_faillog,"%s\t%s\t%s\t%s\t%s\t%s\n","LINE","SKIPPED","TOKEN","VALUE","STATUS","REASON");
	sleep(1);
			printf("\n***********after FAILURE LOG CREATION******************* ");


	if ( CO_Rtv_RptFileName(l_rep_name,
				"STATIC VAL LOG",
				500,
				argv[5],
				argv,
				&l_statvallog,
				l_debug_info_ptr) == APL_FAILURE)
	{
					printf("\n***********in  FAILURE LOG CREATION******************* ");
		/*
		fprintf(l_statvallog,"Failed in CO_Rtv_RptFileName",NULL,NULL);
		*/
		APL_GOBACK_FAIL
	}
	BT_IF_DEBUG
		CO_ProcMonitor(l_statvallog,"Processing Started",NULL,NULL);
	BT_IF_DEBUG
		fprintf(l_statvallog,"%s\t%s\t%s\t%s\t%s\t%s\n","LINE","SKIPPED","TOKEN","VALUE","STATUS","REASON");
	sleep(1);
	

	if ( CO_Rtv_RptFileName(l_rep_name,
				"Format File",
				100,
				argv[5],
				argv,
				&l_format_file,
				l_debug_info_ptr) == APL_FAILURE)
	{
		/*
		fprintf(l_logfile,"Failed in CO_Rtv_RptFileName",NULL,NULL);
		*/
		APL_GOBACK_FAIL
	}
	BT_IF_DEBUG
		fprintf(l_format_file,"\t%s\t%s\t%s\t%s\n","HEADER","SEQ","START","END");
	BT_IF_DEBUG
		CO_ProcMonitor(l_logfile,"Got the Report",NULL,NULL);
	sleep(1);

/*
		printf("\n***********BEFORE FAILURE LOG CREATION******************* ");

	if ( CO_Rtv_RptFileName(l_rep_name,
				"FAILURE LOG",
				500,
				argv[5],
				argv,
				&l_faillog,
				l_debug_info_ptr) == APL_FAILURE)
	{
					printf("\n***********in  FAILURE LOG CREATION******************* ");

		CO_ProcMonitor(l_faillog,"Failed in CO_Rtv_RptFileName",NULL,NULL);
		APL_GOBACK_FAIL
	}
	BT_IF_DEBUG
		CO_ProcMonitor(l_faillog,"Processing Started",NULL,NULL);
	BT_IF_DEBUG
		fprintf(l_faillog,"%s\t%s\t%s\t%s\t%s\t%s\n","LINE","SKIPPED","TOKEN","VALUE","STATUS","REASON");
	sleep(1);
			printf("\n***********after FAILURE LOG CREATION******************* ");

*/


	BT_IF_DEBUG
		CO_ProcMonitor(APL_OUT_FILE,"Got The Connection !!!",NULL,NULL);
	if(APL_FAILURE == BT_Status_Lock(   argv[0],
				argv[1],
				argv[2],
				l_debug_info_ptr))
	{

		APL_GOBACK_FAIL
	}

	printf("\n***********66amish********* ");

	for( i = 0; i<argc ; i++)
	{
		fprintf(APL_OUT_FILE,"Arguement %d |%s|\n",i,argv[i]);
	}
	if ( CO_RtvSysParams(l_debug_info_ptr) == APL_FAILURE)
		APL_GOBACK_FAIL

/*
	printf("\n***********77amish*********|%s| ",l_rep_name);
*/

	if(APL_FAILURE == GFU_Process_File( argv[0],argv[1],argv[2],argv[5] ,l_file,l_debug_info_ptr))
	{
     /*** AIX migration chnges to remove warnings -- too many arguments for format 
		fprintf(l_logfile,"Failed in GFU_Process_File",NULL,NULL); **/

      fprintf(l_logfile,"Failed in GFU_Process_File");
		/*
		APL_GOBACK_FAIL  changes by amish -21/09/2006 */
		
	}
	/*

		if ( CO_Rtv_RptFileName(l_rep_name,
				"User Log",
				500,
				argv[5],
				argv,
				&l_userfile,
				l_debug_info_ptr) == APL_FAILURE)
	{
		CO_ProcMonitor(l_logfile,"Failed in CO_Rtv_RptFileName",NULL,NULL);
		APL_GOBACK_FAIL
	}
*/


/* changes by amish -21/09/2006  -------------start*/
	if ( APL_FAILURE == CO_ReadToken(   chr_finifile,
      	                                 "INTL_REP_PATH",
         	                              chr_l_fname,
            	                           l_debug_info_ptr ))
   	{
      	APL_GOBACK_FAIL
   	}

printf("path is*****************************|%s|",chr_l_fname);

		if(CO_Rtv_FileNm_From_Pointer(	l_userfile,
												chr_l_fname,
												l_logfile_name) == APL_FAILURE)
	{
		 APL_GOBACK_FAIL
	}	

/*

		if(CO_Rtv_FileSize_From_Pointer(	l_userfile,
												chr_l_fname,
												&l_filesize) == APL_FAILURE)
	{
		 APL_GOBACK_FAIL
	}	
	printf("*************testing*********file size is |%d|",l_filesize);
	strcpy(l_fsize_char,ltoa(l_filesize));
	printf("*************file name in cha*********file size is |%s|",l_fsize_char);
	
	
	 	 int_retval =	 CO_PadString(l_fsize_char,"L",9,"0",l_debug_info_ptr);

	 if (int_retval != APL_SUCCESS)
		 APL_GOBACK_FAIL

 printf("*************file name in cha after pad func*********file size is |%s|",l_fsize_char);
	printf("Name |%s| \n",l_logfile_name);

*/	
	strcpy(l_rep_name_temp,chr_l_fname);
	strcat(l_rep_name_temp,l_logfile_name);

	/*
		strcpy(l_failurelog,l_rep_name_temp);
		strcat(l_failurelog,"_FAIL");
		*/

	/*
	strcat(l_rep_name_temp,"*");
	*/
	






	
	if(CO_Rtv_FileNm_From_Pointer(	l_faillog,
												chr_l_fname,
												l_failurelog_tmp) == APL_FAILURE)
	{
		 APL_GOBACK_FAIL
	}	
	
		
	/*	
	strcat(l_failurelog_tmp,"_FAIL");
	*/
	strcpy(l_failurelog,chr_l_fname);
	strcat(l_failurelog,l_failurelog_tmp);
	strcpy(l_failurelog_rm,l_failurelog);
	strcat(l_failurelog_rm,"_FAIL");
	printf("\n***********88amish*********failure file name widout path is |%s|\n",l_failurelog_tmp);
	printf("\n***********88amish*********orig file name is |%s|\n",l_rep_name_temp);
	printf("\n***********88amish*********failure  file name is |%s|\n",l_failurelog);

		APL_CLOSE_FILE(l_faillog);

	sprintf(l_buf,"grep -i 'FAILURE' %s >> %s",l_rep_name_temp,l_failurelog);
    printf("\nCommand = |%s| ",l_buf);
    retval = system(l_buf);
    printf("\n GREP COMMAND EXECUTED WITH status = |%d|\n ",retval);
    memset(l_buf, APL_NULL_CHAR , 1000);
	
	printf("\n***********88amish*********orig fail file is |%s|\n",l_failurelog);
	printf("\n***********88amish*********renaming path  is |%s|\n",l_failurelog_rm);
	
	/*
	sprintf(l_buf,"mv %s %s",l_failurelog,l_failurelog_rm);
    printf("\nCommand = |%s| ",l_buf);
    retval = system(l_buf);
    printf("\n GREP COMMAND EXECUTED WITH status = |%d|\n ",retval);
	*/
    memset(l_buf, APL_NULL_CHAR , 1000);


	if(CO_Rtv_FileNm_From_Pointer(	l_statvallog,
												chr_l_fname,
												l_statlog_tmp) == APL_FAILURE)
	{
		 APL_GOBACK_FAIL
	}	

	
		strcpy(l_statlog,chr_l_fname);
	strcat(l_statlog,l_statlog_tmp);
	strcpy(l_statlog_rm,l_statlog);
	strcat(l_statlog_rm,"_STATIC");
	APL_CLOSE_FILE(l_statvallog);

	sprintf(l_buf,"grep -i 'Static Value Is' %s >> %s",l_rep_name_temp,l_statlog);
    printf("\nCommand = |%s| ",l_buf);
    retval = system(l_buf);
    printf("\n GREP COMMAND EXECUTED WITH status = |%d|\n ",retval);
    memset(l_buf, APL_NULL_CHAR , 1000);
	
	/*
	sprintf(l_buf,"mv %s %s",l_statlog,l_statlog_rm);
    printf("\nCommand = |%s| ",l_buf);
    retval = system(l_buf);
    printf("\n GREP COMMAND EXECUTED WITH status = |%d|\n ",retval);
    memset(l_buf, APL_NULL_CHAR , 1000);
	*/
	

/* changes by amish -21/09/2006 ---------end*/



RETURN_SUCCESS  :

	BT_IF_DEBUG
		CO_ProcMonitor(l_userfile,"Processing Ended Success",NULL,NULL);
	APL_CLOSE_FILE(l_logfile);
	APL_CLOSE_FILE(l_skipped_file);
	APL_CLOSE_FILE(l_userfile);
	APL_CLOSE_FILE(l_format_file);
	APL_CLOSE_FILE(chr_finifile);
	APL_CLOSE_FILE(l_file);
	if(l_bk_file!= (FILE *)NULL)fclose(l_bk_file);
	fprintf(APL_OUT_FILE,"\n**********************Yep! AS Your Wish!!!************************");

	if(APL_FAILURE == BT_Status_Completed( argv[0],
				argv[1],
				argv[2],
				l_debug_info_ptr))
		APL_GOBACK_FAIL

			EXEC SQL COMMIT;
	IS_ANY_ORA_ERROR
		return(0);

RETURN_FAILURE  :
	BT_IF_DEBUG
		CO_ProcMonitor(l_userfile,"Processing Ended Failure",NULL,NULL);
	APL_CLOSE_FILE(l_logfile);
	APL_CLOSE_FILE(l_skipped_file);
	APL_CLOSE_FILE(l_userfile);
	APL_CLOSE_FILE(l_format_file);
	APL_CLOSE_FILE(l_bk_file);
	APL_CLOSE_FILE(chr_finifile);
	APL_CLOSE_FILE(l_file);


	CO_ProcMonitor(APL_OUT_FILE,"\nOoops! Its Failure!!!\n",l_debug_info_ptr,NULL);
	system("date");
	EXEC SQL COMMIT;
	return(-1);
}




