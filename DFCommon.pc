/************************************************************************************************************
*                 COPYRIGHT NOTICE
*   
*   
*                 Copyright @  2005 by Polaris Software Lab Ltd.
*   
*                 All rights reserved.
*                 No part of this document may be reproduced, stored in a retrieval system,
*                 translated, transcribed, or transmitted in any form or by any means,
*                 without the prior written permission of Polaris Software Lab Limited ('Polaris').
*          
* ***********************************************************************************************************/

/**********************************************************************
* *                                                                    *
*
* * Project Name        : INTELLECT CUSTODY                            *
* * Module Name         : DEAL  PROCESSING                             *
* * File Name           : DFCommon.pc                                  *
* *                                                                    *
* * Description         : This source file contains the function which *
*                         is used to call the function which process 54x and 515               *
*                         *                                                                    *
*                         * Screens Used        : None
*	                       *
*	                       * Reports Used        : None                                         *
*	                       *                                                                    *
*	                       *                                                                    *
*	                       * Notes               :                                              *
*	                       *                                                                    *
*	                       *            Version Control Block                                   *
*	                       *                                                                    *
*	                       * Date       Version       Author               Description          *
*	                       * ---------  --------  ---------------  ---------------------------- *
*	                       *                                                                    *
*	                       *             1.0                            New File                *
*	                       *                                                                    *
*	                       * List of functions   :                                              *
*	                       *                                                                    *
*	                       * Function Name          Description                                 *
*	                       * ------------------------------------------------------------------ *
*/ /*Changes done for AIX Migration*/	                        

/************************************************************************************************************/
/*  1. int ConvFileToList(FILE *, char *, MESSAGE_STRUCT **, char *)                                        */
/*  2. int GetWrapperName(char *, MESSAGE_STRUCT **, char *, char *, ERROR_STRUCT **)                       */
/*  3. int GetEnvString(char *, char *, ERROR_STRUCT **)                                                    */
/*  4. int GetParamString(MESSAGE_STRUCT **, char *, char *, ERROR_STRUCT **)                               */
/*  5. int PutClientRequest(char *, char *,char *,char *, char *,char *, ERROR_STRUCT **)                   */
/*  6. int UpdateLog(FILE *, char *, char *, char *, char *)                                                */
/*  7. int GetCAIDFromAMSGLINK(char *, MESSAGE_STRUCT **, char *, char *, ERROR_STRUCT **)                  */
/*  8. int GBDbInsAMSGLINK(MESSAGE_STRUCT **, char *, char *, char *, char *, char *, ERROR_STRUCT **)      */
/*  9. int I_InsertMessageRecordNode(MESSAGE_STRUCT **, char *, char *, char *, char *, char *)             */
/* 10. int DisplayMessageDetails(MESSAGE_STRUCT **)                                                         */
/* 11. int CompSeqTagQualVal(MESSAGE_STRUCT *, char *, char *, char *, char *)                              */
/* 12. int CompSeqTagQual(MESSAGE_STRUCT *, char *, char *, char *)                                         */
/* 13. int CompSeqTag(MESSAGE_STRUCT *, char *, char *)                                                     */
/* 14. int CompSeqQual(MESSAGE_STRUCT *, char *, char *)                                                    */
/* 15. int I_GetDescription(MESSAGE_STRUCT **p_message_list, char *, char *, char *, char *, char *)        */
/* 16. int CompTagQual(MESSAGE_STRUCT *, char *, char *)                                                    */
/* 17. int I_FreeMessageList(MESSAGE_STRUCT **)                                                             */
/* 18. int GetVal(MESSAGE_STRUCT **p_message_list, char *, char *, char *, char *, char *)                  */
/* 19. int I_GetQual(MESSAGE_STRUCT **p_message_list, char *, char *, char *, char *)                       */
/* 20. int UpdateLog(FILE *, char *, char *, char *, char *)                                                */
/* 21. int ChkErrorAddNoteNbr(char *, char *, char *)                                                       */
/* 22. int MoveFileToArch(char *, char *)                                                                   */
/* 23  int GetDataFromHeader_StartEndPos(MESSAGE_STRUCT **, int, int, int, char *)                          */
/* 24. int GetDataFromHeader_Separator(MESSAGE_STRUCT **, int, char, int, char *)                           */
/* 25. int GetDataForRepeatBlock(MESSAGE_STRUCT **, char *, char *, char *, char *, char *)                 */
/* 26. int CheckForDaemonStatus(char *, ERROR_STRUCT **)                                                    */
/* 27. int CheckAgentCode(MESSAGE_STRUCT **, ERROR_STRUCT **)                                               */
/* 28. int StrSplitFn(char *, char, int *, char ***)                                                        */
/* 29. int Get_misinfo(MESSAGE_STRUCT **p_msg_list, char *p_filename,char *p_msg_name,  char *p_str_misinfo,char *p_str_funcmo
 * de ,char *p_mis_msg_name,ERROR_STRUCT **p_error_list)                                                    */
/*int GetSubFunFn(MESSAGE_STRUCT **p_message_list,char *p_str_msg_name, char *p_str_val)*/
/* 31. int I_LocateVal(MESSAGE_STRUCT  **, char* , char* ,char* , char* )                                   */
/* 32. int DFparse_error(char * p_err_desc, MESSAGE_STRUCT **p_msg_list,char *p_filename, char *p_message_name,ERROR_STRUCT **
 * p_error_list )                                     */
/*************************************************************************************************************/

#include "stdio_64.h"
#include "string.h"
#include "CR_Common.h"
#include "Intellect_Interface.h"
#include "Intellect_Common.h"
#include "Df_Fe.h"

EXEC SQL INCLUDE SQLCA;

#define DEFORMAT_IF_DEBUG if ( 1 )
#define LINE_FOR_SWIFT_ADDR 4
#define MAXBLOCK 7	

char    	g_log_buff_common[MSG_LENGTH]           	= APL_NULL_STRING;
char		g_incmsgarchdir_common[PATH_LENGTH]			= APL_NULL_STRING;
char		g_incmsgdir_common[PATH_LENGTH]	        	= APL_NULL_STRING;
extern char		g_addr_frm[]	    ;
extern char		g_addr_to[]	    ;


int GetDataForRepeatBlock(
   MESSAGE_STRUCT   **p_message_list,
	char*            p_tag,
	char*            p_qual,
	char*            p_sequence,
	char*            p_block_no,
	char*		 p_return_concat_string
)
{
	long l_block_no_num		= 0;		
	char l_block_no_char[11]	= APL_NULL_STRING;
	char l_str_val[71]			= APL_NULL_STRING; 
	char l_str_tag[101]			= APL_NULL_STRING;
	char l_str_qual[201]		= APL_NULL_STRING;
	char l_str_qual_first_part[10]	= APL_NULL_STRING;
	char l_str_qual_second_part[201]	= APL_NULL_STRING;
	char l_str_sequence[6]		= APL_NULL_STRING;
   char l_str_tag_first_part[10]       = APL_NULL_STRING;
	char l_str_tag_second_part[50]      = APL_NULL_STRING;
	int  l_int_found			= 0;
	int  int_l_int_retval		= 0;

	strcpy(l_str_tag, p_tag);
	strcpy(l_str_qual, p_qual);
	strcpy(l_str_sequence, p_sequence);
	strcpy(l_block_no_char, p_block_no);	

   if(strchr(l_str_qual, '$') != NULL)
	{
		while(strchr(l_str_qual, '$') != NULL)
		{
			SeparateData(l_str_qual, '$', l_str_qual_first_part, l_str_qual_second_part);
			SeparateData(l_str_tag, '$', l_str_tag_first_part, l_str_tag_second_part);
			//if(int_l_int_retval = I_GetVal(p_message_list, l_str_tag_first_part, l_str_qual_first_part, l_str_val, l_str_sequence, l_block_no_char) == 1)//AIX Warning Removal
			if((int_l_int_retval = I_GetVal(p_message_list, l_str_tag_first_part, l_str_qual_first_part, l_str_val, l_str_sequence, l_block_no_char)) == 1)
			{
				strcpy(l_str_tag, l_str_tag_first_part);
				strcpy(l_str_qual, l_str_qual_first_part);
				strcpy(p_return_concat_string, l_str_val);
				break;
			}
			strcpy(l_str_qual, l_str_qual_second_part);
			strcpy(l_str_tag, l_str_tag_second_part);
		}

		if(int_l_int_retval == APL_FAILURE)
		{
			int_l_int_retval = I_GetVal(p_message_list, l_str_tag,l_str_qual,l_str_val,p_sequence, l_block_no_char);
		}
	}
	else
	{
	       int_l_int_retval = I_GetVal(p_message_list, l_str_tag, l_str_qual, l_str_val, l_str_sequence, l_block_no_char);
	}

	l_int_found = int_l_int_retval;

	if(l_int_found)
	{
		l_block_no_num = atol(l_block_no_char);
		l_block_no_num++;
		strcpy(l_block_no_char, ltoa(l_block_no_num));
		int_l_int_retval = 0;
		
		while((int_l_int_retval = I_GetVal(p_message_list, l_str_tag, l_str_qual, l_str_val, l_str_sequence, l_block_no_char)) == APL_SUCCESS)
		{
			strcat(p_return_concat_string,"#");
			strcat(p_return_concat_string, l_str_val);
			l_block_no_num = atol(l_block_no_char);
			l_block_no_num++;
			strcpy(l_block_no_char, ltoa(l_block_no_num));
		}
	}
	
	return l_int_found;
}


int ConvFileToList(FILE *fl,char *p_msg_no, MESSAGE_STRUCT **p_message_list)
{
	Alert("Entered");
	int 		int_l_int_retval			= 0;

	//DEBUG_INFO_STRUCT_H 	**l_debug_info_ptr	= NULL; 
	
	DEBUG_INFO_STRUCT_H **l_debug_info_ptr=(DEBUG_INFO_STRUCT_H **)NULL;
        DEBUG_INFO_STRUCT_H *l_debug_info_struct=(DEBUG_INFO_STRUCT_H *)NULL;

        l_debug_info_struct = (DEBUG_INFO_STRUCT_H *)calloc(1,sizeof(DEBUG_INFO_STRUCT_H *)); //23/05/2012
        APL_MALLOC_FAIL(l_debug_info_struct); 


        l_debug_info_ptr = &l_debug_info_struct; 
	char 		chr_l_str[8001] 			= APL_NULL_STRING;
	char		chr_l_str1[71]				= APL_NULL_STRING;
	char 		l_str_tag[6]        		= APL_NULL_STRING;
	char 		l_str_qual[71]      		= APL_NULL_STRING;
	char 		l_str_val[70]       		= APL_NULL_STRING;
	char 		l_str_sequence[10]   		= APL_NULL_STRING;
	char		l_first_part[71]		= APL_NULL_STRING;
	char		l_second_part[150]		= APL_NULL_STRING;
        char            l_second_part_temp[150]              = APL_NULL_STRING;
	char    	l_description[8001]	= APL_NULL_STRING;
	MESSAGE_STRUCT 	**l_message_list_previous_node =NULL;
	MESSAGE_STRUCT  **l_message_list	=NULL;
	char 		chr_l_new_line[3]				= APL_NULL_STRING;
	int		l_header_flag				= 0; 
	int 		chr_flag							= 0;
	char		l_block_no[101]			= APL_NULL_STRING;
	char		l_str_temp_block_no1[101]= APL_NULL_STRING;
	char		l_str_temp_block_no2[101]= APL_NULL_STRING;
	int 		l_sr_no_dfseqmap			= 0;
	//int		l_block_no_val				= 0;		
	long l_block_no_val				= 0;		
	char     l_block_no_val_temp[101]         = APL_NULL_STRING;
	char l_chr_temp_block_val[101] = APL_NULL_STRING;
	char l_temp_value[101];
	int calloc_size=1;
	Alert("218:");
  H_SEQUENCEMAP_STRUCT h_sequencemap_struct ;
I_SEQUENCEMAP_STRUCT i_sequencemap_struct  ;

	EXEC SQL BEGIN DECLARE SECTION;
	/*H_SEQUENCEMAP_STRUCT       *h_sequencemap_struct     	 	=       NULL;
	I_SEQUENCEMAP_STRUCT       *i_sequencemap_struct         =       NULL;
*/


	struct sqlca sqlca;

	EXEC SQL VAR l_description IS STRING;
	EXEC SQL VAR h_sequencemap_struct.swift_msg_no IS STRING;
	EXEC SQL VAR h_sequencemap_struct.sequence IS STRING;
	EXEC SQL VAR h_sequencemap_struct.tag_qualifier IS STRING;
	EXEC SQL VAR h_sequencemap_struct.parent IS STRING;
	EXEC SQL VAR h_sequencemap_struct.occurence_val IS STRING;
	EXEC SQL VAR p_msg_no IS STRING; 
	EXEC SQL VAR l_str_temp_block_no1 IS STRING;

	EXEC SQL DECLARE sequencemap_cur CURSOR FOR
	select * from dfsequencemap where swift_msg_no = :p_msg_no order by SRL_NUM;
	
	EXEC SQL END DECLARE SECTION;
/*

   h_sequencemap_struct = (H_SEQUENCEMAP_STRUCT *)calloc(calloc_size,sizeof(H_SEQUENCEMAP_STRUCT));
	APL_MALLOC_FAIL(h_sequencemap_struct);

	i_sequencemap_struct = (I_SEQUENCEMAP_STRUCT *)calloc(calloc_size,sizeof(I_SEQUENCEMAP_STRUCT));
	APL_MALLOC_FAIL(i_sequencemap_struct);
*/
  memset (&h_sequencemap_struct,NULL,sizeof(H_SEQUENCEMAP_STRUCT)); 
  memset (&i_sequencemap_struct,0,sizeof(I_SEQUENCEMAP_STRUCT)); 

	Alert("At 236");
/*
	l_message_list = (MESSAGE_STRUCT **)calloc(1,sizeof(MESSAGE_STRUCT *));
	APL_MALLOC_FAIL(l_message_list);
*/
	Alert("At 236");

	sprintf(chr_l_new_line,"%c%c",toascii(13),toascii(10));
	chr_l_new_line[strlen(chr_l_new_line)]='\0';

	Alert("At 236");
	l_message_list = p_message_list;
	Alert("At 236");

	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function ConvFileToList\n");
		printf("msg no%s\n",p_msg_no);
				fflush(stdout);
	}
	memset(l_description,APL_NULL_CHAR,8001);


	while (!feof(fl))
	{
		memset(chr_l_str1, '\0', 71);
		memset(chr_l_str, '\0', 8001);
		fscanf(fl, "%[^\n]\n",chr_l_str);
		/*fgets(chr_l_str,100,fl);*/
		chr_l_str[strlen(chr_l_str)]='\0';
		strncpy(chr_l_str1, chr_l_str, 70); 	
		chr_l_str1[strlen(chr_l_str1)] = '\0';	

		/* if (chr_l_str1[0] == ':') changed by Pravin for the snow-CS0116663 */
		if(chr_l_str1[0] == ':' & chr_l_str1[4] == ':')
		{
			l_header_flag = 1;
			memset(l_str_tag, '\0', 6);
			memset(l_str_qual, '\0', 71);
			memset(l_str_val, '\0', 70);
			memset(l_description,'\0',8001);	
			int_l_int_retval = 0;

			

			strncpy(l_str_tag,chr_l_str1,5);
			l_str_tag[5]='\0';

			DEFORMAT_IF_DEBUG
			{
				printf("\n Tag is |%s| ",l_str_tag);
				printf("\n length Tag is |%d| ",(int)strlen(l_str_tag));  //AIX-Warnings Removal
				fflush(stdout);
			}
			
			

			if((!strstr(chr_l_str1,":16R:")) && (!strstr(chr_l_str1,":16S:")))
			{

				if(strrchr(chr_l_str1, '/'))
				{
					strcpy(l_str_val,strrchr(chr_l_str1,'/')+1);
				}
				else if(strrchr(chr_l_str1, ' '))
				{
					strcpy(l_str_val,strrchr(chr_l_str1,' ')+1);
				}	

			}

			DEFORMAT_IF_DEBUG
			{
				printf(" Value is |%s| \n",l_str_val);
				printf(" length chr_value is |%d| ",(int)strlen(l_str_val));  //AIX-Warnings Removal
				fflush(stdout);
			}


			

			strncpy(l_str_qual,chr_l_str1+5,(strlen(chr_l_str1)-(strlen(l_str_val)+5)));
			Alert("SPLITE QUALIFIER [%s]",l_str_qual);
			
			if(l_str_qual[0] != ':')
			{
				if((l_str_qual[strlen(l_str_qual)-1] == ' ') || (l_str_qual[strlen(l_str_qual)-1] == '/'))	
				{
					strncpy(l_str_qual, l_str_qual, strlen(l_str_qual) - 1);
					l_str_qual[strlen(l_str_qual) - 1] = '\0';
				}
			}
			if((strstr(l_str_qual,"//")) != NULL)
			{	
				SeparateData(l_str_qual,'/',l_first_part,l_second_part);

					printf("\n 1 l_first part is |%s| \n",l_first_part);
			        printf("\n 1 l_second_part is |%s| \n",l_second_part);
					if (strstr(l_second_part,"//"))
					{
							printf("\n Got Double Slash \n");
							ReplaceDoubleSlash(l_second_part);
							printf("\n After calling l_second_part is |%s| \n",l_second_part);
					}
				strcpy(l_str_qual,APL_NULL_STRING);
				strcpy(l_str_qual,l_first_part);	
				strcat(l_str_qual,"/");
				strncpy(l_second_part, l_second_part,(strlen(l_second_part)-1));
				l_second_part[(strlen(l_second_part)-1)] = '\0';
				//Below code again commented as queries in dfparammap needs to be change w.r.t the below code
				/* retro from SBI for 70E SPRO changes(Default Market type) by Hardik start */
				if((!strcmp(l_str_tag,":70E:")) && (!strcmp(l_first_part,":SPRO")))
				{	
					strcat(l_second_part,"/");
					strcat(l_second_part, l_str_val);
					strcpy(l_str_val, l_second_part);
					printf("\n Ankit : l_str_val |%s|",l_str_val);
					printf("\n Ankit : l_second_part  |%s|",l_second_part);
				}
				/* retro from SBI for 70E SPRO changes(Default Market type) by Hardik End */
				else
				{
					if(strrchr(l_second_part,'/') != NULL)
					{

                                                 strcpy(l_second_part_temp, strrchr(l_second_part,'/')+1);
                                                printf("VELU l_second_part_temp [%s]",l_second_part_temp);
                                                if(strlen(l_second_part_temp) >0)
                                                {
                                                memset(l_second_part, '\0', 150);
                                                strcpy(l_second_part,l_second_part_temp);
                                                }
                                                printf("\n VELU2 : l_second_part  |%s|",l_second_part);
                                               
						strcat(l_second_part,"/");
					}
					strcat(l_second_part, l_str_val);
					strcpy(l_str_val, l_second_part);
				}
			}
			
			else if ((strstr(l_str_qual,"/")) !=NULL)
			{
				DEFORMAT_IF_DEBUG
						printf("Value obtained ===== ||%s|| \n",l_str_val);
				fflush(stdout);
				printf("1.l_str_qual is |%s|",l_str_qual);
				fflush(stdout);
				printf("1.l_first_part is |%s|",l_first_part);
				fflush(stdout);
				printf("1.l_second_part is |%s|",l_second_part);
				fflush(stdout);
				SeparateData(l_str_qual,'/',l_first_part,l_second_part);
				printf("2.l_str_qual is |%s|",l_str_qual);
				fflush(stdout);
				printf("2.l_first_part is |%s|",l_first_part);
				fflush(stdout);
				printf("2.l_second_part is |%s|",l_second_part);
				fflush(stdout);
				strcpy(l_str_qual,APL_NULL_STRING);
				printf("3.l_str_qual is |%s|",l_str_qual);
				fflush(stdout);
				printf("3.l_first_part is |%s|",l_first_part);
				fflush(stdout);
				printf("3.l_second_part is |%s|",l_second_part);
				fflush(stdout);
				strcpy(l_str_qual,l_first_part);
				printf("4.l_str_qual is |%s|",l_str_qual);
				fflush(stdout);
				printf("4.l_first_part is |%s|",l_first_part);
				fflush(stdout);
				printf("4.l_second_part is |%s|",l_second_part);
				fflush(stdout);
				strcat(l_str_qual,"/");
				printf("5.l_str_qual is |%s|",l_str_qual);
				fflush(stdout);
				printf("5.l_first_part is |%s|",l_first_part);
				fflush(stdout);
				printf("5.l_second_part is |%s|",l_second_part);
				fflush(stdout);
				strncpy(l_second_part, l_second_part,(strlen(l_second_part)-1));
				printf("6.l_str_qual is |%s|",l_str_qual);
				fflush(stdout);
				printf("6.l_first_part is |%s|",l_first_part);
				fflush(stdout);
				printf("6.l_second_part is |%s|",l_second_part);
				fflush(stdout);

				//if(strncmp(l_second_part,'/',5) == 0)//AIX Warning Removal
				if(strncmp(l_second_part,"/",5) == 0)
					{
						strcpy(l_second_part, strrchr(l_second_part,'/')+1);
						strcat(l_second_part,"/");
					}
				strcat(l_second_part, l_str_val);
				strcpy(l_str_val, l_second_part);
				
				DEFORMAT_IF_DEBUG
					printf("First Part -------------------------------- ||%s||\n",l_first_part);
					printf("Second Part --------------------------------||%s||\n",l_second_part);
					printf("Value of this is  -------------------------||%s||\n",l_str_val);
				fflush(stdout);
			}

			DEFORMAT_IF_DEBUG
			{
				printf(" Qualifier is |%s| \n",l_str_qual);
				printf(" length Qual is |%d| ",(int)strlen(l_str_qual));  //AIX-Warnings Removal
				fflush(stdout);
			}
			

			
			if((!strcmp(l_str_tag,":16R:")) || (!strcmp(l_str_tag, ":16S:")))
			{
				EXEC SQL OPEN sequencemap_cur;
				EXEC SQL FETCH sequencemap_cur INTO :h_sequencemap_struct:i_sequencemap_struct;
				IS_ANY_ORA_ERROR
				
				if(sqlca.sqlcode == 1403)
					SYS_RETURN_NO_DATA_FOUND

				while(strcmp(l_str_qual, h_sequencemap_struct.tag_qualifier))
				{
					EXEC SQL FETCH sequencemap_cur INTO :h_sequencemap_struct:i_sequencemap_struct;
				        IS_ANY_ORA_ERROR
				}

				EXEC SQL CLOSE sequencemap_cur;
				IS_ANY_ORA_ERROR			

				strcpy(l_str_sequence, h_sequencemap_struct.sequence);
				
				printf("The sequence generated is %s---------------------------\n", l_str_sequence); 
				fflush(stdout);
				printf("The block no chr_value is %s-------------------------------\n", h_sequencemap_struct.occurence_val);				
				fflush(stdout);
				if(strstr(chr_l_str1,":16R:"))
				{
					printf("It came here .............1\n");
					fflush(stdout);

					if(!strcmp(h_sequencemap_struct.occurence_val, "0"))
					{
						printf("Nullll-----------------------------\n");
						fflush(stdout);
						if(h_sequencemap_struct.inter_block_seq != 1)
						{ 
							printf("child ------------------------------\n");
							fflush(stdout);
	
							EXEC SQL SELECT occurence_val into :l_str_temp_block_no1 
							FROM dfsequencemap
							where swift_msg_no = :p_msg_no
							AND TAG_QUALIFIER = :h_sequencemap_struct.parent;
							IS_ANY_ORA_ERROR

							
							
							if(!strcmp(l_str_temp_block_no1, "0"))
							{
								I_FreeMessageList(l_message_list);	
								free(l_message_list);
								APL_GOBACK_FAIL
							}
							strcpy(h_sequencemap_struct.occurence_val, l_str_temp_block_no1);
							strcat(h_sequencemap_struct.occurence_val, ",1");
							printf("The block no chr_value is %s-----------------\n", h_sequencemap_struct.occurence_val);	
							fflush(stdout);
							
						}
						else
						{
							printf("parent ---------------------------\n");
							fflush(stdout);
							strcpy(h_sequencemap_struct.occurence_val, "1");
							printf("The block  no chr_value is %s-----------------\n", h_sequencemap_struct.occurence_val);
							fflush(stdout);
						}	

					}
					else
					{
						printf("not Nulllll ...........2\n");
						fflush(stdout);
						if(strrchr(h_sequencemap_struct.occurence_val, ','))
						{
							printf("child ......................\n");
							fflush(stdout);
							memset(l_str_temp_block_no1,APL_NULL_CHAR,sizeof(l_str_temp_block_no1));
							strncpy(l_str_temp_block_no1, h_sequencemap_struct.occurence_val, strlen(h_sequencemap_struct.occurence_val) - strlen(strrchr(h_sequencemap_struct.occurence_val, ',')) + 1); 

							l_str_temp_block_no1[strlen(h_sequencemap_struct.occurence_val) - strlen(strrchr(h_sequencemap_struct.occurence_val, ',')) + 1] = '\0';						

							/* Alert("Chk : Sana : l_str_temp_block_no1 = |%s|",l_str_temp_block_no1);
							fflush(stdout); */

							memset(l_str_temp_block_no2,APL_NULL_CHAR,sizeof(l_str_temp_block_no2));
							strcpy(l_str_temp_block_no2, strrchr(h_sequencemap_struct.occurence_val,',')+1);
							/* Alert("Chk : Sana : l_str_temp_block_no2 = |%s|",l_str_temp_block_no2);
							fflush(stdout); */

							l_block_no_val = atol(l_str_temp_block_no2);
							l_block_no_val++;
							memset(h_sequencemap_struct.occurence_val,APL_NULL_CHAR,sizeof(h_sequencemap_struct.occurence_val));
							strcpy(h_sequencemap_struct.occurence_val, l_str_temp_block_no1);
							/* Alert("chk : Sana : occurence_val = |%s|",h_sequencemap_struct.occurence_val);
							fflush(stdout); */
							strcat(h_sequencemap_struct.occurence_val, ltoa(l_block_no_val));
							/* Alert("chk : Sana : occurence_val after = |%s|",h_sequencemap_struct.occurence_val);
							fflush(stdout); */
						}
						else
						{
							printf("parent ..........3\n");
							fflush(stdout);
							l_block_no_val = atoi(h_sequencemap_struct.occurence_val);
							l_block_no_val++;
							strcpy(h_sequencemap_struct.occurence_val, ltoa(l_block_no_val));
							printf("The chr_value of the block no is %s\n", h_sequencemap_struct.occurence_val);
							fflush(stdout);
						}	
					}


					EXEC SQL UPDATE dfsequencemap
					set occurence_val = :h_sequencemap_struct.occurence_val
					where swift_msg_no = :p_msg_no
					AND sequence = :h_sequencemap_struct.sequence
					AND TAG_QUALIFIER = :h_sequencemap_struct.tag_qualifier;
					IS_ANY_ORA_ERROR

					EXEC SQL UPDATE dfsequencemap
					set occurence_val = '0' 
					where swift_msg_no = :p_msg_no
					AND block_main_seq = :h_sequencemap_struct.block_main_seq
					AND inter_block_seq > :h_sequencemap_struct.inter_block_seq;
					IS_ANY_ORA_ERROR
				}
				strcpy(l_block_no, h_sequencemap_struct.occurence_val);

			}
			


			

			strcpy(l_description, chr_l_str+70);
			l_description[strlen(l_description)] = APL_NULL_CHAR;

	
	
			

			DEFORMAT_IF_DEBUG
			{
				printf("\n Sequence is |%s| Tag is |%s|\tQualifier is |%s|\t\tValue is |%s|",l_str_sequence,l_str_tag,l_str_qual,l_str_val);
				printf("block no chr_value %s\n", l_block_no);
				fflush(stdout);
			}
						
			int_l_int_retval = I_InsertMessageRecordNode(l_message_list,l_str_tag,l_str_qual,l_str_val,l_str_sequence, l_description, l_block_no); 
			//int_l_int_retval = I_InsertMessageRecordNode(&l_message_list,&l_str_tag,&l_str_qual,&l_str_val,&l_str_sequence, &l_description, &l_block_no);

			if(int_l_int_retval == 0)
			{
				APL_GOBACK_FAIL			
			}

			DEFORMAT_IF_DEBUG
			{
				printf("\n From List ..... Sequence is |%s| Tag is |%s|",(*l_message_list)->sequence,(*l_message_list)->msg_tag);
				printf(" Qualifier is |%s| Value is |%s|",(*l_message_list)->qual,(*l_message_list)->int_val);
				fflush(stdout);
			}
																																		
			l_message_list_previous_node = &(*l_message_list);
			l_message_list = &((*l_message_list)->h_next);
		}
		else
		{
			/** memset(l_description,'\0',500);  TUX  Why 500 ?????? when length is 8001 ***/
			memset(l_description,APL_NULL_CHAR,8001);
			if(l_header_flag == 1)
			{	
				strcpy(l_description,(*l_message_list_previous_node)->description);
				if(strcmp(l_description, APL_NULL_STRING) == 0)
				{
					strcpy(l_description, chr_l_str1);
				}
				else
				{
					strcat(l_description, chr_l_str1);					
				}
			
				strcat(l_description, chr_l_new_line);
				strcpy((*l_message_list_previous_node)->description, l_description);
			}
			else
			{
				printf("test here |%s|\n",chr_l_str1);
				fflush(stdout);
				if(chr_flag == 0)
				{
					strcpy(l_description, chr_l_str1);
					strcat(l_description, chr_l_new_line);	
					memset(l_str_tag, '\0', 6);
					memset(l_str_qual, '\0', 70);
					memset(l_str_val, '\0', 70);
					memset(l_str_sequence,'\0',5);
					l_block_no_val = 0;
					chr_flag = 1;
					strcpy(l_block_no_val_temp, ltoa(l_block_no_val));
					int_l_int_retval = I_InsertMessageRecordNode(l_message_list,l_str_tag,l_str_qual,l_str_val,l_str_sequence, l_description, l_block_no_val_temp);
					if(int_l_int_retval == 0)
					{
						APL_GOBACK_FAIL
					}

					l_message_list_previous_node = &(*l_message_list);
					l_message_list = &((*l_message_list)->h_next);
				}
				else
				{
					/** TUX : Why we want to strcat spaces with descriptin **/
					memset(l_description,APL_NULL_CHAR,8001);
					strcpy(l_description,(*l_message_list_previous_node)->description);
					printf("\n desc = |%s| \n ",l_description);
				fflush(stdout);
					if ( strlen(chr_l_str1) >0 )
					{
						strcat(l_description, chr_l_str1);
						strcat(l_description, chr_l_new_line);
					}
					strcpy((*l_message_list_previous_node)->description, l_description);
				}
			}
		}
	}

	fclose(fl);


	EXEC SQL update dfsequencemap set occurence_val = '0';
	IS_ANY_ORA_ERROR

	DEFORMAT_IF_DEBUG
	{
		Alert("\n Leaving Function ConvFileToList\n");
				fflush(stdout);
	}

	APL_GOBACK_SUCCESS	

LBL_EXIT_NO_DATA:
        EXEC SQL CLOSE sequencemap_cur;
	APL_IF_DEBUG
		printf("\nLeaving unsuccessfully out of ConvFileToList : NO DATA FOUND \n"); 
				fflush(stdout);
	return SYS_NO_DATA;

RETURN_SUCCESS:
	/* free(h_sequencemap_struct);
	free(i_sequencemap_struct); */
	//free(l_debug_info_ptr);
	return APL_SUCCESS;

RETURN_FAILURE:
	/* free(h_sequencemap_struct);
	free(i_sequencemap_struct);*/
	//free(l_debug_info_ptr);
	return APL_FAILURE;
}


int GetWrapperName(char *p_msg_no, MESSAGE_STRUCT **p_message_list, char *p_msg_wrapper, char *p_func_mode, char *p_proc_name, char *p_msg_name, DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	EXEC SQL BEGIN DECLARE SECTION;

	char		l_str_val[51]			 = APL_NULL_STRING;	
	int		int_l_int_retval		 = 0;	
	int		l_int_found			 = 0;
   char		l_str_qual_first_part[70]  	= APL_NULL_STRING;
	char		l_str_qual_second_part[70] 	= APL_NULL_STRING;
	char		***l_and_process_qual	=NULL;				
	char		***l_and_process_seq		=NULL;
	char		***l_and_process_tag		=NULL;
	char		***l_and_process_value	=NULL;
	char		***l_and_process_blockno=NULL;
	
	int 		*l_int_noelem;	
	char		l_separator		 = '#';		
	int 		l_int_loopcount = 0;	
	
	int      *l_int_noelem_val;	
	int      l_value_rep_count = 0;
	char     ***l_or_value   =       (char ***)NULL;
	int      l_not_flag = 0;
	int	 l_int_ret = 0;
	int calloc_size = 1;
	H_DSWRAPPERMAP_STRUCT       *h_dswrappermap_struct      =       NULL;
	I_DSWRAPPERMAP_STRUCT	    *i_dswrappermap_struct      =       NULL; 	 		

	struct sqlca sqlca;

	EXEC SQL VAR h_dswrappermap_struct->h_swift_msg_no IS STRING;
	EXEC SQL VAR h_dswrappermap_struct->h_sequence IS STRING;
	EXEC SQL VAR h_dswrappermap_struct->h_msg_tag IS STRING;
	EXEC SQL VAR h_dswrappermap_struct->chr_h_qualifier IS STRING;
	EXEC SQL VAR h_dswrappermap_struct->chr_h_val IS STRING;
	EXEC SQL VAR h_dswrappermap_struct->h_wrapper_name IS STRING;
	EXEC SQL VAR h_dswrappermap_struct->h_function_mode IS STRING;
	EXEC SQL VAR h_dswrappermap_struct->h_proc_name IS STRING;
	EXEC SQL VAR h_dswrappermap_struct->h_msg_name IS STRING;
	EXEC SQL VAR h_dswrappermap_struct->h_block_no IS STRING; 
	EXEC SQL VAR p_msg_no IS STRING;

	EXEC SQL END DECLARE SECTION;

	h_dswrappermap_struct = (H_DSWRAPPERMAP_STRUCT *)calloc(calloc_size,sizeof(H_DSWRAPPERMAP_STRUCT));
	APL_MALLOC_FAIL(h_dswrappermap_struct);

	i_dswrappermap_struct = (I_DSWRAPPERMAP_STRUCT *)calloc(calloc_size,sizeof(I_DSWRAPPERMAP_STRUCT));
	APL_MALLOC_FAIL(i_dswrappermap_struct);


	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function GetWrapperName\n");
				fflush(stdout);
	}

	l_int_noelem = (int *)calloc(1, sizeof(int *));
	l_int_noelem_val = (int *)calloc(1, sizeof(int *));
	l_and_process_qual = (char ***)calloc(200, sizeof(char ***));
	l_and_process_seq = (char ***)calloc(200, sizeof(char ***));
	l_and_process_tag = (char ***)calloc(200, sizeof(char ***));
	l_and_process_value = (char ***)calloc(200, sizeof(char ***));
	l_and_process_blockno = (char ***)calloc(200, sizeof(char ***));

	/*
	EXEC SQL DECLARE dswrappermap_cur CURSOR FOR
	select * from dfwrpmap where swift_msg_no = :p_msg_no;	
	EXEC SQL OPEN dswrappermap_cur;
	*/

	EXEC SQL DECLARE dswrappermap_cur CURSOR FOR
	select * from dfwrpmap where msg_name = :p_msg_no;	
	IS_ANY_ORA_ERROR

	EXEC SQL OPEN dswrappermap_cur;
	
	DEFORMAT_IF_DEBUG
	{
		printf("\n 2sqlca.sqlcode is :%d:\n for msg is %s",sqlca.sqlcode, p_msg_no); 
				fflush(stdout);
	}

	IS_ANY_ORA_ERROR	
				
	
	for( ; ; )
	{
		memset(h_dswrappermap_struct,NULL,sizeof(H_DSWRAPPERMAP_STRUCT));
		memset(i_dswrappermap_struct,NULL,sizeof(I_DSWRAPPERMAP_STRUCT));
		EXEC SQL FETCH dswrappermap_cur INTO :h_dswrappermap_struct:i_dswrappermap_struct;
		IS_ANY_ORA_ERROR
		if(sqlca.sqlcode == 1403)
		{
			SYS_RETURN_NO_DATA_FOUND
		}
		printf("Inside main cursor for loop\n");
				fflush(stdout);
		*l_int_noelem = 0;	
		l_not_flag  = 0;
		if(strchr(h_dswrappermap_struct->chr_h_qualifier, '#'))
		{
			printf("#is prewesent %s\n", h_dswrappermap_struct->chr_h_qualifier);
				fflush(stdout);
			l_int_ret = StrSplitFn(h_dswrappermap_struct->chr_h_qualifier + 1, &l_separator, l_int_noelem, l_and_process_qual); 
			l_int_ret = StrSplitFn(h_dswrappermap_struct->h_sequence + 1, &l_separator, l_int_noelem, l_and_process_seq);
			l_int_ret = StrSplitFn(h_dswrappermap_struct->h_msg_tag + 1, &l_separator, l_int_noelem, l_and_process_tag);
			l_int_ret = StrSplitFn(h_dswrappermap_struct->chr_h_val + 1, &l_separator, l_int_noelem, l_and_process_value);
			l_int_ret = StrSplitFn(h_dswrappermap_struct->h_block_no + 1, &l_separator, l_int_noelem, l_and_process_blockno);
		}
		else
		{
			*l_int_noelem = 1;
		}
		
		printf("The count is %d\n", *l_int_noelem);		
				fflush(stdout);

		for(l_int_loopcount = 0; l_int_loopcount < *l_int_noelem; l_int_loopcount++)
		{
			printf("Inside for loop for data checkecking\n");
				fflush(stdout);
			*l_int_noelem_val = 1;
			if(l_int_loopcount > 0)
			{
				printf("it came inside the j iv_cond \n"); 
				fflush(stdout);
			
				if(l_int_found == 1)
					l_int_found =0;
				else
				{
					printf("and iv_cond not satisfied\n");
				fflush(stdout);
					break;
				}

			}
			

			if(*l_int_noelem > 1)
			{
				printf("# is present so string is %s...........\n", *(*l_and_process_qual+l_int_loopcount));
				fflush(stdout);
				strcpy(h_dswrappermap_struct->chr_h_qualifier ,*(*l_and_process_qual+l_int_loopcount));
				strcpy(h_dswrappermap_struct->h_sequence, *(*l_and_process_seq + l_int_loopcount));
				strcpy(h_dswrappermap_struct->h_msg_tag, *(*l_and_process_tag + l_int_loopcount));
				strcpy(h_dswrappermap_struct->chr_h_val, *(*l_and_process_value + l_int_loopcount));
				strcpy(h_dswrappermap_struct->h_block_no, *(*l_and_process_blockno + l_int_loopcount));		
			}
			
			printf("The struct contains the data %s\n", h_dswrappermap_struct->chr_h_qualifier);
				fflush(stdout);
			printf("The struct contains the int_val %s\n", h_dswrappermap_struct->chr_h_val);
				fflush(stdout);
         
			if(h_dswrappermap_struct->chr_h_val)
         {
            if(strrchr(h_dswrappermap_struct->chr_h_val,'$'))
            {
               l_or_value = (char ***)calloc(200,sizeof(char **));
               l_int_ret = StrSplitFn(h_dswrappermap_struct->chr_h_val,'$',l_int_noelem_val,l_or_value);
            }
         }
         
			
         if(h_dswrappermap_struct->chr_h_qualifier[0] == '!')
         {
            l_not_flag = 1;
            strcpy(h_dswrappermap_struct->chr_h_qualifier,h_dswrappermap_struct->chr_h_qualifier + 1);
				         }
			

		 	if(strchr(h_dswrappermap_struct->chr_h_qualifier, '$') != NULL)
		 	{
				while(strchr(h_dswrappermap_struct->chr_h_qualifier, '$') != NULL)
				{
					SeparateData(h_dswrappermap_struct->chr_h_qualifier, '$', l_str_qual_first_part, l_str_qual_second_part);
					//if(int_l_int_retval = I_GetVal(p_message_list, h_dswrappermap_struct->h_msg_tag, l_str_qual_first_part, l_str_val, h_dswrappermap_struct->h_sequence, h_dswrappermap_struct->h_block_no) == 1)//AIX Warning Removal
					if((int_l_int_retval = I_GetVal(p_message_list, h_dswrappermap_struct->h_msg_tag, l_str_qual_first_part, l_str_val, h_dswrappermap_struct->h_sequence, h_dswrappermap_struct->h_block_no)) == 1)
						break;
					strcpy(h_dswrappermap_struct->chr_h_qualifier, l_str_qual_second_part);
				}

				if(int_l_int_retval == 0)
				{
					int_l_int_retval = I_GetVal(p_message_list, h_dswrappermap_struct->h_msg_tag, h_dswrappermap_struct->chr_h_qualifier, l_str_val, h_dswrappermap_struct->h_sequence, h_dswrappermap_struct->h_block_no);
				}
			}
			else
			{
				int_l_int_retval = I_GetVal(p_message_list, h_dswrappermap_struct->h_msg_tag, h_dswrappermap_struct->chr_h_qualifier, l_str_val, h_dswrappermap_struct->h_sequence, h_dswrappermap_struct->h_block_no);
			}
			if(l_not_flag)int_l_int_retval = !int_l_int_retval;
			printf("not |%d| int_retval|%d|\n",l_not_flag,int_l_int_retval);
				fflush(stdout);

			if(int_l_int_retval)
			{
				for(l_value_rep_count = 0;l_value_rep_count < *l_int_noelem_val;l_value_rep_count ++)
				{
					if(l_value_rep_count > 0)
					{
						if(l_int_found == 1)
						{
							printf("value matching .............................\n");
				fflush(stdout);
							break;
						}
					}
					if(*l_int_noelem_val > 1)
            	{
             		strcpy(h_dswrappermap_struct->chr_h_val, *(*l_or_value + l_value_rep_count));
            	}
					
					if(strcmp(h_dswrappermap_struct->chr_h_val, "NA") != 0) 
					{
						printf("st int_val |%s| int_val |%s|\n",l_str_val, h_dswrappermap_struct->chr_h_val);
				fflush(stdout);
						if(strcmp(l_str_val, h_dswrappermap_struct->chr_h_val) == 0)
						{
							if(l_int_loopcount == (*l_int_noelem - 1))
							{
								strcpy(p_msg_wrapper, h_dswrappermap_struct->h_wrapper_name);
								strcpy(p_func_mode, h_dswrappermap_struct->h_function_mode);
								strcpy(p_proc_name, h_dswrappermap_struct->h_proc_name);
								strcpy(p_msg_name, h_dswrappermap_struct->h_msg_name);
							}
							l_int_found = 1;
							int_l_int_retval = 1;
							
						}
						else
						{
							l_int_found = 0;
							int_l_int_retval = 0;
						}
					}
					else
					{
			          if(l_int_loopcount == (*l_int_noelem - 1))
				       {
		              		strcpy(p_msg_wrapper, h_dswrappermap_struct->h_wrapper_name);
				       		strcpy(p_func_mode, h_dswrappermap_struct->h_function_mode);
				       		strcpy(p_proc_name, h_dswrappermap_struct->h_proc_name);
				       		strcpy(p_msg_name, h_dswrappermap_struct->h_msg_name);
				       }
				       l_int_found = 1;
						 int_l_int_retval = 1;
					}
				}
			}
		}
		printf("l_ret_val = |%d|\n",int_l_int_retval);
				fflush(stdout);
		printf("it came to i-------------\n");
				fflush(stdout);
		if(int_l_int_retval)
		{
			printf("it came here tooo inside i\n");
				fflush(stdout);
			break;
		}
}

	printf("It came hereeeee toooooo before closinf the cursor\n");	
				fflush(stdout);

	EXEC SQL CLOSE dswrappermap_cur;
	IS_ANY_ORA_ERROR


	DEFORMAT_IF_DEBUG
	{
		printf("The wrapper name is %s and chr_func miode is %s and proc name is %s\n",p_msg_wrapper, p_func_mode, p_proc_name);
		printf("Leaving Function GetWrapperName\n");
				fflush(stdout);

	}	
	
	APL_GOBACK_SUCCESS	
	
LBL_EXIT_NO_DATA:
	EXEC SQL CLOSE dswrappermap_cur; 
	return SYS_NO_DATA; 

RETURN_SUCCESS:
	free(h_dswrappermap_struct);
	free(i_dswrappermap_struct);
	free(l_int_noelem);
	free(l_int_noelem_val);
	free(l_and_process_qual);
	free(l_and_process_seq);
	free(l_and_process_tag);
	free(l_and_process_value );
	free(l_and_process_blockno);
	free(l_or_value);
	return l_int_found;

RETURN_FAILURE:
	free(h_dswrappermap_struct);
	free(i_dswrappermap_struct);
	free(l_int_noelem);
	free(l_int_noelem_val);
	free(l_and_process_qual);
	free(l_and_process_seq);
	free(l_and_process_tag);
	free(l_and_process_value );
	free(l_and_process_blockno);
	free(l_or_value);
	
		return APL_FAILURE;
}



int GetEnvString(char *p_mode, char *p_env_str, DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{

	EXEC SQL BEGIN DECLARE SECTION;

	char    chr_l_str_temp[4000]		= APL_NULL_STRING;
	char	chr_l_userid[15]		= APL_NULL_STRING;
	char	chr_l_mode[15]		= APL_NULL_STRING;
	char	l_function_name[25]	= APL_NULL_STRING;
	char	l_auth_req[2]  		= APL_NULL_STRING;
	char	l_sub_action[20]	= APL_NULL_STRING;	
	char	chr_l_action[3]		= APL_NULL_STRING;	
	short   l_userid_shr		= 0;
	short	l_mode_shr		= 0;
	short	l_function_name_shr	= 0;
	short	l_auth_req_shr		= 0;
	short	l_sub_action_shr	= 0;
	short	l_action_shr		= 0;
	
	struct sqlca sqlca;

	EXEC SQL VAR chr_l_userid IS STRING;	
	EXEC SQL VAR chr_l_mode IS STRING;	
	EXEC SQL VAR l_function_name IS STRING;	
	EXEC SQL VAR l_auth_req IS STRING;	
	EXEC SQL VAR l_sub_action IS STRING;	
	EXEC SQL VAR chr_l_action IS STRING;	
	EXEC SQL VAR p_mode IS STRING;	

	EXEC SQL END DECLARE SECTION;

	DEFORMAT_IF_DEBUG
	{
		printf("Entering Function GetEnvString\n");
	}	

	EXEC SQL
	select 
		usr, 
		envmode, 
		function_name, 
		auth_req, 
		SUB_PROCESS, 
		h_process 
		into 	:chr_l_userid:l_userid_shr,
			:chr_l_mode:l_mode_shr, 
			:l_function_name:l_function_name_shr, 
			:l_auth_req:l_auth_req_shr, 
			:l_sub_action:l_sub_action_shr, 
			:chr_l_action:l_action_shr 
		from    dfenvmap
		where   function_mode = :p_mode;

	printf("The sql h_code is %d\n", sqlca.sqlcode);

	IS_ANY_ORA_ERROR

	if(sqlca.sqlcode == 1403)
		SYS_RETURN_NO_DATA_FOUND	
	
	strcpy(p_env_str,APL_NULL_STRING);
	strcpy(chr_l_str_temp,APL_NULL_STRING);
	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"USER",DATA_VALUE_SEPRTR,chr_l_userid);
	strcpy(p_env_str,chr_l_str_temp);

	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"MODE",DATA_VALUE_SEPRTR,chr_l_mode);
	strcat(p_env_str,chr_l_str_temp);

	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"FUNCTIONNAME",DATA_VALUE_SEPRTR,l_function_name);
	strcat(p_env_str,chr_l_str_temp);

	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"AUTHREQ",DATA_VALUE_SEPRTR,l_auth_req);
	strcat(p_env_str,chr_l_str_temp);

	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"SUBPROCESS",DATA_VALUE_SEPRTR,l_sub_action);
	strcat(p_env_str,chr_l_str_temp);

	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"ACTION",DATA_VALUE_SEPRTR,chr_l_action);
	strcat(p_env_str,chr_l_str_temp);

	DEFORMAT_IF_DEBUG
	{
		printf("The env string is %s\n",p_env_str);
		printf("Leaving Function GetEnvString\n");
	}	
	
	APL_GOBACK_SUCCESS

LBL_EXIT_NO_DATA:
	return SYS_NO_DATA;

RETURN_SUCCESS:
	return APL_SUCCESS;

RETURN_FAILURE:
	return APL_FAILURE;

}


int GetParamString(MESSAGE_STRUCT **l_message_list, char *chr_l_param_str, char *l_str_msg_name, DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{

	int l_int_temp_flag = 0;

   char l_msg_name[7] = APL_NULL_STRING;  /* ASHISH 16-05-2008 */

	EXEC SQL BEGIN DECLARE SECTION;
	
	H_DSPARAMMAP_STRUCT     *h_dsparammap_struct    = NULL;
	I_DSPARAMMAP_STRUCT     *i_dsparammap_struct    = NULL;
	int calloc_size=1;
	struct sqlca sqlca;

	EXEC SQL VAR h_dsparammap_struct->h_msg_name IS STRING;
	EXEC SQL VAR h_dsparammap_struct->h_field_type IS STRING;
	EXEC SQL VAR h_dsparammap_struct->h_label IS STRING;
	EXEC SQL VAR h_dsparammap_struct->h_msg_tag IS STRING;
	EXEC SQL VAR h_dsparammap_struct->chr_h_qualifier IS STRING;
	EXEC SQL VAR h_dsparammap_struct->h_sequence IS STRING;
	EXEC SQL VAR h_dsparammap_struct->h_static_val IS STRING;
	EXEC SQL VAR h_dsparammap_struct->h_val_type IS STRING;
	EXEC SQL VAR h_dsparammap_struct->h_block_no IS STRING;
	EXEC SQL VAR h_dsparammap_struct->h_query IS STRING;
	EXEC SQL VAR l_str_msg_name IS STRING;

	EXEC SQL END DECLARE SECTION;

	h_dsparammap_struct = (H_DSPARAMMAP_STRUCT *)calloc(calloc_size,sizeof(H_DSPARAMMAP_STRUCT));
	APL_MALLOC_FAIL(h_dsparammap_struct);

	i_dsparammap_struct = (I_DSPARAMMAP_STRUCT *)calloc(calloc_size,sizeof(I_DSPARAMMAP_STRUCT));
	APL_MALLOC_FAIL(i_dsparammap_struct);

	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function GetParamString\n");
		printf("msg name is %s\n", l_str_msg_name);
	}


	strcpy(chr_l_param_str, APL_NULL_STRING);

   /*  ASHISH 16-05-2008 Start */
   strcpy(l_msg_name,l_str_msg_name); 
	sqlca.sqlcode = 0;	
	EXEC SQL DECLARE dsparammap_cur CURSOR FOR
	select * from dfparammap where msg_name = :l_msg_name and valid='Y' order by SRL_NUM;

   printf("\n Sql Error to declare cursor dsparammap_cur = |%d| \n",sqlca.sqlcode);
   /*  ASHISH 16-05-2008 End */

	IS_ANY_ORA_ERROR

	EXEC SQL OPEN dsparammap_cur;
	IS_ANY_ORA_ERROR

	for( ; ; )
	{
		memset(h_dsparammap_struct, NULL, sizeof(H_DSPARAMMAP_STRUCT));
		memset(i_dsparammap_struct, NULL, sizeof(I_DSPARAMMAP_STRUCT));

		EXEC SQL FETCH dsparammap_cur INTO :h_dsparammap_struct:i_dsparammap_struct;

		IS_ANY_ORA_ERROR

		if(sqlca.sqlcode == 1403)
		{
			if(l_int_temp_flag == 0)
				SYS_RETURN_NO_DATA_FOUND		
			break;
		}
		l_int_temp_flag = 1;
		
		if(FormParamString(l_message_list, chr_l_param_str, l_str_msg_name, h_dsparammap_struct, l_debug_info_ptr) == APL_FAILURE)
			APL_GOBACK_FAIL
	
	}
	DEFORMAT_IF_DEBUG
	{
		printf("The output is %s\n", chr_l_param_str);
		printf("\n Leaving Function GetParamString\n");
	}

	EXEC SQL CLOSE dsparammap_cur;
	IS_ANY_ORA_ERROR

	APL_GOBACK_SUCCESS

LBL_EXIT_NO_DATA:
	APL_FREE(h_dsparammap_struct);
	APL_FREE(i_dsparammap_struct);
	EXEC SQL CLOSE dsparammap_cur;
	return SYS_NO_DATA;

RETURN_SUCCESS:
	APL_FREE(h_dsparammap_struct);
	APL_FREE(i_dsparammap_struct);
	return APL_SUCCESS;

RETURN_FAILURE:
	APL_FREE(h_dsparammap_struct);
	APL_FREE(i_dsparammap_struct);
	return APL_FAILURE;
}


int FormParamString(MESSAGE_STRUCT **l_message_list, char *chr_l_param_str, char *l_str_msg_name, H_DSPARAMMAP_STRUCT *h_dsparammap_struct, DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{

		DEFORMAT_IF_DEBUG
		{
			printf("Entering the FormParamString Function\n");
		}


		if (strcmp(h_dsparammap_struct->h_field_type,"DIRECT")==0)
		{
			if( CatData_DIRECT(chr_l_param_str, l_message_list, h_dsparammap_struct->h_label, h_dsparammap_struct->h_msg_tag, h_dsparammap_struct->chr_h_qualifier, h_dsparammap_struct->h_sequence, h_dsparammap_struct->h_block_no, h_dsparammap_struct->h_val_type, l_debug_info_ptr) == APL_FAILURE)
				APL_GOBACK_FAIL
		}
		else if (strcmp(h_dsparammap_struct->h_field_type,"STATIC")==0)
		{
			CatData_STATIC(chr_l_param_str, h_dsparammap_struct->h_label, h_dsparammap_struct->h_static_val);
		}
		else if (strcmp(h_dsparammap_struct->h_field_type,"MAPVAL")==0)
		{
			if(CatData_MAPVAL(chr_l_param_str, l_str_msg_name, l_message_list,
			   h_dsparammap_struct->h_label,
			   h_dsparammap_struct->h_msg_tag,
			   h_dsparammap_struct->chr_h_qualifier,
			   h_dsparammap_struct->h_sequence, h_dsparammap_struct->h_block_no, l_debug_info_ptr) == APL_FAILURE)
				APL_GOBACK_FAIL
		}
		else if (strcmp(h_dsparammap_struct->h_field_type,"OTHER")==0)	
		{
			printf("here raka in other\n");
			if(CatData_OTHER(chr_l_param_str, l_str_msg_name, l_message_list,
			   h_dsparammap_struct->h_label,
			   h_dsparammap_struct->h_msg_tag,
			   h_dsparammap_struct->chr_h_qualifier,
			   h_dsparammap_struct->h_sequence, h_dsparammap_struct->h_block_no, l_debug_info_ptr) == APL_FAILURE)
				APL_GOBACK_FAIL
		}
		else if(strstr(h_dsparammap_struct->h_field_type,"#"))
		{
			if(CatData_MULTIPLEQUERY(chr_l_param_str, l_message_list,
			   h_dsparammap_struct->h_label,
			   h_dsparammap_struct->h_msg_tag,
			   h_dsparammap_struct->chr_h_qualifier,
			   h_dsparammap_struct->h_sequence,
			   h_dsparammap_struct->h_block_no,
			   h_dsparammap_struct->h_query,
			   h_dsparammap_struct->h_field_type,
			   h_dsparammap_struct->h_val_type,
			   h_dsparammap_struct->h_static_val,
			   l_str_msg_name,l_debug_info_ptr) == APL_FAILURE)
				APL_GOBACK_FAIL
		}


                DEFORMAT_IF_DEBUG
                {
                        printf("Leaving the FormParamString Function\n");
                }

	APL_GOBACK_SUCCESS

RETURN_SUCCESS:
	return APL_SUCCESS;

RETURN_FAILURE:
	return APL_FAILURE;
}



int PutClientRequest(char *p_proc_name, char *p_func_name, char *p_env_str, char *chr_p_param_str, char *p_userid, char *p_misinfo, char *p_error_desc, DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
        EXEC SQL BEGIN DECLARE SECTION;

	char chr_l_error_desc[4000]= APL_NULL_STRING;
	EXEC SQL VAR chr_l_error_desc IS STRING;

	EXEC SQL END DECLARE SECTION;

	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function PutClientRequest\n");
	}

	/*
	if(strcmp(p_proc_name, "SP_CA") == 0)
	{
		EXEC SQL CALL SP_CA(:p_func_name, :p_env_str, :chr_p_param_str, :p_userid, :p_misinfo, :chr_l_error_desc);
	}
	else if(strcmp(p_proc_name, "SP_BILL") == 0)
	{
	}
	else if(strcmp(p_proc_name, "SP_BATCH") == 0)
	{
	}
	else if(strcmp(p_proc_name, "SP_MNT") == 0)
	{
	}
	*/
	if(strcmp(p_proc_name, "SP_INTL_DEAL") == 0)
	{
		CO_ProcMonitor(APL_OUT_FILE,"Before stored procedure ::: ",l_debug_info_ptr,NULL);
		/* Changes mode to call stored proc which will not wait for record to be processed.. */
		EXEC SQL CALL SP_INTL_DEAL_NO_WAIT(:p_func_name, :p_env_str, :chr_p_param_str, :p_userid, :p_misinfo, :chr_l_error_desc);
		/*
		EXEC SQL CALL SP_INTL_DEAL(:p_func_name, :p_env_str, :chr_p_param_str, :p_userid, :p_misinfo, :chr_l_error_desc);
		*/
	}
	
	IS_ANY_ORA_ERROR

	strcpy(p_error_desc,chr_l_error_desc);

	DEFORMAT_IF_DEBUG
	{
		printf("\n Leaving Function PutClientRequest. The ERR_DESC is: %s \n",chr_l_error_desc);
	}

	APL_GOBACK_SUCCESS

RETURN_SUCCESS:
	return APL_SUCCESS;

RETURN_FAILURE:
	return APL_FAILURE;

}

/*
int GBDbInsAMSGLINK(MESSAGE_STRUCT **l_message_list, char *p_str_client_table, char *p_str_msg_name,
char *l_msg_func_mode, char *l_message_file_name, char *l_ca_id_return, DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{

	EXEC SQL BEGIN DECLARE SECTION;

	int  int_l_int_retval				= 0;
	char chr_l_ca_id[21]			= APL_NULL_STRING;
	char chr_l_prelim_ind[2]			= APL_NULL_STRING;
	char chr_l_client[APL_CLIENT_LENGTH]		= APL_NULL_STRING;
	char chr_l_msg_no[7]			= APL_NULL_STRING;
	char l_in_out[2]			= APL_NULL_STRING;
	char l_msgrefno[APL_TXNREFNO_LEN]	= APL_NULL_STRING;
	char chr_l_input_dt[APL_DATE_LEN]		= APL_NULL_STRING;
	char l_str_addinfo[31]			= APL_NULL_STRING;
	char l_str_temp_file_name[31]		= APL_NULL_STRING;
	char chr_l_event_type[3]    		= APL_NULL_STRING;
	char l_link_type[3]    			= APL_NULL_STRING;
	char chr_l_decl_dt[20]    			= APL_NULL_STRING;
	char chr_l_instrcode[9] 			= APL_NULL_STRING;
	int  *l_ptr_evnt_nbr		=NULL ;
	int  int_l_event_nbr 			= 0;
	char l_msg_func[16] 			= APL_NULL_STRING;	

	struct sqlca sqlca;

	EXEC SQL VAR chr_l_event_type   		IS STRING;
	EXEC SQL VAR chr_l_instrcode   		IS STRING;
	EXEC SQL VAR chr_l_ca_id   			IS STRING;
	EXEC SQL VAR l_link_type   		IS STRING;
	EXEC SQL VAR l_message_file_name   	IS STRING;
	EXEC SQL VAR l_str_temp_file_name   	IS STRING;
	EXEC SQL VAR l_msg_func		   	IS STRING;
	EXEC SQL VAR l_msg_func_mode	   	IS STRING;

	EXEC SQL END DECLARE SECTION;

	l_ptr_evnt_nbr =  (int *)calloc(1,sizeof(int));
	memset(l_ptr_evnt_nbr,NULL,sizeof(int));

	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function GBDbInsAMSGLINK\n");
	}

	int_l_int_retval = I_GetVal(l_message_list,":97A:",":SAFE/",chr_l_client,"B", "1");
	int_l_int_retval = I_GetVal(l_message_list,":20C:",":SEME/",l_msgrefno,"A", "1");

	CO_Rtv_DataString(p_str_client_table,"EVENT_TYPE",(char *)chr_l_event_type);
	CO_Rtv_DataString(p_str_client_table,"DECLARE_DT",(char *)chr_l_decl_dt);
	CO_Rtv_DataString(p_str_client_table,"SECURITY_CD",(char *)chr_l_instrcode);
	CO_Rtv_DataInt(p_str_client_table,"EVNT_INDNT",(int *)l_ptr_evnt_nbr);
	int_l_event_nbr = *l_ptr_evnt_nbr;

	EXEC SQL SELECT ENVMODE INTO :l_msg_func FROM DFENVMAP WHERE FUNCTION_MODE = :l_msg_func_mode;
	IS_ANY_ORA_ERROR;
	
	if (strcmp(l_msg_func,"INP")==0)
	{
		EXEC SQL SELECT CORP_ID, PRELIMINARY_FLAG, TIMESTAMP INTO :chr_l_ca_id, :chr_l_prelim_ind, :chr_l_input_dt
			FROM CAEVENT
			WHERE CA_EVENT    	= :chr_l_event_type
			AND     DECLARE_DT 	= :chr_l_decl_dt
			AND     SECURITY_CD  	= :chr_l_instrcode
			AND     EVNT_INDNT        = :int_l_event_nbr;
		IS_ANY_ORA_ERROR;
	}
	else
	{
		int_l_int_retval = GetCAIDFromAMSGLINK(p_str_client_table,l_message_list,p_str_msg_name,chr_l_ca_id,l_debug_info_ptr);
		EXEC SQL SELECT  PRELIMINARY_FLAG, TIMESTAMP INTO :chr_l_prelim_ind,:chr_l_input_dt
			FROM CAEVENT
			WHERE CORP_ID = :chr_l_ca_id;

		IS_ANY_ORA_ERROR;
	}

	if (strcmp(l_msg_func,"INP")==0)
	{
		strcpy(l_link_type,"VN");
	}
	else if (strcmp(l_msg_func,"MOD")==0)
	{
		strcpy(l_link_type,"VC");
	}
	else if (strcmp(l_msg_func,"DEL")==0)
	{
		strcpy(l_link_type,"VR");
	}
	else
	{
		strcpy(l_link_type,"XX");
	}

	if (strchr(l_message_file_name,'/'))
		strcpy(l_str_temp_file_name,strrchr(l_message_file_name,'/')+1);
	else
		strcpy(l_str_temp_file_name,l_message_file_name);

																		EXEC SQL INSERT INTO CAMESGLINK VALUES (
	:chr_l_ca_id,
	:chr_l_prelim_ind,
	:chr_l_client,
	:p_str_msg_name,
	'I',
	:l_link_type,
	:l_msgrefno,
	:chr_l_input_dt,
	:l_str_temp_file_name);

	IS_ANY_ORA_ERROR;

	EXEC SQL COMMIT;
	IS_ANY_ORA_ERROR;

	strcpy(l_ca_id_return,chr_l_ca_id);

	DEFORMAT_IF_DEBUG
	{
		printf("\n Leaving Function GBDbInsAMSGLINK\n");
	}
	APL_GOBACK_SUCCESS;

RETURN_SUCCESS:
	return APL_SUCCESS;

RETURN_FAILURE:
	return APL_FAILURE;
}
*/

int GetCAIDFromAMSGLINK(char *p_str_client_table, MESSAGE_STRUCT **l_message_list, char *p_str_msg_name,
char *chr_l_ca_id, DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	EXEC SQL BEGIN DECLARE SECTION;

	char chr_l_client[APL_CLIENT_LENGTH]		= APL_NULL_STRING;
	char l_prev[APL_TXNREFNO_LEN]		= APL_NULL_STRING;
	char l_str_temp_ca_id[21] 			= APL_NULL_STRING;
	int  int_l_int_retval 					= 0;

	struct sqlca sqlca;

	EXEC SQL VAR l_str_temp_ca_id   		IS STRING;
	EXEC SQL VAR chr_l_client   		IS STRING;
	EXEC SQL VAR p_str_msg_name   		IS STRING;
	EXEC SQL VAR l_prev   			IS STRING;

	EXEC SQL END DECLARE SECTION;


	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function GetCAIDFromAMSGLINK\n");
	}

	int_l_int_retval = I_GetVal(l_message_list,":20C:",":PREV/",l_prev,"A", "1");
	int_l_int_retval = I_GetVal(l_message_list,":97A:",":SAFE/",chr_l_client,"B", "1");

	EXEC SQL SELECT MAX(CORP_ID)
		INTO    :l_str_temp_ca_id
		FROM 	CAMESGLINK
		WHERE   CLIENT 	= :chr_l_client
		AND     SWIFT_MSG_NO  	= :p_str_msg_name
		AND     MSG_IN_OUT_IND  	= 'I'
		AND     TYPEOF_MSG_LNK in ('VN','VC','VR')
		AND     SWIFT_MSGREFNO        = :l_prev;
		IS_ANY_ORA_ERROR;

		strcpy(chr_l_ca_id, l_str_temp_ca_id);

		DEFORMAT_IF_DEBUG
		{
			printf("\n Leaving Function GetCAIDFromAMSGLINK\n");
		}

	APL_GOBACK_SUCCESS;

RETURN_SUCCESS:
	return APL_SUCCESS;

RETURN_FAILURE:
	return APL_FAILURE;
}


int UpdateLog(FILE *fl_log,char *chr_l_err_desc,char *l_message_file_name,char *record_type, char *l_identifier, DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function UpdateLog\n");
	}

	if (strncmp(chr_l_err_desc,"SUCCESS",7)==0)
	{
		DEFORMAT_IF_DEBUG
		{
			printf("Processed %s successfully ....|%s|\n",record_type,l_identifier);
		}

		sprintf(g_log_buff_common,"Processed %s successfully ....|%s|",record_type,l_identifier);
		CO_ProcMonitor(fl_log, g_log_buff_common, NULL , NULL);
	}
	else
	{
		DEFORMAT_IF_DEBUG
		{
			printf("Error int_found during %s processing ....\n",record_type);
			printf("Error --> |%s| \n",chr_l_err_desc);
		}

		sprintf(g_log_buff_common,"Error int_found during %s processing ....",record_type);
		CO_ProcMonitor(fl_log, g_log_buff_common, NULL , NULL);

		sprintf(g_log_buff_common,"Error -->  ");
		CO_ProcMonitor(fl_log, g_log_buff_common, l_debug_info_ptr , NULL);
	}
									
	DEFORMAT_IF_DEBUG
	{
		printf("\n Leaving Function UpdateLog\n");
	}

	return APL_SUCCESS;
}


int I_InsertMessageRecordNode(
	MESSAGE_STRUCT   **message_struct_ptrptr,
	char*            msg_tag,
	char*            qual,
	char*            int_val,
      	char*            sequence,
    	char*            description,
	char*		 block_no_val 
)
{
		  int i=0 ;	
		  MESSAGE_STRUCT **l_message_list     = message_struct_ptrptr;

		  while ( (*l_message_list) != NULL)
		  {
					Alert(" ****** internal list =|%d|", i++);
					 l_message_list = &((*l_message_list)->h_next);
		  }

		  Alert("At 1563");
		  if ( ( (*l_message_list) = (MESSAGE_STRUCT *)calloc(1,sizeof(MESSAGE_STRUCT)) ) == NULL )
		  {
					 Alert("In Fail");
						 APL_GOBACK_FAIL
		  }

		  strcpy((*l_message_list)->msg_tag,msg_tag);
		  strcpy((*l_message_list)->qual,qual);
		  strcpy((*l_message_list)->int_val,int_val);
		  strcpy((*l_message_list)->sequence,sequence);
		  strcpy((*l_message_list)->description,description);
		  strcpy((*l_message_list)->block_no,block_no_val);
		  Alert("At 1576");

		  APL_GOBACK_SUCCESS

					 RETURN_SUCCESS:  return APL_SUCCESS;
RETURN_FAILURE:  return APL_FAILURE;
}



int PutCLIENT_BILLRequest(char *p_func_name,char *p_env_str,char *p_str_ft,char *p_str_ft1, 
char *p_str_ft2,char *p_userid,char *p_error_desc)
{
	EXEC SQL BEGIN DECLARE SECTION;

	char chr_l_error_desc[4000]= APL_NULL_STRING;
	EXEC SQL VAR chr_l_error_desc IS STRING;

	EXEC SQL END DECLARE SECTION;

	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function PutCLIENT_BILLRequest\n");
	}


	strcpy(p_error_desc,chr_l_error_desc);

	DEFORMAT_IF_DEBUG
	{
		printf("\n Leaving Function PutCLIENT_BILLRequest\n");
	}
	return APL_SUCCESS;
}


int DisplayMessageDetails(MESSAGE_STRUCT **l_message_list)
{
	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function DisplayMessageDetails\n");
	}
	
	while ( (*l_message_list) != NULL)
	{
		printf("\n ..... Sequence is |%s| Tag is |%s|",(*l_message_list)->sequence,(*l_message_list)->msg_tag);
		printf(" Qualifier is |%s| Value is |%s|",(*l_message_list)->qual,(*l_message_list)->int_val);
		printf(" Description is |%s| ",(*l_message_list)->description);
		printf(" Block is |%s| ",(*l_message_list)->block_no);	

		l_message_list = &((*l_message_list)->h_next);
	}


	DEFORMAT_IF_DEBUG
	{
		printf("\n Leaving Function DisplayMessageDetails\n");
	}

	return APL_SUCCESS;
}



int CompSeqTagQualVal(MESSAGE_STRUCT *p_message_list, char *p_str_sequence,char *p_str_tag,char *p_str_qual,char *p_str_val)
{
	int l_int_found = 0;

	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function CompSeqTagQualVal\n");
	}

	if ((strcmp( p_message_list->sequence, p_str_sequence ) == 0) && (strcmp( p_message_list->msg_tag,p_str_tag ) == 0) && (strcmp( p_message_list->qual, p_str_qual ) ==0) && (strcmp( p_message_list->int_val, p_str_val ) == 0))
	{
		l_int_found =1;	
	}

	DEFORMAT_IF_DEBUG
	{
		printf("Leaving Function CompSeqTagQualVal\n");
	}

	return l_int_found;
}

int CompSeqTagQual(MESSAGE_STRUCT *p_message_list, char *p_str_sequence,char *p_str_tag,char *p_str_qual)
{
	int l_int_found = 0;

	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function CompSeqTagQual\n");
	}

	if ((strcmp( p_message_list->sequence, p_str_sequence ) == 0) && (strcmp( p_message_list->msg_tag, p_str_tag ) == 0) && (strcmp( p_message_list->qual, p_str_qual ) == 0) )
	{
		l_int_found = 1;	
	}

	DEFORMAT_IF_DEBUG
	{
		printf("Leaving Function CompSeqTagQual\n");
	}

	return l_int_found; 
}


int CompSeqTag(MESSAGE_STRUCT *p_message_list, char *p_str_sequence,char *p_str_tag)
{
	int l_int_found = 0;
	
	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function CompSeqTag\n");
	}

	if ((strcmp( p_message_list->sequence, p_str_sequence ) == 0) && (strcmp( p_message_list->msg_tag, p_str_tag ) == 0) )
	{
		l_int_found = 1;
	}

	DEFORMAT_IF_DEBUG
	{
		printf("Leaving Function CompSeqTag\n");
	}

	return l_int_found;
}

int CompSeqQual(MESSAGE_STRUCT *p_message_list, char *p_str_sequence,char *p_str_qual)
{
	int l_int_found = 0;

	DEFORMAT_IF_DEBUG
	{
		printf("Entered Function CompSeqQual\n");
	}

	if ((strcmp( p_message_list->sequence, p_str_sequence ) == 0) && (strcmp( p_message_list->qual, p_str_qual ) ==0))
	{
		l_int_found = 1;
	}

	DEFORMAT_IF_DEBUG
	{
		printf("Leaving Function CompSeqQual\n");
	}

	return l_int_found;
}

int CompTagQual(MESSAGE_STRUCT *p_message_list, char *p_str_tag,char *p_str_qual)
{
	int l_int_found = 0;

	DEFORMAT_IF_DEBUG
        {
	       printf("Entered Function CompTagQual\n");
        }

        if ( (strcmp( p_message_list->msg_tag, p_str_tag ) == 0) && (strcmp( p_message_list->qual, p_str_qual ) ==0))
        {
		l_int_found = 1;
	}

	DEFORMAT_IF_DEBUG
	{
		printf("Leaving Function CompTagQual\n");
	}

	return l_int_found;
}


int I_FreeMessageList(MESSAGE_STRUCT **p_message_list)
{
	MESSAGE_STRUCT *l_message_list = NULL;

/*
	if((l_message_list = (MESSAGE_STRUCT *)(calloc(1,sizeof(MESSAGE_STRUCT )))) == NULL)
	{
		printf("\n Problem in memory allocation for l_message_list ............. \n");
		fflush(stdout);
		APL_GOBACK_FAIL
	} 


*/

	DEFORMAT_IF_DEBUG
	{
		printf("Entering Function I_FreeMessageList\n");
		fflush(stdout);
	}

	while(*p_message_list)
	{
			  Alert("At 1790");
			  l_message_list=(*p_message_list)->h_next;
			  Alert("At 1789 E");
			  free((*p_message_list));
			  Alert("At 1789 A");

			  /**if((p_message_list = (MESSAGE_STRUCT **)(calloc(1,sizeof(MESSAGE_STRUCT **)))) == NULL)
				 {
				 printf("\n Problem in memory allocation for p_message_list ............. \n");
				 fflush(stdout);
				 APL_GOBACK_FAIL
				 }  29/05/2012 **/
			  (*p_message_list)=l_message_list;
			  Alert("At 1789 B");
	}
		Alert("At 1789 C");

	Alert("Leaving Function I_FreeMessageList\n");
	fflush(stdout);

	/* DEFORMAT_IF_DEBUG
	{
		printf("Leaving Function I_FreeMessageList\n");
		fflush(stdout);
	}*/

	APL_GOBACK_SUCCESS
	
	RETURN_SUCCESS:
			return APL_SUCCESS;

	RETURN_FAILURE:
			return APL_FAILURE;
}



int I_GetVal(
      	MESSAGE_STRUCT   **p_message_list,
    	char*            msg_tag,
	char*            qual,
	char*            int_val,
	char*            sequence,
	char*		 block_no
)
     {

	int     l_int_found_val = 0;

    	DEFORMAT_IF_DEBUG
       	{
	       printf("Entering Function I_GetVal\n");
	}

     	while(*p_message_list)
	{
		if ((strcmp((*p_message_list)->msg_tag,msg_tag) == 0) &&
		(strcmp((*p_message_list)->qual,qual) == 0) &&
		 (strcmp((*p_message_list)->sequence,sequence) == 0)&&
		 (strcmp((*p_message_list)->block_no,block_no) == 0))
		{
			strcpy(int_val,(*p_message_list)->int_val);
			l_int_found_val = 1;
			break;
		}
		else
		{
			p_message_list = &((*p_message_list)->h_next);
			l_int_found_val     =       0;
			continue;
		}
   	}
	
      	DEFORMAT_IF_DEBUG
	{
		 printf("Leaving Function I_GetVal\n");
        }

       return l_int_found_val;
}


int I_GetDescription(
	MESSAGE_STRUCT   **p_message_list,
	char*            msg_tag,
	char*            qual,
	char*            description,
	char*            sequence,
	char*            block_no
)
{

	int     l_int_found_val = 0;

        DEFORMAT_IF_DEBUG
	{
		printf("Entering Function I_GetDescription\n");
	}

	while(*p_message_list)
	{
		if ((strcmp((*p_message_list)->msg_tag,msg_tag) == 0) &&
		    (strcmp((*p_message_list)->qual,qual) == 0) &&
		    (strcmp((*p_message_list)->sequence,sequence) == 0)&&
		    (strcmp((*p_message_list)->block_no,block_no) == 0))
		{
			strcpy(description,(*p_message_list)->description);
			l_int_found_val = 1;
			break;
		}
		else
		{
			p_message_list = &((*p_message_list)->h_next);
			l_int_found_val = 0;
			continue;
		}
	}

        DEFORMAT_IF_DEBUG
	{
		printf("Leaving Function I_GetDescription\n");
	}

	return l_int_found_val;
}



int I_GetQual(
      	MESSAGE_STRUCT   **p_message_list,
	char*            msg_tag,
	char*            qual,
	char*            sequence,
	char*		 block_no 
)
{
	int     l_int_found_qual = 0;

   	DEFORMAT_IF_DEBUG
      	{
		 printf("Entering Function I_GetQual\n");
	}


    	while(*p_message_list)
       {
		if ((strcmp((*p_message_list)->msg_tag,msg_tag) == 0) &&
		    (strcmp((*p_message_list)->sequence,sequence) == 0) &&
		    (strcmp((*p_message_list)->block_no,block_no) ==0))
		{
			strcpy(qual,(*p_message_list)->qual);
			l_int_found_qual =1;
			break;
		}
		else
		{
			p_message_list = &((*p_message_list)->h_next);
			l_int_found_qual = 0;
			continue;
		}
      }

      DEFORMAT_IF_DEBUG
      {
	 printf("Leaving Function I_GetQual\n");
      }

       return l_int_found_qual;
}


int ChkErrorAddNoteNbr(char *chr_l_err_desc,char *p_str_client_table,char *l_note_nbr)
{

       if ( (strncmp(chr_l_err_desc,"SUCCESS",7)==0) || (strstr(chr_l_err_desc,"Foot Note Already Exists")!=0) )
       {
	      CatData_STATIC(p_str_client_table,"INFO_SEQ",l_note_nbr);
       }
	return APL_SUCCESS;
}


int MoveFileToArch(char *chr_fl_name,char *p_incmsgarchdir, DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	char chr_l_buf2[500] = APL_NULL_STRING;
	int  l_return	 = 0;
	int  int_l_int_retval		 = 0;	

	DEFORMAT_IF_DEBUG
	{
		printf("Entered MoveFileToArch ..... \n");
		fflush(stdout);
	}

	memset(chr_l_buf2, APL_NULL_CHAR , 500);

	 
                /*VaibhavK 16June2008 SIT issue 1598*/
	
		memset(chr_l_buf2,APL_NULL_CHAR,sizeof(chr_l_buf2));
		printf("\n Move Command is \n %s \n",chr_l_buf2);
                fflush(stdout);
		printf("\n After move command 1st chr_fl_name = |%s|", chr_fl_name);
		fflush(stdout);
		printf("\n After move command 1st  p_incmsgarchdir = |%s|", p_incmsgarchdir);
                fflush(stdout);	
		//sprintf(chr_l_buf2, "cp \"%s\" %s ",chr_fl_name, p_incmsgarchdir); //babu
                sprintf(chr_l_buf2, "cp %s %s ",chr_fl_name, p_incmsgarchdir);
		APL_IF_DEBUG
		//Alert("\nMove Command is \n %s \n",chr_l_buf2);
		//Hardik
		printf("\n Move Command is \n %s \n",chr_l_buf2);
		fflush(stdout);
		/*Changed by kotubabu for Linux Migration(System Command Returns -1 in Linux)- START*/
		l_return = system(chr_l_buf2); 
		//if (system(chr_l_buf2) != 0 ) /**** TUX ***/
        if (l_return != 0 && l_return != -1)
		/*Changed by kotubabu for Linux Migration(System Command Returns -1 in Linux)- END*/
		{
			printf("\n Unable to copy file |%s| To ARCH Directory\n",chr_fl_name);
			fflush(stdout);
			APL_GOBACK_FAIL;
		}

			

  		memset(chr_l_buf2, APL_NULL_CHAR , sizeof(chr_l_buf2));
		printf("\n Move Command is \n %s \n",chr_l_buf2);
                fflush(stdout);
                printf("\n After move command 2nd chr_fl_name = |%s|", chr_fl_name);
                fflush(stdout);
                printf("\n After move command 2nd  p_incmsgarchdir = |%s|", p_incmsgarchdir);
                fflush(stdout);
		sprintf(chr_l_buf2, "rm -f \"%s\" ",chr_fl_name); /*VaibhavK 16June2008 SIT issue 1598*/
	//	Alert("\nMove Command is \n %s \n",chr_l_buf2);
		 printf("\n Move Command hardik 2nd is \n %s \n",chr_l_buf2);
		fflush(stdout);

		l_return = system(chr_l_buf2);
		if ( l_return != 0 && l_return != -1) /** TUX ***/ /*Changed by kotubabu for Linux Migration(System Command Returns -1 in Linux)*/
		{
			printf("\n Unable to remove file |%s| \n",chr_fl_name);
		fflush(stdout);
			APL_GOBACK_FAIL;
		}




	DEFORMAT_IF_DEBUG
	{
		printf("Leaving the processtion MoveFileToArch ........\n");
		fflush(stdout);
	}

	APL_GOBACK_SUCCESS

RETURN_SUCCESS:
	return APL_SUCCESS;
RETURN_FAILURE:
	return APL_FAILURE;
}


int CheckForDaemonStatus(char *swift_msg_no, DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	int  l_return_val 	= 0;
	char l_daemon_name[20] 	= APL_NULL_STRING;
	

	EXEC SQL BEGIN DECLARE SECTION;
	struct sqlca sqlca;
	EXEC SQL VAR l_daemon_name IS STRING;

	EXEC SQL END DECLARE SECTION;

	DEFORMAT_IF_DEBUG
	{
		printf("\n Entering Function CheckForDaemonStatus\n");
		fflush(stdout);
		printf("\n the msg entered id %s", swift_msg_no);
		fflush(stdout);
	}

	if(strstr(swift_msg_no, "56"))
	{
		strcpy(l_daemon_name, "CA_Server");
	}
	else if((strstr(swift_msg_no, "54"))||(strstr(swift_msg_no, "515")))
	{
		strcpy(l_daemon_name, "Daemon_DL");
	}
	else if(strstr(swift_msg_no, "53"))
	{
		l_return_val = APL_SUCCESS;
		APL_GOBACK_SUCCESS
	}
	else
	{
		return SYS_NO_DATA;
	}
	EXEC SQL select status into :l_return_val from PRO_DAEMON_STATUS where PROC_NAME = :l_daemon_name;
	IS_ANY_ORA_ERROR

	DEFORMAT_IF_DEBUG
	{
		printf("\n Leaving Function CheckForDaemonStatus\n");
		fflush(stdout);
	}
	
	APL_GOBACK_SUCCESS

RETURN_SUCCESS:
	return l_return_val;
RETURN_FAILURE:
	return APL_FAILURE;
}


/*
int CheckAgentCode(MESSAGE_STRUCT **l_message_list, DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	int     l_return_val            = 0;
	char    l_swift_addr[70]        = APL_NULL_STRING;
	char 	chr_l_error_desc[400]	=APL_NULL_STRING;
	EXEC SQL BEGIN DECLARE SECTION;
	EXEC SQL VAR l_swift_addr IS STRING;
	struct sqlca sqlca ;
	EXEC SQL END DECLARE SECTION;
	DEFORMAT_IF_DEBUG
	{
		printf("\n Entering Function CheckAgentCode\n");
		fflush(stdout);
	}

	GetDataFromHeader_Separator(l_message_list, LINE_FOR_SWIFT_ADDR, ' ', 1, l_swift_addr);
	printf(" \n SWIFTADDRESS =%s= strlen = %d \n",l_swift_addr,strlen(l_swift_addr));
	EXEC SQL select count(*) into :l_return_val from cagent where swiftaddr = :l_swift_addr and status_ind = 'AA';
	IS_ANY_ORA_ERROR
	printf("sqlcode IS= %d  rteurnval is == %d \n",sqlca.sqlcode,l_return_val);
	if((sqlca.sqlcode == 1403)|| (l_return_val == 0))
	{
		
		CO_ProcMonitor(APL_OUT_FILE,"Agent h_code not int_found \n",NULL,NULL);
		SYS_RETURN_NO_DATA_FOUND;
	}
	if(l_return_val >1)
	{
		CO_ProcMonitor(APL_OUT_FILE,"Multiple entries \n",NULL,NULL);
		APL_GOBACK_FAIL
	}
	DEFORMAT_IF_DEBUG
	{
		printf("\n Leaving Function CheckAgentCode\n");
	}

	APL_GOBACK_SUCCESS

RETURN_SUCCESS:
	{
		DEFORMAT_IF_DEBUG
		{
			printf("Leaving fuction CheckAgentCode Successfully\n");
		}	
		return APL_SUCCESS;
	}
RETURN_FAILURE:
	{
		CO_Rtv_ErrString(l_debug_info_ptr,chr_l_error_desc);
		DEFORMAT_IF_DEBUG
		{
			fprintf(APL_OUT_FILE,"ERROR IS %d \n",chr_l_error_desc);
		}
		return APL_FAILURE;
	}
LBL_EXIT_NO_DATA:
	{
		return SYS_NO_DATA;
	}
}
*/


int GetDataFromHeader_StartEndPos(MESSAGE_STRUCT **l_message_list, int l_line_no, int int_l_start_pos, int l_end_pos, char *l_return_string)
{
	char chr_l_str[1000]		 = APL_NULL_STRING;
	char l_return_str_temp[100] 	 = APL_NULL_STRING;
	int  l_break_flag; 
	int  l_line_no_temp = 0;

	DEFORMAT_IF_DEBUG
	{
		printf("\n Entering Function GetDataFromHeader_StartEndPos\n");
	}

	strcpy(chr_l_str, (*l_message_list)->description);	


	l_break_flag = 1;

        if(l_line_no < 0)
		l_line_no = 0;

	if(l_end_pos < 0)
		l_end_pos= 0;
	
	if(int_l_start_pos < 0)
		int_l_start_pos = 0;

	l_line_no_temp = l_line_no;

	while(l_line_no && l_break_flag)
	{
		l_break_flag = 0;
		sscanf(chr_l_str, "%[^\n]\n",l_return_str_temp);
		l_return_str_temp[strlen(l_return_str_temp)]='\0';

		if((strchr(chr_l_str,'\n')) != NULL)
		{
			strcpy(chr_l_str,strchr(chr_l_str,'\n')+1);
			l_break_flag = 1;
		}
		
		l_line_no--;
	}


	if(l_line_no_temp)
	{
		if(strlen(l_return_str_temp + int_l_start_pos) > l_end_pos)
		{
			strncpy(l_return_string, l_return_str_temp + int_l_start_pos, l_end_pos);
			l_return_string[l_end_pos] = '\0';
		}
		else
			strcpy(l_return_string, l_return_str_temp + int_l_start_pos);
	}

	
	DEFORMAT_IF_DEBUG
	{
		printf("\n Leaving Function GetDataFromHeader_StartEndPos\n");
	}
	
	return APL_SUCCESS;
}


int GetDataFromHeader_Separator(MESSAGE_STRUCT **p_message_list, int l_line_no, char p_char_separator, int l_part_num, char *l_return_string)
{
	char chr_l_str[1000]                 = APL_NULL_STRING;
	char l_return_str_temp[100]      = APL_NULL_STRING;
        char l_return_str_part_1[100]    = APL_NULL_STRING;	
        char l_return_str_part_2[100]    = APL_NULL_STRING;	
	int  l_break_flag;
	int  l_line_no_temp		 = 0;

	DEFORMAT_IF_DEBUG
	{
		printf("\n Entering Function GetDataFromHeader_Separator\n");
	}

	strcpy(chr_l_str, (*p_message_list)->description);

	if(l_line_no < 0)
		l_line_no = 0;
	
	if(l_part_num < 0)
		l_part_num = 0;

	l_break_flag = 1;
	l_line_no_temp = l_line_no;

	while(l_line_no && l_break_flag)
	{
                l_break_flag = 0;
		sscanf(chr_l_str, "%[^\n]\n",l_return_str_temp);
		l_return_str_temp[strlen(l_return_str_temp)]='\0';

                if((strchr(chr_l_str,'\n')) != NULL)
		{
			strcpy(chr_l_str,strchr(chr_l_str,'\n')+1);
			l_break_flag = 1;
		}
		
		l_line_no--;
	}

	while(l_part_num && l_line_no_temp)
	{
		if(strchr(l_return_str_temp,p_char_separator))
		{
			SeparateData(l_return_str_temp, p_char_separator, l_return_str_part_1, l_return_str_part_2);
			strcpy(l_return_str_temp, l_return_str_part_2);
		}
		else
		{
			strcpy(l_return_str_part_1, l_return_str_temp); 
		}
		l_part_num--;
	}

	strcpy(l_return_string, l_return_str_part_1);


	DEFORMAT_IF_DEBUG
	{
		printf("\n Leaving Function GetDataFromHeader_Separator\n");
	}

	return APL_SUCCESS;
}

int StrSplitFn(char *p_src, char *p_separator, int *int_p_noelem, char ***p_retstr )
{
   printf("here in strsplit\n");
	int l_int_loop=0;
   int l_int_len=0;
   *int_p_noelem = 0;
   for (l_int_loop=0;l_int_loop<strlen(p_src);)
   {
      //if (p_src[l_int_loop++] == p_separator) CHanges done for AIX Migration
        if (p_src[l_int_loop++] == p_separator[0])
         (*int_p_noelem)++;
   }
   (*int_p_noelem)++;
   l_int_loop = 0;
   /** AIX -Change CA fail if nothing is passed **/
     if (*int_p_noelem ==0 )
   {
      *p_retstr=(char **)calloc(1, sizeof(char *));
        if (strlen(p_src)==0)
      {
        *(*p_retstr+0) = (char *)calloc(1, 2);
        strcpy(*(*p_retstr+0), APL_NULL_STRING);
      }

      else
       {
 
       *(*p_retstr+0) = (char *)calloc(1, strlen(p_src));
       strcpy(*(*p_retstr+0), p_src);
      }
      return APL_SUCCESS;
   }
 
   /**End **/
   *p_retstr=(char **)calloc(*int_p_noelem, sizeof(char *));
   if (*p_retstr == NULL) return APL_SUCCESS;
   while (1) {
          //AIX-Warnings Removal
      if (NULL == strchr(p_src, p_separator[0])) break;
      l_int_len = strlen(p_src) - strlen(strchr(p_src, p_separator[0]));
      if (!l_int_len)
      {
         *(*p_retstr+l_int_loop) = (char *)calloc(1, 1+l_int_len);
         *(*(*p_retstr+l_int_loop)) = NULL;
         p_src++;
      }
      else
      {
         *(*p_retstr+l_int_loop) = (char *)calloc(1, 1+l_int_len);
         if (*(*p_retstr+l_int_loop) == NULL) return APL_SUCCESS;
         strncpy(*(*p_retstr+l_int_loop), p_src, l_int_len);
         (*(*p_retstr+l_int_loop))[l_int_len] = '\0';
         p_src += l_int_len+1;
      }
      l_int_loop++;
      l_int_len = 0;
   }
   l_int_len = strlen(p_src);
   *(*p_retstr+l_int_loop) = (char *)calloc(1, 1+l_int_len);
   if (*(*p_retstr+l_int_loop) == NULL) return 0;
   strncpy(*(*p_retstr+l_int_loop), p_src, l_int_len);
   (*(*p_retstr+l_int_loop))[l_int_len] = '\0';
	printf("leavinf strsplit \n");
   return APL_SUCCESS;
}


int Get_misinfo(MESSAGE_STRUCT **p_msg_list, char *chr_p_filename,char *p_msg_name,  char *p_str_misinfo,char *p_str_funcmode ,char *p_mis_msg_name,DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
        	MESSAGE_STRUCT **l_message_list =	(MESSAGE_STRUCT **)NULL;
        	char l_str_misinfo[4001] = APL_NULL_STRING;
        	char l_str_funcdesc[61] = APL_NULL_STRING;
        	char l_str_msg_name[7] = APL_NULL_STRING;
        	char chr_l_str_temp[400] = APL_NULL_STRING;
        	char l_rec_from_sent_to[51] = APL_NULL_STRING;
        	char chr_l_str_filename[71] = APL_NULL_STRING;
        	char l_str_msgfunc_code[5] = APL_NULL_STRING;
        	char l_str_pset[161] = APL_NULL_STRING;
        	char l_str_place_code[5] = APL_NULL_STRING;
        	char l_str_narrative[41]= APL_NULL_STRING;
        	char l_str_addinfo[31]=APL_NULL_STRING;
			char l_str_subfun_val[4] = APL_NULL_STRING;
			char chr_l_sys_date_time[APL_DATE_LEN]=APL_NULL_STRING;
			char l_str_agentcode[11]=APL_NULL_STRING;
        	EXEC SQL BEGIN DECLARE SECTION;
        	EXEC SQL VAR l_str_funcdesc IS STRING;
			EXEC SQL VAR l_str_agentcode IS STRING;
        	struct sqlca sqlca;
        	EXEC SQL END DECLARE SECTION;


        	APL_IF_DEBUG
			{
				printf("Entered Function Get_misinfo \n");
        	}
			memset(l_str_misinfo,APL_NULL_CHAR,4001);
        	l_message_list = p_msg_list;
         strcpy(l_str_msg_name , p_msg_name);
        	if((GetParamString(l_message_list,l_str_misinfo,p_mis_msg_name,l_debug_info_ptr)) == APL_FAILURE)
                APL_GOBACK_FAIL
			
			if (strlen(l_str_misinfo)==0)
			{
				DEFORMAT_IF_DEBUG
				{
					printf("No data in dfparammap for MIS548\n");
				}
				SYS_RETURN_NO_DATA_FOUND			
			}
			

			sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"SERVER_NAME",DATA_VALUE_SEPRTR,"DEFORMATER");
        	strcat(l_str_misinfo,chr_l_str_temp);

			
			
        	
			sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"MSG_NAME",DATA_VALUE_SEPRTR,l_str_msg_name);
        	strcat(l_str_misinfo,chr_l_str_temp);

        	APL_IF_DEBUG
			{
				printf("MISINFO IS == %s \n", l_str_misinfo);
			}
        	

        	
			if( CO_RtvSysDtTime(chr_l_sys_date_time,l_debug_info_ptr) == APL_FAILURE)
			{
				APL_IF_DEBUG
				{
					printf("l_str_date_time =%s \n",chr_l_sys_date_time);
				}
			}
        	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"COMMON_DT",DATA_VALUE_SEPRTR,chr_l_sys_date_time);
        	strcat(l_str_misinfo,chr_l_str_temp);
			

        EXEC SQL SELECT FUNCTION_NAME INTO :l_str_funcdesc FROM dfenvmap WHERE FUNCTION_MODE = :p_str_funcmode ;
        IS_ANY_ORA_ERROR
			if(sqlca.sqlcode == 1403)
                SYS_RETURN_NO_DATA_FOUND
			APL_IF_DEBUG
			{
 	      	 printf("funcdesc = %s %d \n ",l_str_funcdesc,sqlca.sqlcode);
        	}
			sprintf(chr_l_str_temp , "%c%s%c%s",DATA_FIELD_SEPRTR,"TASK_DESC",DATA_VALUE_SEPRTR,l_str_funcdesc);
        	strcat(l_str_misinfo,chr_l_str_temp);

         strcpy(chr_l_str_temp , APL_NULL_STRING);
       	memset(chr_l_str_temp,APL_NULL_CHAR,400);
        	
			APL_IF_DEBUG
			{
				printf("misinfo 1 = %s \n ",l_str_misinfo);
        	}
			
			sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"MSG_FUNC",DATA_VALUE_SEPRTR,l_str_funcdesc);
        	
			APL_IF_DEBUG
			{
				printf(" 2nd time |%s| \n",chr_l_str_temp);
        		printf("length of temp = %d \n",(int)strlen(chr_l_str_temp));  //AIX-Warnings Removal
        	}
			strcat(l_str_misinfo,chr_l_str_temp);


        	
        	
        	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"NAMEOF_FILE",DATA_VALUE_SEPRTR,strrchr(chr_p_filename,'/')+1);
        	strcat(l_str_misinfo,chr_l_str_temp);
        	APL_IF_DEBUG
			{
				printf("misinfo  = %s \n ",l_str_misinfo);
			}
        	memset(chr_l_str_temp,APL_NULL_CHAR,400);

         /*	
        	if((GetDataFromHeader_Separator(l_message_list,4,' ', 1, l_rec_from_sent_to))== APL_FAILURE)
                        APL_GOBACK_FAIL

		  	if(strcmp(l_rec_from_sent_to ,APL_NULL_STRING)==0)
		  	{
		  		APL_IF_DEBUG
		  		{
					printf("ERROR :Agent contact_details not present in the msg \n");
				}
			}
			
			EXEC SQL SELECT AGENTCODE INTO :l_str_agentcode FROM CAGENT WHERE SWIFTADDR = :l_rec_from_sent_to;
			IS_ANY_ORA_ERROR

			APL_IF_DEBUG
			{
				printf("AGENTCODE is  ==%s== \n",l_str_agentcode);
			}
       	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"REC_FROM_SENT_TO",DATA_VALUE_SEPRTR,l_str_agentcode);
        	
			
			strcat(l_str_misinfo,chr_l_str_temp);
   		APL_IF_DEBUG
			{
				printf("misinfo = %s %d\n",l_str_misinfo,strlen(l_str_misinfo));
   		}
			memset(chr_l_str_temp,APL_NULL_CHAR,400);


        	
			if(GetSubFunFn(l_message_list,l_str_msg_name,l_str_subfun_val)==APL_FAILURE)
				APL_GOBACK_FAIL
	
			sprintf(chr_l_str_temp,"%c%s%c",DATA_FIELD_SEPRTR,"SUBPROCESS",DATA_VALUE_SEPRTR,l_str_subfun_val);
        	strcat(l_str_misinfo,chr_l_str_temp);
   		APL_IF_DEBUG
			{
				printf("misinfo = %s %d\n",l_str_misinfo,strlen(l_str_misinfo));
   		}
			memset(chr_l_str_temp,APL_NULL_CHAR,400);
			
			*/

        	
			
			if((strcmp(p_msg_name,"540N01")==0) ||
					(strcmp(p_msg_name,"541N01")==0) ||
					(strcmp(p_msg_name,"542N01")==0) ||
					(strcmp(p_msg_name,"543N01")==0))
			{
				strcpy(l_str_msgfunc_code,"T01");
				
			}
			
			
			
   		if((strcmp(p_msg_name,"540C01")==0) ||
      		(strcmp(p_msg_name,"541C01")==0) ||
      		(strcmp(p_msg_name,"542C01")==0) ||
      		(strcmp(p_msg_name,"543C01")==0))
   		{
      		strcpy(l_str_msgfunc_code,"T02");
   		}
   		

			if((strcmp(l_str_msg_name,"544N01")==0) || (strcmp(l_str_msg_name,"545N01")==0) || (strcmp(l_str_msg_name,"546N01")==0) || (strcmp(l_str_msg_name,"547N01")==0))
         strcpy(l_str_msgfunc_code,"T03");


			if((strcmp(l_str_msg_name,"544R01")==0) || (strcmp(l_str_msg_name,"545R01")==0) || (strcmp(l_str_msg_name,"546R01")==0) || (strcmp(l_str_msg_name,"547R01")==0))
  			strcpy(l_str_msgfunc_code,"T04");

  			if(strcmp(l_str_msg_name,"548N04")==0)
 			strcpy(l_str_msgfunc_code,"T05");

  			if(strcmp(l_str_msg_name,"548R04")==0)
			strcpy(l_str_msgfunc_code,"T06");

  			if(strcmp(l_str_msg_name,"548N03")==0)
   		strcpy(l_str_msgfunc_code,"T07");

  			if(strcmp(l_str_msg_name,"548R03")==0)
   		strcpy(l_str_msgfunc_code,"T08");

  			if(strcmp(l_str_msg_name,"548N05")==0)
			strcpy(l_str_msgfunc_code,"T09");

  			if(strcmp(l_str_msg_name,"548N06")==0)
  	 		strcpy(l_str_msgfunc_code,"T10");

   		
   		if(strcmp(p_msg_name,"578N01")==0)
      	strcpy(l_str_msgfunc_code,"T12");
			

   		if(strcmp(p_msg_name,"535N01")==0)
      	strcpy(l_str_msgfunc_code,"T13");

   		if(strcmp(p_msg_name,"536N01")==0)
      	strcpy(l_str_msgfunc_code,"T14");

   		if(strcmp(p_msg_name,"537N01")==0)
      	strcpy(l_str_msgfunc_code,"T15");

  			sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"MSGFUNC_CODE",DATA_VALUE_SEPRTR,l_str_msgfunc_code);
 			APL_IF_DEBUG
			{
				printf("TEMP == %s i%d\n",chr_l_str_temp,(int)strlen(chr_l_str_temp));  //AIX-Warnings Removal
  			}
			strcat(l_str_misinfo,chr_l_str_temp);
         memset(chr_l_str_temp,APL_NULL_CHAR,400);
			APL_IF_DEBUG
			{
        		printf("misinfo = %s \n Length of misinfo = %d temp ==%s\n",l_str_misinfo,(int)strlen(l_str_misinfo),chr_l_str_temp);//AIX Warning Removal
			}
         
        	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"PSETPARTY",DATA_VALUE_SEPRTR,l_str_pset);
        	strcat(l_str_misinfo,chr_l_str_temp);
        	memset(chr_l_str_temp,APL_NULL_CHAR,400);
			
        	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"PLACE_CD",DATA_VALUE_SEPRTR,l_str_place_code);
        	strcat(l_str_misinfo,chr_l_str_temp);
        	memset(chr_l_str_temp,APL_NULL_CHAR,400);

        	
        	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"DETAIL",DATA_VALUE_SEPRTR,l_str_narrative);
        	strcat(l_str_misinfo,chr_l_str_temp);
        	memset(chr_l_str_temp,APL_NULL_CHAR,400);

        	
        	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"INFORMATION",DATA_VALUE_SEPRTR,l_str_addinfo);
        	strcat(l_str_misinfo,chr_l_str_temp);
        	memset(chr_l_str_temp,APL_NULL_CHAR,400);

        	
        	sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"PROC_USR",DATA_VALUE_SEPRTR,"GCSYSTEM");
        	strcat(l_str_misinfo,chr_l_str_temp);
        	memset(chr_l_str_temp,APL_NULL_CHAR,400);

				
			
        	if( strcmp(l_str_msg_name ,"564N01")!= 0)
        	{
                sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"EVENT_TYPE",DATA_VALUE_SEPRTR,"");
                strcat(l_str_misinfo,chr_l_str_temp);
        			 memset(chr_l_str_temp,APL_NULL_CHAR,400);
        
			}

			
			if((strcmp(p_msg_name,"540N01")==0) ||
				(strcmp(p_msg_name,"541N01")==0) ||
				(strcmp(p_msg_name,"542N01")==0) ||
				(strcmp(p_msg_name,"543N01")==0))
			{
					sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"TRAIL_FOR",DATA_VALUE_SEPRTR,"T");
               strcat(l_str_misinfo,chr_l_str_temp);
        			memset(chr_l_str_temp,APL_NULL_CHAR,400);
					 
               sprintf(chr_l_str_temp,"%c%s%c%s",DATA_FIELD_SEPRTR,"DEAL_FRM_ORD",DATA_VALUE_SEPRTR,"N");
               strcat(l_str_misinfo,chr_l_str_temp);
        			memset(chr_l_str_temp,APL_NULL_CHAR,400);
       			
			}
	
	APL_IF_DEBUG
	{
		//printf("LAST misinfo = %s \n Length of misinfo = %d temp ==%s\n",l_str_misinfo,strlen(l_str_misinfo),chr_l_str_temp); Changes done for AIX Migration
		printf("LAST misinfo = %s \n Length of misinfo = %d temp ==%s\n",l_str_misinfo,(int)strlen(l_str_misinfo),chr_l_str_temp);
	}


  	strcpy(p_str_misinfo,l_str_misinfo);
	APL_IF_DEBUG
	{
		//printf("LASTp_str misinfo = %s \n Length of misinfo = %d temp ==%s\n",p_str_misinfo,strlen(p_str_misinfo),chr_l_str_temp); Changes done for AIX Migration
		printf("LASTp_str misinfo = %s \n Length of misinfo = %d temp ==%s\n",p_str_misinfo,(int)strlen(p_str_misinfo),chr_l_str_temp);
	}

APL_GOBACK_SUCCESS // AIX - Warnings

	RETURN_SUCCESS:
	{
                CO_ProcMonitor(APL_OUT_FILE, "Exiting Out Of  get_misinfo successfully\n", NULL, NULL);

                 return(APL_SUCCESS);
   }

	RETURN_FAILURE:
   {
                CO_ProcMonitor(APL_OUT_FILE, "Exiting Out Of get_misinfo unsuccessfully\n", NULL, NULL);
                 return(APL_FAILURE);
   }

	LBL_EXIT_NO_DATA:
	{
        return(SYS_NO_DATA);

   }

}


int GetSubFunFn(MESSAGE_STRUCT **p_message_list,char *p_str_msg_name, char *p_str_val)
{
	MESSAGE_STRUCT		**l_message_list			= p_message_list;
	char					l_str_resetval[4]			= APL_NULL_STRING;
	char					l_str_msg_name[4]			= APL_NULL_STRING;
   
	DEFORMAT_IF_DEBUG
   {
		CO_ProcMonitor(APL_OUT_FILE, "\n Entered processtion GetSubFunFn  \n",NULL,NULL);
	}

	strcpy(l_str_msg_name,p_str_msg_name);

	if((strcmp(l_str_msg_name,"544N01")==0) || (strcmp(l_str_msg_name,"544R01")==0) || (strcmp(l_str_msg_name,"546N01")==0) || (strcmp(l_str_msg_name,"546R01")==0))
	{		
		strcpy(p_str_val,"31");
	}
	if((strcmp(l_str_msg_name,"545N01")==0) || (strcmp(l_str_msg_name,"545R01")==0) || (strcmp(l_str_msg_name,"547N01")==0) || (strcmp(l_str_msg_name,"547R01")==0))
	{
		if(I_GetVal(p_message_list,":22H:",":PREC/",l_str_resetval,"A","1") == APL_SUCCESS)
		{
			if(strcmp(l_str_resetval,"PRCA")==0)
  				strcpy(p_str_val,"32");
			if(strcmp(l_str_resetval,"PRSE")==0)
				strcpy(p_str_val,"31");
		}
      else
      {
			if(strcmp(l_str_resetval,APL_NULL_STRING)==0)
				strcpy(p_str_val,"33");
		}
	}
	if(strcmp(l_str_msg_name,"548N03")== 0)
	{
		strcpy(p_str_val,"41");
	}
	APL_GOBACK_SUCCESS

/* AIX - Warnings
	RETURN_FAILURE :
	{
		DEFORMAT_IF_DEBUG 
			CO_ProcMonitor(APL_OUT_FILE, "\n Leaving processtion GetSubFunFn with errors \n",NULL,NULL);
		return(APL_FAILURE);
	}
*/
	RETURN_SUCCESS :
  	{
 		DEFORMAT_IF_DEBUG 
  			CO_ProcMonitor(APL_OUT_FILE, "\n Leaving processtion GetSubFunFn successfully \n",NULL,NULL);
	  	return(APL_SUCCESS);
	}

}



int I_LocateVal(MESSAGE_STRUCT  **p_message_list, char*  msg_tag, char*  qual,char*  int_val, char*  sequence)
{
	int  int_l_int_retval  = 0;
	char l_parent_block[3]  = APL_NULL_STRING;
	char l_child_block[3]   = APL_NULL_STRING;

	DEFORMAT_IF_DEBUG
	{
		printf("\n Entering Function I_LocateVal\n");
	}


	for (int_l_int_retval=1; int_l_int_retval<MAXBLOCK; int_l_int_retval++)
	{
		strcpy(l_parent_block,"1,");
		sprintf(l_child_block,"%d",int_l_int_retval);
		strcat(l_parent_block,l_child_block);
		if (I_GetVal(p_message_list, msg_tag, qual, int_val, sequence, l_parent_block))
			return APL_SUCCESS;
	}
	return APL_FAILURE;
}

	

int DFparse_error(char * p_err_desc, MESSAGE_STRUCT **p_msg_list,char *chr_p_filename, char *p_message_name,DEBUG_INFO_STRUCT_H **l_debug_info_ptr )
{
   char **l_arr_str_reasons	=	(char **)NULL ;
   char **l_arr_str_fields		=	(char **)NULL;
   char *l_str_failreason 		= "From Deformater: ";
   int l_int_numreasons		=	0;
   int l_int_numfields		=	0;
   int l_int_loopcount		=	0;

   printf("\nENTERED FUCTION PARSE_ERRORi  %s\n",p_err_desc);
   if (APL_FAILURE == CO_SplitStr( p_err_desc, '#', &l_int_numreasons, &l_arr_str_reasons ))
   {
     		APL_IF_DEBUG
			{	
		 	   for (l_int_loopcount=0;l_int_loopcount<l_int_numreasons;l_int_loopcount++)
            {
                 //AIX-Warnings Removal
               printf("inside lreason SPLIT count|%d| length|%d|\n", l_int_loopcount,(int)strlen(l_arr_str_reasons[l_int_loopcount]));
            }
	
      	}
			if(l_arr_str_reasons == (char **)NULL)
      	{
         	CO_ProcMonitor(APL_OUT_FILE, "Failure from StrSplitFn: NO ERROR DES CRIPTION", NULL, NULL);
      	}
   }
   APL_IF_DEBUG
	{
		for (l_int_loopcount=0;l_int_loopcount<l_int_numreasons;l_int_loopcount++)
      {
         //printf("Number of Errors from Trade Server is|%d| |%s| length|%d|\n", l_int_loopcount,l_arr_str_reasons[l_int_loopcount],strlen(l_arr_str_reasons[l_int_loopcount])); Changes done for AIX Migration
         printf("Number of Errors from Trade Server is|%d| |%s| length|%d|\n", l_int_loopcount,l_arr_str_reasons[l_int_loopcount],(int)strlen(l_arr_str_reasons[l_int_loopcount]));
      }
  	} 
	for(l_int_loopcount=0;l_int_loopcount<l_int_numreasons;l_int_loopcount++)
   {
		APL_IF_DEBUG
		{
      	printf("inside for loop loopcount= %d\n",l_int_loopcount);
      }
		if (APL_FAILURE == CO_SplitStr( l_arr_str_reasons[l_int_loopcount  ], '|', &l_int_numfields, &l_arr_str_fields )) 
		{
      		APL_IF_DEBUG
				{	
					for (l_int_loopcount=0;l_int_loopcount<l_int_numfields;l_int_loopcount++)
      			{
         			//printf("Number of Errors from Trade Server is|%d| |%s| length|%d|\n", l_int_loopcount,l_arr_str_fields[l_int_loopcount],strlen(l_arr_str_fields[l_int_loopcount])); Changes done for AIX Migration
         			printf("Number of Errors from Trade Server is|%d| |%s| length|%d|\n", l_int_loopcount,l_arr_str_fields[l_int_loopcount],(int)strlen(l_arr_str_fields[l_int_loopcount]));
      			}

           	} 
				if(l_arr_str_fields == (char **)NULL)
            {
					 CO_ProcMonitor(APL_OUT_FILE, "Failure from StrSplitFni: NO ERROR FIELDS", NULL, NULL); 
			 	}
      }
		APL_IF_DEBUG
		{
     		printf("*******%d \n",l_int_numfields);
     		printf("%s %s %d\n",l_arr_str_fields[3],l_arr_str_fields[2],l_int_numfields);
		}
     	strcat(l_str_failreason , l_arr_str_fields[l_int_numfields -1]);
     	APL_IF_DEBUG
		{
			printf("%s \n",l_str_failreason);
		}
     	
     	if((InsComm_MsgRptFn(p_msg_list,p_message_name,l_str_failreason,"RJT",chr_p_filename,l_debug_info_ptr)) == APL_FAILURE)
      				APL_GOBACK_FAIL
   }
   APL_GOBACK_SUCCESS

	RETURN_SUCCESS:
         {
                 CO_ProcMonitor(APL_OUT_FILE, "Exiting Out Of  DFparse_error successfully\n", NULL, NULL);
                 return(APL_SUCCESS);
         }

	RETURN_FAILURE:
        {
                 CO_ProcMonitor(APL_OUT_FILE, "Exiting Out Of DFparse_error unsuccessfully\n", NULL, NULL);
                 return(APL_FAILURE);
         }
}
 
/* function for validation of messages */
int DoValidateFn(char *p_str_msg_name, MESSAGE_STRUCT **p_msg_list,FILE *fl_log,char *p_str_msg_filename,char *p_str_status,DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
 
 
 	int				l_int_rejcntr					=	0;
 	int				l_int_repcntr					=	0;
 	int				l_int_rejflg					=	0;
 	int				l_int_repflg					=	0;
 	int				l_int_cnt						=	0;
 	int				l_int_var						=	0;
 	FILE				*fl								= 	(FILE *)NULL;
 	char				l_str_msg_no[4]				=	APL_NULL_STRING;
 	char				l_str_msg_name[7]				=	APL_NULL_STRING;
 	char				l_str_isin[13]					=	APL_NULL_STRING;
 	char				l_str_country_code[3]		=	APL_NULL_STRING;
 	char				*l_str_paramstring;
 	char				*l_str_seme;
 	char				*l_str_part1;
 	char 				*l_str_msgval;

   char l_msg_name[7] = APL_NULL_STRING; /* ASHISH 16-05-2008 */ 
 
 	MESSAGE_STRUCT **l_msg_list;
 	DEBUG_INFO_STRUCT_H **l_debuginfo;
 	H_DSPARAMMAP_STRUCT			*dsparammap_struct		=	NULL;
 	DFVALIDATEMAP_STRUCT_H		*h_dfvalidatemap_struct	=	NULL;
 	DFVALIDATEMAP_STRUCT_I		*i_dfvalidatemap_struct	=	NULL;
 	DF_COMMON_MSGRPT_STRUCT_H	*h_commmsgrept_struct	=	NULL;
 	DF_COMMON_MSGRPT_STRUCT_I	*i_commmsgrept_struct	=	NULL;
 	PRO_GSEQNUM_STRUCT_H			*l_progseqnum_struct_h				=	NULL;
		int calloc_size = 1;
 	struct sqlca sqlca;
 
 	APL_IF_DEBUG
 	{
 		CO_ProcMonitor(APL_OUT_FILE, "\n Entered processtion DoValidatFn \n",NULL, NULL);
 	}
 
 	l_str_paramstring = (char*)calloc(1,(sizeof(char *)));
 	l_str_part1= (char*)calloc(1,(sizeof(char *)));
 	l_str_msgval = (char *)calloc(1,(sizeof(char *)));
 	l_str_seme= (char *)calloc(1,(sizeof(char *)));
 
 	l_msg_list = p_msg_list;
 	l_debuginfo = l_debug_info_ptr;
 	strcpy(l_str_msg_name,p_str_msg_name);
 
 
 
 	dsparammap_struct = (H_DSPARAMMAP_STRUCT *)calloc(calloc_size,sizeof(H_DSPARAMMAP_STRUCT));
 	APL_MALLOC_FAIL(dsparammap_struct);
 	h_dfvalidatemap_struct = (DFVALIDATEMAP_STRUCT_H *)calloc(calloc_size,sizeof(DFVALIDATEMAP_STRUCT_H));
 	APL_MALLOC_FAIL(h_dfvalidatemap_struct); /* JC - Changed structure name */
 	i_dfvalidatemap_struct = (DFVALIDATEMAP_STRUCT_I *)calloc(calloc_size,sizeof(DFVALIDATEMAP_STRUCT_I));
 	APL_MALLOC_FAIL(i_dfvalidatemap_struct); /* JC - Changed structure name */
 	h_commmsgrept_struct = (DF_COMMON_MSGRPT_STRUCT_H *)calloc(calloc_size,sizeof(DF_COMMON_MSGRPT_STRUCT_H));
 	APL_MALLOC_FAIL(h_commmsgrept_struct); /* JC - Changed structure name */
 	i_commmsgrept_struct = (DF_COMMON_MSGRPT_STRUCT_I *)calloc(calloc_size,sizeof(DF_COMMON_MSGRPT_STRUCT_I));
 	APL_MALLOC_FAIL(i_commmsgrept_struct); /* JC - Changed structure name */
 
 	EXEC SQL BEGIN DECLARE SECTION;
 
 	EXEC SQL VAR h_dfvalidatemap_struct->h_msg_name is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_field_name is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_typeofvldt is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_reqd is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_field_type is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_msg_tag is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->chr_h_qualifier is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_sequence is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_val_type is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_static_val is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_block_no is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_repeat is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_failreas is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_query is STRING;
 	EXEC SQL VAR h_dfvalidatemap_struct->h_nation_code is STRING;
 	EXEC SQL VAR l_str_country_code is STRING;
 
 
 
 	EXEC SQL VAR l_str_msg_name is STRING;
 
 	EXEC SQL END DECLARE SECTION;
 
 	/* l_str_msg_no[3]='\0'; Commented by JC since it is not used anywhere */
 
	
 	/*
 	if(I_GetVal(p_msg_list,":35B:","SEC_ISIN",l_str_isin,"B","1") == APL_FAILURE)
 		APL_GOBACK_FAIL
 
 
 	EXEC SQL SELECT CNTRYCODE INTO :l_str_country_code FROM MT_INSTRUMENT WHERE ISIN = :l_str_isin;
 
 	IS_ANY_ORA_ERROR
 	if(sqlca.sqlcode != 0)
 	{
 		strcpy(p_str_status,"RJT");
 	
 		if(InsComm_MsgRptFn(l_msg_list,l_str_msg_name,"INVALID ISIN",p_str_status,p_str_msg_filename,l_debug_info_ptr) == APL_FAILURE)
 		{
 			CO_ProcMonitor(fl_log,"ERROR INSERTING IN DF_COMMON_MSGRPT \n",l_debug_info_ptr,NULL);
 						APL_GOBACK_FAIL
 		}
 		APL_GOBACK_SUCCESS
 	}
 	*/

  /* ASHISH 16-05-2008 Start */ 
   strcpy(l_msg_name,l_str_msg_name);
		sqlca.sqlcode = 0; 
 	EXEC SQL DECLARE VALIDATEMAP_CUR CURSOR FOR
 	SELECT *
 	FROM DFVALIDATEMAP
 	WHERE MSG_NAME= :l_msg_name AND REQD='Y' AND COUNTRY_CODE= 'XX' ORDER BY TYPEOFVLDT;
   
   Alert("\n Sql Error to declare cursor VALIDATEMAP_CUR = |%d| \n",sqlca.sqlcode);
 	IS_ANY_ORA_ERROR
  /* ASHISH 16-05-2008 End */ 
 
 
		sqlca.sqlcode = 0; 
 	EXEC SQL OPEN VALIDATEMAP_CUR;
 	l_int_var=0;
 	for(;;)
 	{
 
			sqlca.sqlcode = 0; 
 		EXEC SQL FETCH VALIDATEMAP_CUR 
 		INTO :h_dfvalidatemap_struct:i_dfvalidatemap_struct;
 	
 
 		if((sqlca.sqlcode == 1403) && (l_int_var == 0))
 			SYS_RETURN_NO_DATA_FOUND
 
 		APL_IF_DEBUG
 		{
 			Alert("\n Entered cursor FOR LOOP\n");
 			Alert("\n The chr_value of l_int_rejflg is %d and l_int_rejcntr is %d \n",l_int_rejflg,l_int_rejcntr);
 		}
 
 		if(sqlca.sqlcode ==1403)
 			break;
 
 
 
 		if(l_int_rejcntr != 0)
 		{
 			if(strcmp(h_dfvalidatemap_struct->h_typeofvldt,"RPR")==0)
 			{
 				strcpy(p_str_status,"RJT");
 					break;
 			}
 		}
 
 
 
 		strcpy(dsparammap_struct->h_msg_name,h_dfvalidatemap_struct->h_msg_name);
 		strcpy(dsparammap_struct->chr_h_val,"Y");
 		strcpy(dsparammap_struct->h_field_type,h_dfvalidatemap_struct->h_field_type);
 		strcpy(dsparammap_struct->h_label,h_dfvalidatemap_struct->h_field_name);
 		strcpy(dsparammap_struct->h_msg_tag,h_dfvalidatemap_struct->h_msg_tag);
 		strcpy(dsparammap_struct->chr_h_qualifier,h_dfvalidatemap_struct->chr_h_qualifier);
 		strcpy(dsparammap_struct->h_sequence,h_dfvalidatemap_struct->h_sequence);
 		strcpy(dsparammap_struct->h_static_val,h_dfvalidatemap_struct->h_static_val);
 		strcpy(dsparammap_struct->h_val_type,h_dfvalidatemap_struct->h_val_type);
 		strcpy(dsparammap_struct->h_block_no, h_dfvalidatemap_struct->h_block_no);
 		dsparammap_struct->h_srl_num = 0;
 		strcpy(dsparammap_struct->h_query, h_dfvalidatemap_struct->h_query);
 
 
 		APL_IF_DEBUG
 		{
 			Alert("\n CALLING FORMPARAMSTRING FUNCTION \n");
 		}
 
 		if(FormParamString(l_msg_list,l_str_paramstring,l_str_msg_name,dsparammap_struct,l_debug_info_ptr) == APL_FAILURE)
 			APL_GOBACK_FAIL
 		
 		APL_IF_DEBUG
 		{
 			Alert("\n RETURNED FROM FORMPARAMSTRING FUNCTION AND THE VALUE IS %s \n",l_str_paramstring);
 		}
 
 
 		strcpy(l_str_part1, l_str_paramstring + strlen(dsparammap_struct->h_label) + 2);
 		strncpy(l_str_msgval,l_str_part1,strlen(l_str_part1));
 		l_str_msgval[strlen(l_str_part1)]='\0';
 		l_str_msgval[strlen(l_str_part1)]='\0';
 		APL_IF_DEBUG
 		{
 			Alert("\n The resultant data1 ************** %s \n",l_str_msgval);
 		}
 
 
 
 		strcpy(l_str_paramstring,APL_NULL_STRING);
 
 		if(!strcmp(l_str_msgval,"Y")==0)
 		{
 		
 			if(strcmp(h_dfvalidatemap_struct->h_typeofvldt,"RPR")==0)
 			{
 				l_int_repcntr=l_int_repcntr+1;
 				l_int_repflg=1;
 				strcpy(p_str_status,"RPR");
 
 				APL_IF_DEBUG
 				{
 					Alert("\n GONE FOR REPAIR \n");
 				}
 			}
 
 			else
 			{
 				l_int_rejcntr=l_int_rejcntr+1;
 				l_int_rejflg=1;
 				strcpy(p_str_status,"RJT");
 
 				APL_IF_DEBUG
 				{
 					Alert("\n GONE FOR REJECT \n");
 				}
 			}
 
 			if(InsComm_MsgRptFn(l_msg_list,h_dfvalidatemap_struct->h_msg_name,h_dfvalidatemap_struct->h_failreas,p_str_status,p_str_msg_filename,l_debug_info_ptr) == APL_FAILURE)
 			{
 				CO_ProcMonitor(fl_log,"ERROR INSERTING IN DF_COMMON_MSGRPT \n",l_debug_info_ptr,NULL);
 					APL_GOBACK_FAIL
 			}
 		}
 
 		l_int_var = l_int_var + 1;
 	}
 
 	EXEC SQL CLOSE VALIDATEMAP_CUR;
 
 	if(( l_int_rejflg == 0) && (l_int_repflg == 0 ))
 	{
 		strcpy(p_str_status,"STP");
 	}	
 
 	APL_GOBACK_SUCCESS
 
 	LBL_EXIT_NO_DATA:
 	EXEC SQL CLOSE VALIDATEMAP_CUR;
 	return SYS_NO_DATA;
 
	RETURN_SUCCESS:
	{
 /*		free(dsparammap_struct);
 		free(h_dfvalidatemap_struct);
 		free(h_commmsgrept_struct);
 		free(i_commmsgrept_struct);
 		free(i_dfvalidatemap_struct);
	 	free(l_str_paramstring);
	 	free(l_str_part1);
	 	free(l_str_msgval);
	 	free(l_str_seme);
		free(l_str_paramstring);
		free(l_str_part1);
		free(l_str_msgval);
		free(l_str_seme);*/
 		APL_IF_DEBUG
 		{
 			Alert("Leaving Function dovalidate with success and the STATUS is %s\n",p_str_status);
 		}
 		return(APL_SUCCESS);
 
 	}
 
 
	RETURN_FAILURE:
	{
 /*		free(dsparammap_struct);
 		free(h_dfvalidatemap_struct);
 		free(h_commmsgrept_struct);
 		free(i_commmsgrept_struct);
 		free(i_dfvalidatemap_struct);
	 	free(l_str_paramstring);
	 	free(l_str_part1);
	 	free(l_str_msgval);
	 	free(l_str_seme);
		free(l_str_paramstring);
		free(l_str_part1);
		free(l_str_msgval);
		free(l_str_seme);*/
 		APL_IF_DEBUG
 		{
 			printf("Leaving Function dovalidate with failure");
 		}
 		return(APL_FAILURE);
 	}

}

int ReplaceDoubleSlash ( char *ds_string)
{

   char a[11]="";
   char ds_first_part[11]="";
   char ds_second_part[11]="";
   char ds_replaced_string[11]="";


   strcpy(a,ds_string);

   printf("\n original a is |%s|\n", a);

   strcpy(ds_second_part,strstr(a,"//")+2);
 strcat(ds_second_part,"\0");

   printf("\n second part is |%s|\n", ds_second_part);

   strncpy(ds_first_part,a,strlen(a)-strlen(ds_second_part)-2);
 strcat(ds_first_part,"\0");

   printf("\n ds_first part is |%s|\n", ds_first_part);

   strcpy(ds_replaced_string,ds_first_part);
   strcat(ds_replaced_string,"/");
   strcat(ds_replaced_string,ds_second_part);

   printf("\n ds_replaced string is |%s|\n", ds_replaced_string);

   strcpy(ds_string , ds_replaced_string);

   return 1;

}

