/*
 *    COPYRIGHT NOTICE
 *
 *   Copyright 2005 Polaris Software Lab Limited. All rights reserved.
 *
 *   These materials are confidential and proprietary to
 *    Polaris Software Lab Limited and no part of these materials should
 *    be reproduced, published, transmitted or distributed in any form or
 *    by any means, electronic, mechanical, photocopying, recording or
 *    otherwise, or stored in any information storage or retrieval system
 *    of any nature nor should the materials be disclosed to third parties
 *    or used in any other manner for which this is not authorized, without
 *    the prior express written authorization of Polaris Software Lab Limited.
 */
/*********************************************************************
 *
 * Module Name         : Utility
 *
 * File Name           : GF_Upload.pc
 *
 * Description         : Main file for Generic File Upload processing.
 *
 *
 *
 *            Version Control Block
 *
 * Date        Version          Author               Description
 * ---------   --------  ---------------  ---------------------------
 * 07/12/2005  1.0		 Biju George		Generic File Upload Main 
 *											          Functions
 * 29/03/2006  1.1       Amol Kulkarni    Functions Added
 * 15/06/2009  1.1         Naren V              Program is modified
 *                                              to get the DB login
 *                                              details in preceden
 *                                              ce order first from
 *                                              config file, and if
 *                                              unavailable,   then
 *                                              a  decrypted  value
 *                                              from  an  encrypted
 *                                              file by calling the
 *                                              remote application.
 * 30/03/2022 1.2         kotubabu       Linux Migaration  Kotak Implementaion
 *********************************************************************/
 

#include "stdio_64.h"
#include <unistd.h>
/*** AIX Migration Changes -START*/
#if !defined(_AIXVERSION_430) || !defined(_AIXVERSION_431) || !defined(_AIXVERSION_434) || !defined(_AIXVERSION_510) || !defined(_AIXVERSION_520) || !defined(_AIXVERSION_530) || !defined(_AIXVERSION_610)
     #ifdef OS_LINUX   /* Added by kotubabu for Linux Migration*/
       #include <bits/signum.h>
     #else
       #include <sys/iso/signal_iso.h>
     #endif
//#include <sys/iso/signal_iso.h>
#endif
/*** AIX Migration Changes -END*/
#include <sys/wait.h>
#include <ctype.h>
#include <WI_GF_Common.h>
#include <BT_Common.h>
EXEC SQL INCLUDE SQLCA.H;
#define MAIN_ARG \
{\
	int i =0;\
	for(i = 0;i<argc;i++)\
	{\
		printf("Arguement\t[%d]\t=\t[%s]\n",i,argv[i]);\
	}\
}
#define MICRO_SECONDS 110000



/********** Web Custody Single Login Changes : Vinay Kalaskar *********/

char g_custody_web_ind[2];
#define WEB_INDICATOR  "W"

/**********************************************************************/
#ifdef OS_LINUX   /* Added by kotubabu for Linux Migration-Start*/
FILE *l_logfile = NULL;
FILE *l_skipped_file= NULL;
FILE *l_userfile= NULL;
FILE *l_format_file = NULL;
FILE *l_bk_file = NULL;
#else
FILE *l_logfile = APL_OUT_FILE;
FILE *l_skipped_file= APL_OUT_FILE;
FILE *l_userfile= APL_OUT_FILE;
FILE *l_format_file = APL_OUT_FILE;
FILE *l_bk_file = APL_OUT_FILE;
#endif
 /* Added by kotubabu for Linux Migration-End*/
char g_file_name[GFU_FILE_NAME_LEN];
char g_param_data[2000];
char g_sys_date[APL_DATE_LEN];
char g_line[GFU_LINE_LEN] = APL_NULL_STRING;
GFU_FILE_MAP_STRUCT_H *g_gfu_file_map_h = (GFU_FILE_MAP_STRUCT_H *)NULL;

int Rtv_C_E_T(char *p_file_type,
					char *p_refno,
					C_E_T_STRUCT_H **p_c_e_t_struct_h,
					DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;
	char l_label[500];
	char l_seq[500];
	short i_label,i_seq;
	int l_start_pos = 0, l_end_pos = 0;
	C_E_T_STRUCT_H **l_temp_ptr = p_c_e_t_struct_h;

	APL_FUNCTION_ENTER(l_logfile)
		sqlca.sqlcode=0;
	if(!strcmp(p_file_type,CSV))
	{
		/**printf(" p_refno is %s\n",p_refno);**/
		EXEC SQL DECLARE l_rtv_csv_cur CURSOR
				FOR
				SELECT CSV_FIELD_NAME, CSV_REFERENCE_VALUE
				FROM MT_GFU_CSV_SETUP
				WHERE	REF_NO = :p_refno
				AND STATUS = 'AA';
		/**printf("\n\nError Code%d",sqlca.sqlcode);**/
		IS_ANY_ORA_ERROR
		EXEC SQL OPEN l_rtv_csv_cur;
		IS_ANY_ORA_ERROR

	}
	else if(!strcmp(p_file_type,EXCEL))
	{
		EXEC SQL DECLARE l_rtv_exl_cur CURSOR
				FOR
				SELECT EXCEL_FIELD_NAME,
						EXCEL_REFERENCE_VALUE
				FROM mt_gfu_excel_setup
				WHERE REF_NO = :p_refno
				AND STATUS = 'AA';
		IS_ANY_ORA_ERROR
		EXEC SQL OPEN l_rtv_exl_cur;
		IS_ANY_ORA_ERROR
		

	}
	else if(!strcmp(p_file_type,TEXT))
	{
		EXEC SQL DECLARE l_rtv_txt_cur CURSOR
				FOR
				SELECT TXT_FIELD_NAME,
						NVL(START_POS,0),
						NVL(END_POS,0)
				FROM mt_gfu_txt_setup
				WHERE REF_NO = :p_refno
				AND STATUS = 'AA';
		IS_ANY_ORA_ERROR
		EXEC SQL OPEN l_rtv_txt_cur;
		IS_ANY_ORA_ERROR

	}

	for(;;)
	{
		memset(l_label,APL_NULL_CHAR,sizeof(l_label));
		memset(l_seq,APL_NULL_CHAR,sizeof(l_seq));
		i_label = 0; i_seq = 0; l_start_pos = 0; l_end_pos = 0;
		if(!strcmp(p_file_type,CSV))
		{
			EXEC SQL FETCH l_rtv_csv_cur
						INTO :l_label:i_label,
							  :l_seq:i_seq;
			IS_ANY_ORA_ERROR
		}	
		else if(!strcmp(p_file_type,EXCEL))
		{
			EXEC SQL FETCH l_rtv_exl_cur
						INTO :l_label:i_label,
							  :l_seq:i_seq;
			IS_ANY_ORA_ERROR
		}
		else if(!strcmp(p_file_type,TEXT))
		{
			EXEC SQL FETCH l_rtv_txt_cur
						INTO :l_label:i_label,
							  :l_start_pos,
							  :l_end_pos;
			IS_ANY_ORA_ERROR
		}
		/**printf("sqlca.sqlcode |%d|\n",sqlca.sqlcode);**/
		if(sqlca.sqlcode == 1403)break;

		while((*l_temp_ptr) != (C_E_T_STRUCT_H *)NULL)
		{
			l_temp_ptr = &((*l_temp_ptr)->h_next);
		}
		if(((*l_temp_ptr) = (C_E_T_STRUCT_H *)calloc(1,sizeof(C_E_T_STRUCT_H))) == NULL)
		{
			APL_GOBACK_FAIL
		}
		strcpy((*l_temp_ptr) -> h_label,l_label);
		strcpy((*l_temp_ptr) -> h_seq,l_seq);
		(*l_temp_ptr) -> h_start_pos	=	l_start_pos;
		(*l_temp_ptr) -> h_end_pos	=	l_end_pos;
		(*l_temp_ptr) -> h_next = NULL;

	}
		if(!strcmp(p_file_type,CSV))
		{
			EXEC SQL CLOSE l_rtv_csv_cur;

		}	
		else if(!strcmp(p_file_type,EXCEL))
		{
			EXEC SQL CLOSE l_rtv_exl_cur;
			IS_ANY_ORA_ERROR
		}
		else if(!strcmp(p_file_type,TEXT))
		{
			EXEC SQL CLOSE l_rtv_txt_cur;
			IS_ANY_ORA_ERROR
		}

APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}


int Add_Rpl_Format_Lst(char *p_file_type,
							 	GFU_FORMAT_MAP_STRUCT_LST **p_gfu_format_map_lst,
							 C_E_T_STRUCT_H **p_c_e_t_struct_h,
							 DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	C_E_T_STRUCT_H **l_temp_cet = p_c_e_t_struct_h ;
	GFU_FORMAT_MAP_STRUCT_LST **l_temp_format;

	APL_FUNCTION_ENTER(l_logfile)
	while(*l_temp_cet)
	{
		l_temp_format = p_gfu_format_map_lst;
		while(*l_temp_format)
		{
			if(!strcmp((*l_temp_format) -> h_label , (*l_temp_cet)->h_label))
			{
				strcpy((*l_temp_format) -> h_seq,(*l_temp_cet)->h_seq);
				strcpy((*l_temp_format) -> h_start,ltoa((*l_temp_cet)->h_start_pos));
				strcpy((*l_temp_format) -> h_end,ltoa((*l_temp_cet)->h_end_pos));
			}
			l_temp_format = &((*l_temp_format)->h_next);
		}
		l_temp_cet = &((*l_temp_cet)->h_next);
	}

APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)


}
int Process_C_E_T(	GFU_FORMAT_MAP_STRUCT_LST **p_gfu_format_map_lst,
							char *p_refno,
							char *p_module,
							char *p_vendor,
							DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;
	C_E_T_STRUCT_H **l_c_e_t_struct_h = (C_E_T_STRUCT_H **)NULL;
	C_E_T_STRUCT_H *l_c_e_t_struct_free = (C_E_T_STRUCT_H *)NULL;
	char l_file_type[4] = APL_NULL_STRING;

	l_c_e_t_struct_h = (C_E_T_STRUCT_H **) calloc(1,sizeof(C_E_T_STRUCT_H *));

	APL_FUNCTION_ENTER(l_logfile)
	/*Changes done by AMOL*/
/*
	EXEC SQL SELECT FILE_TYPE
				INTO :l_file_type
				FROM MT_GFU_FORMAT_SETUP
				WHERE	VENDOR_ID = :p_vendor
				AND  FUNCTION_ID	= :p_module
				AND STATUS = 'AA';
*/
/*	printf("\nBefore retriving file type ref_no=|%s|",p_refno);*/
	
	EXEC SQL SELECT FILE_TYPE INTO :l_file_type FROM  MT_GFU_FORMAT_SETUP WHERE REF_NO=:p_refno AND STATUS='AA';
	/**printf("\nSQL Code for File Type=%d",sqlca.sqlcode);**/
	IS_ANY_ORA_ERROR

	if(sqlca.sqlcode == 1403) APL_GOBACK_SUCCESS

	if(Rtv_C_E_T(	l_file_type,
					p_refno,
					l_c_e_t_struct_h,
					l_debug_info_ptr) == APL_FAILURE)
			{
				printf("\n\nError during Rtv_C_E_T function");
			APL_GOBACK_FAIL
			}
/*	printf("After Rtv_C_E_T function");*/
	if(Add_Rpl_Format_Lst(l_file_type,
							 p_gfu_format_map_lst,
							 l_c_e_t_struct_h,
							 l_debug_info_ptr) == APL_FAILURE)
	{
				printf("\n\nError during Add_Rpl_Format_Lst function");
	APL_GOBACK_FAIL
	}
							
							
APL_GOBACK_SUCCESS
RETURN_FAILURE:
	while(*l_c_e_t_struct_h)
	{
		l_c_e_t_struct_free = (*l_c_e_t_struct_h) -> h_next;
		APL_FREE((*l_c_e_t_struct_h))
		*l_c_e_t_struct_h = l_c_e_t_struct_free;
	}
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	while(*l_c_e_t_struct_h)
	{
		l_c_e_t_struct_free = (*l_c_e_t_struct_h) -> h_next;
		APL_FREE((*l_c_e_t_struct_h))
		*l_c_e_t_struct_h = l_c_e_t_struct_free;
	}
	APL_FUNCTION_RET_SUCCESS(l_logfile)


}
							


/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : Call_Stored_Proc																 *
 *                                                                                                       *
 * Description           : This Function is used for calling stored procedure for specific module.       *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_gfu_req_map_h                     GFU_REQ_MAP_STRUCT_H *           I      Containing Wrapper/SP name*
 *                                                                                                       *
 * p_env_data                          char *                           I      Environment String		 *
 *                                                                                                       *
 * p_param_data                        char *                           I      Parameter String			 *
 *                                                                                                       *
 * p_line_no                           int                              I      Line number of the record *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/

int Call_Stored_Proc(	GFU_REQ_MAP_STRUCT_H *p_gfu_req_map_h,
			char *p_env_data, 
			char *p_param_data,
			int p_line_no,
			DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;
	char l_error[GFU_ERR_DATA_LEN] = APL_NULL_STRING;
	char l_reason[GFU_ERR_DATA_LEN] = APL_NULL_STRING;
	char l_mis_info[4000] = APL_NULL_STRING;
	
	/* Added By Kalyan for Web Module Chgs -- From here*/
	char l_err_label[100] = APL_NULL_STRING;
	char l_err_lab_val[100] = APL_NULL_STRING;

	int l_int_num = 0; //Added On 24/05/2007
	char **temp;	   //Added On 24/05/2007
	int l_loopcnt = 0; //Added On 24/05/2007
	char l_temp_err_val[30];  //Added On 24/05/2007

	/* Added By Kalyan for Web Module Chgs -- Till here*/
BT_IF_DEBUG
	fprintf(l_logfile,"Environ Data\n|%s|\n",p_env_data);

BT_IF_DEBUG
	fprintf(l_logfile,"Param Data\n|%s|\n",p_param_data);

	APL_FUNCTION_ENTER(l_logfile)
	printf("Store Procedure Name |%s|\n",p_gfu_req_map_h -> h_sp_name);
	if(!strcmp(p_gfu_req_map_h -> h_sp_name,"SP_INTL_MT_DM"))
	{
		EXEC SQL CALL SP_INTL_MT_DM(:p_gfu_req_map_h -> h_wrapper,:p_env_data,:p_param_data,:p_gfu_req_map_h -> h_user,:l_error);
	}
	else if(!strcmp(p_gfu_req_map_h -> h_sp_name,"SP_INTL_MT"))
	{
		EXEC SQL CALL SP_INTL_MT(:p_gfu_req_map_h -> h_wrapper,:p_env_data,:p_param_data,:p_gfu_req_map_h -> h_user,:l_error);
	}
	else if(!strcmp(p_gfu_req_map_h -> h_sp_name,"SP_INTL_CA"))
	{
		EXEC SQL CALL SP_INTL_CA(:p_gfu_req_map_h -> h_wrapper,:p_env_data,:p_param_data,:p_gfu_req_map_h -> h_user,:l_error);
	}
	else if(!strcmp(p_gfu_req_map_h -> h_sp_name,"SP_INTL_DEAL"))
	{
		printf(" Entering sp_intl_deal:\n\t|%s|\n\t|%s|\n\t|%s|\n\t|%s|\n\t|%s|\n\t|%s|",p_gfu_req_map_h -> h_wrapper,p_env_data,p_param_data,p_gfu_req_map_h -> h_user,l_mis_info,l_error);
		EXEC SQL CALL SP_INTL_DEAL(:p_gfu_req_map_h -> h_wrapper,:p_env_data,:p_param_data,:p_gfu_req_map_h -> h_user,:l_mis_info,:l_error);
	}
        /* Added By Kalyan for WIM , DAEMON_WEB */
        else if(!strcmp(p_gfu_req_map_h -> h_sp_name,"SP_WEB_MN"))
        {
         	EXEC SQL CALL SP_WEB_MN(:p_gfu_req_map_h -> h_wrapper,:p_env_data,:p_param_data,:p_gfu_req_map_h -> h_user,:l_error);
        }
        /* Kalyan -- Till here */
         /* Added Q3-ENH-CA-Voluntary -START Commented By Gouse
        else if(!strcmp(p_gfu_req_map_h -> h_sp_name,"SP_WEB_BAT"))
        { 
                 printf("Before GF_Proc_Bat function call \n");
                if(APL_FAILURE == GF_Proc_Bat(p_param_data,p_env_data,l_debug_info_ptr))
               APL_GOBACK_FAIL
                printf("After Function call \n");
                EXEC SQL CALL SP_WEB_BAT(:p_gfu_req_map_h -> h_wrapper,:p_env_data,:p_param_data,:p_gfu_req_map_h -> h_user,:l_error);
        }
         Added for Q3-ENH-CA-Voluntary - END*/

	IS_ANY_ORA_ERROR
BT_IF_DEBUG
		fprintf(l_logfile,"Return From Daemon : %s \n",l_error);



	/* Added By Kalyan For Web Module -- From Here */

	strcpy(l_err_label,p_gfu_req_map_h->h_rep_label);

	/* Added on 24/05/2007 for retrieving Multiple Lables ....*/

        if(APL_FAILURE == CO_SplitStr(l_err_label, '|', &l_int_num, &temp))
        {
        printf("Failure from first CO_SplitStr with seperator as | \n");
                APL_GOBACK_FAIL
        }
	
	printf("KS -- Number of label to be displayed ... [%d]\n",l_int_num); 
	for(l_loopcnt=0;l_loopcnt<l_int_num;l_loopcnt++)
	{
		printf("KS -- Label[%d] is .. [%s]\n",l_loopcnt,temp[l_loopcnt]); 
		CO_Rtv_DataString(p_param_data,temp[l_loopcnt],l_temp_err_val);
		printf("Value Fetched is [%s] \n",l_temp_err_val);
		strcat(l_err_lab_val,l_temp_err_val);
		strcat(l_err_lab_val,"|");
		memset(l_temp_err_val,APL_NULL_CHAR,sizeof(l_temp_err_val));
	}
	
	//printf("KS -- Label is [%s] \nKS -- Value Fetched is [%s] \n",l_err_label,l_err_lab_val);

        if(strlen(l_err_label)==0)
	{
		printf("KS -- Label is Null ............\n");
        	strcpy(l_err_label,"-\t");
        	strcpy(l_err_lab_val,"-\t");
	}
	

	/* Added By Kalyan For Web Module -- Till Here */



	
	/** there May be cases where the daemon outputs some value along with SUCCESS, So changed strcmp to strstr **/
	if(!strstr(l_error,"SUCCESS"))
	{
	/*	Comment for UAT */
		/*
		if(APL_FAILURE ==	GFU_Rtv_DelStr(	l_error, 
						"|", 
						10,
						l_reason,
						l_debug_info_ptr))
			APL_GOBACK_FAIL
		*/
		/*if(APL_FAILURE == GFU_UpdErrorDet(	p_line_no,
							"N",
							"FAILURE",
							APL_NULL_STRING,
							APL_NULL_STRING,
							l_reason,
							l_debug_info_ptr))
		APL_GOBACK_FAIL
		*/

		/*if(APL_FAILURE == GFU_UpdErrorDet(   p_line_no, Commented By Kalyan
					"N",
					"FAILURE",
					APL_NULL_STRING,
					APL_NULL_STRING,
					l_error,
					l_debug_info_ptr))
			APL_GOBACK_FAIL
		*/
		if(APL_FAILURE == GFU_UpdErrorDet(   p_line_no,
					"N",
					"FAILURE",
					l_err_label,
					l_err_lab_val,
					l_error,
					l_debug_info_ptr))
			APL_GOBACK_FAIL

		if(APL_FAILURE == GFU_Write_Skipped(	p_line_no,
							l_debug_info_ptr))
		APL_GOBACK_FAIL



	}
	else
	{
		if(APL_FAILURE == GFU_UpdErrorDet(	p_line_no,
							"N",
							"SUCCESS",
							l_err_label,
							l_err_lab_val,
							APL_NULL_STRING,
							l_debug_info_ptr))
		APL_GOBACK_FAIL
	}


	APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}




/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Lst_To_Data																 *
 *                                                                                                       *
 * Description           : This Function is used for making string from linked list						 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_token_value_lst                   GFU_TOKEN_VAL_STRUCT_LST **      I      Linked list Token/Value   *
 *                                                                                                       *
 * p_data							   char *                           O      Converted String		     *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/


int GFU_Lst_To_Data(GFU_TOKEN_VAL_STRUCT_LST **p_token_value_lst, char *p_data,DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	
	char l_line[GFU_LINE_LEN] = APL_NULL_STRING;
	GFU_TOKEN_VAL_STRUCT_LST **l_temp_ptr = p_token_value_lst;
	APL_FUNCTION_ENTER(l_logfile)
	memset(p_data,APL_NULL_CHAR,sizeof(p_data));

	while((*l_temp_ptr)!=NULL)
	{
		memset(l_line,APL_NULL_CHAR,sizeof(l_line));
		sprintf(l_line,"%c%s%c%s",DATA_FIELD_SEPRTR,(*l_temp_ptr) -> h_token,DATA_VALUE_SEPRTR,(*l_temp_ptr) -> h_value);
BT_IF_DEBUG
		fprintf(l_logfile,"\t|%s|\t\t=\t\t|%s|\n",(*l_temp_ptr) -> h_token,(*l_temp_ptr) -> h_value);
		strcat(p_data,l_line);
		l_temp_ptr = &((*l_temp_ptr) -> h_next);
	}

APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)


}


/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Process_Rec																 *
 *                                                                                                       *
 * Description           : This Function is used to process single record								 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 * p_gfu_env_map_lst                   GFU_TOKEN_VAL_STRUCT_LST **      I      Environment list			 *
 *                                                                                                       *
 * p_gfu_val_map_lst				   GFU_VAL_MAP_STRUCT_LST **        I      Validation List		     *
 *																										 *
 * p_gfu_req_map_h					   GFU_REQ_MAP_STRUCT_H *			I	   Request Map Structure     *
 *																										 *
 * p_gfu_param_data_lst				   GFU_TOKEN_VAL_STRUCT_LST **		I	   Parameter Data List		 *
 *																										 *
 * p_line_no						   int								I	   Line number of record	 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/



int GFU_Process_Rec(	GFU_TOKEN_VAL_STRUCT_LST **p_gfu_env_map_lst,
						GFU_VAL_MAP_STRUCT_LST **p_gfu_val_map_lst,
						GFU_REQ_MAP_STRUCT_H *p_gfu_req_map_h,
						GFU_TOKEN_VAL_STRUCT_LST **p_gfu_param_data_lst,
						int p_line_no,
						DEBUG_INFO_STRUCT_H **l_debug_info_ptr)


{
	char l_param_data[GFU_PARAM_DATA_LEN];
	char l_env_data[GFU_ENV_DATA_LEN];

	APL_FUNCTION_ENTER(l_logfile)
	memset(l_param_data,APL_NULL_CHAR,sizeof(l_param_data));
	memset(l_env_data,APL_NULL_CHAR,sizeof(l_env_data));

	if(GF_FnlProc(p_gfu_param_data_lst,p_gfu_env_map_lst,p_line_no,p_gfu_req_map_h -> h_module,l_debug_info_ptr) == APL_FAILURE)
		APL_GOBACK_FAIL

	if(APL_FAILURE == GFU_Lst_To_Data(p_gfu_param_data_lst,l_param_data,l_debug_info_ptr))
		APL_GOBACK_FAIL

	if(APL_FAILURE == GFU_Lst_To_Data(p_gfu_env_map_lst,l_env_data,l_debug_info_ptr))
		APL_GOBACK_FAIL

	if(APL_FAILURE == Call_Stored_Proc(p_gfu_req_map_h,l_env_data,l_param_data,p_line_no,l_debug_info_ptr))
		APL_GOBACK_FAIL


APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)

}

/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Process_Lst																 *
 *                                                                                                       *
 * Description           : This Function is used to process whole file converted as list				 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_file_lst						   GFU_FILE_LST						I	   Full List				 *
 *																										 *
 * p_process_name					   char *							I      Name of the process		 *
 *																									     *
 * p_process_key					   char *							I      Key of the Process		 *
 *																										 *
 * p_start_date						   char *							I	   Started Date				 *
 *																										 *
 * p_gfu_val_map_lst				   GFU_VAL_MAP_STRUCT_LST **        I      Validation List		     *
 *																										 *
 * p_gfu_req_map_h					   GFU_REQ_MAP_STRUCT_H *			I	   Request Map Structure     *
 *																										 *
 * p_gfu_env_map_lst                   GFU_TOKEN_VAL_STRUCT_LST **      I      Environment list			 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/

int GFU_Process_Lst(GFU_FILE_LST **p_file_lst,
					char *p_process_name,
					char *p_process_key,
					char *p_start_date,
					GFU_VAL_MAP_STRUCT_LST **p_gfu_val_map_lst,
					GFU_REQ_MAP_STRUCT_H *p_gfu_req_map_h,
					GFU_TOKEN_VAL_STRUCT_LST **p_gfu_env_map_lst,
					DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	GFU_FILE_LST **l_temp_ptr = p_file_lst;
	char l_status_info[100];

	APL_FUNCTION_ENTER(l_logfile)
	while((*l_temp_ptr)!=NULL)
	{
	        fputs("\n",stdin);
                fflush(stdin);
			
		if(APL_FAILURE == CO_FreeErrLst(l_debug_info_ptr))
			APL_GOBACK_FAIL

		if(!(((*l_temp_ptr) -> h_line_no)%GFU_COMMIT_COUNT))
		{
			memset(l_status_info,APL_NULL_CHAR,sizeof(l_status_info));
			sprintf(l_status_info," Processed Till Line |%d| Record |%d|\n",(*l_temp_ptr) -> h_line_no,(*l_temp_ptr) -> h_rec_no);

			if(APL_FAILURE == BT_Status_Update(	p_process_name,
											p_process_key,
											p_start_date,
											l_status_info,
											l_debug_info_ptr))
			APL_GOBACK_FAIL
		}

		if(APL_FAILURE == GFU_Process_Rec(	p_gfu_env_map_lst,
							p_gfu_val_map_lst,
							p_gfu_req_map_h,
							(*l_temp_ptr)-> h_token_val,
							(*l_temp_ptr)-> h_line_no,
							l_debug_info_ptr))
		{
			if(APL_FAILURE == GFU_UpdErrorDet(	(*l_temp_ptr) -> h_line_no,
							"N",
							"FAILURE",
							APL_NULL_STRING,
							APL_NULL_STRING,
							APL_NULL_STRING,
							l_debug_info_ptr))
			APL_GOBACK_FAIL

			if(APL_FAILURE == GFU_Write_Skipped(	(*l_temp_ptr) -> h_line_no,
								l_debug_info_ptr))
			APL_GOBACK_FAIL 

		}
			
		l_temp_ptr = &((*l_temp_ptr)->h_next);
		/** Reporting Will be done here */
	}
APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}



/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : Read_Ascii																	 *
 *                                                                                                       *
 * Description           : This Function is used to One Ascii line to list								 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_line							   char *							I	   line						 *
 *																										 *
 * p_line_no						   int								I	   line number				 *
 *																										 *
 * p_gfu_file_map_h					   GFU_FILE_MAP_STRUCT_H *			I	   Conatins Details about the file *
 *																										 *
 * p_gfu_format_map_lst				   GFU_FORMAT_MAP_STRUCT_LST **		I      Format List				 *
 *																									     *
 * p_token_value					   GFU_TOKEN_VAL_STRUCT_LST			O      The Output List			 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/

int Read_Ascii(	char *p_line,
		int p_line_no,
					GFU_FILE_MAP_STRUCT_H *p_gfu_file_map_h,
				GFU_FORMAT_MAP_STRUCT_LST **p_gfu_format_map_lst,
				GFU_TOKEN_VAL_STRUCT_LST **p_token_value,
				DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	GFU_FORMAT_MAP_STRUCT_LST **l_temp_ptr = p_gfu_format_map_lst;
	GFU_TOKEN_VAL_STRUCT_LST **l_token_value = p_token_value;

	GFU_FORMAT_MAP_STRUCT_LST *l_curr_format_node = (GFU_FORMAT_MAP_STRUCT_LST *)NULL;
	
	char l_value[GFU_VALUE_LEN];
	
	APL_FUNCTION_ENTER(l_logfile)	

	while((*l_temp_ptr)!=NULL)
	{
		/** Here we have to add Read from file name if Test is F this is for Belav files**/
		memset(l_value,APL_NULL_CHAR,sizeof(l_value));
		BT_IF_DEBUG
			fprintf(l_logfile,"Read From File Name Or Text (F/T) : %s\n",(*l_temp_ptr) -> h_header_text);
		l_curr_format_node = (GFU_FORMAT_MAP_STRUCT_LST *)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_LST));
		memset(l_curr_format_node,NULL,sizeof(GFU_FORMAT_MAP_STRUCT_LST));
		strcpy(l_curr_format_node -> h_refno,(*l_temp_ptr) -> h_refno);
		strcpy(l_curr_format_node -> h_valid,(*l_temp_ptr) ->h_valid);
		strcpy(l_curr_format_node -> h_header_text,(*l_temp_ptr) ->h_header_text);
		strcpy(l_curr_format_node -> h_field_type,(*l_temp_ptr) ->h_field_type);
		strcpy(l_curr_format_node -> h_label,(*l_temp_ptr) ->h_label);
		strcpy(l_curr_format_node -> h_seq,(*l_temp_ptr) ->h_seq);
		strcpy(l_curr_format_node -> h_start,(*l_temp_ptr) ->h_start);
		strcpy(l_curr_format_node -> h_end,(*l_temp_ptr) ->h_end);
		strcpy(l_curr_format_node -> h_remove_char,(*l_temp_ptr) ->h_remove_char);
		strcpy(l_curr_format_node -> h_remove_last_char,(*l_temp_ptr) ->h_remove_last_char);
		strcpy(l_curr_format_node -> h_static_val,(*l_temp_ptr) ->h_static_val);
		strcpy(l_curr_format_node -> h_val_type,(*l_temp_ptr) ->h_val_type);
		strcpy(l_curr_format_node -> h_date_format,(*l_temp_ptr) ->h_date_format);
		strcpy(l_curr_format_node -> h_header,(*l_temp_ptr) ->h_header);
		l_curr_format_node -> h_srl_no = (*l_temp_ptr) ->h_srl_no;
		strcpy(l_curr_format_node -> h_repeat,(*l_temp_ptr) ->h_repeat);
		strcpy(l_curr_format_node -> h_query,(*l_temp_ptr) ->h_query);
		l_curr_format_node -> h_next = (GFU_FORMAT_MAP_STRUCT_LST *)NULL;
		
		switch (l_curr_format_node -> h_header_text[0])
		{

			case 'T':
				if(APL_FAILURE == Rtv_Data_Value(	p_line,
							p_line_no,
							p_gfu_file_map_h -> h_file_type,
							l_curr_format_node -> h_label,
							l_curr_format_node -> h_refno,
							l_curr_format_node -> h_field_type,
							l_curr_format_node -> h_seq,
							l_curr_format_node -> h_start,
							l_curr_format_node -> h_end,
							p_gfu_file_map_h -> h_delimiter,					
							l_curr_format_node -> h_remove_char,
							l_curr_format_node -> h_remove_last_char,
							l_curr_format_node -> h_static_val,
							l_curr_format_node -> h_val_type,
							l_curr_format_node -> h_date_format,
							l_curr_format_node -> h_srl_no,
							l_curr_format_node -> h_repeat,
							l_curr_format_node -> h_query,
							l_value,
							l_debug_info_ptr))
					APL_GOBACK_FAIL
						break;
			case 'F':
				if(APL_FAILURE == Rtv_Data_Value(p_gfu_file_map_h -> h_file_name,
							p_line_no,
							p_gfu_file_map_h -> h_file_type,
							l_curr_format_node -> h_label,
							l_curr_format_node -> h_refno,
							l_curr_format_node -> h_field_type,
							l_curr_format_node -> h_seq,
							l_curr_format_node -> h_start,
							l_curr_format_node -> h_end,
							p_gfu_file_map_h -> h_delimiter,	
							l_curr_format_node -> h_remove_char,
							l_curr_format_node -> h_remove_last_char,
							l_curr_format_node -> h_static_val,
							l_curr_format_node -> h_val_type,
							l_curr_format_node -> h_date_format,
							l_curr_format_node -> h_srl_no,
							l_curr_format_node -> h_repeat,
							l_curr_format_node -> h_query,
							l_value,
							l_debug_info_ptr))
					APL_GOBACK_FAIL
						break;
		}

						
		while((*l_token_value) != NULL)
		{
			l_token_value = &((*l_token_value)->h_next);
		}
		if(((*l_token_value) = (GFU_TOKEN_VAL_STRUCT_LST *)calloc(1,sizeof(GFU_TOKEN_VAL_STRUCT_LST))) == NULL)
		{
BT_IF_DEBUG
			fprintf(l_logfile,"failed in New Allocation\n");
			APL_GOBACK_FAIL
		}
		strcpy((*l_token_value) -> h_token, l_curr_format_node -> h_label);
		strcpy((*l_token_value) -> h_value, l_value);
		(*l_token_value) -> h_next = NULL;
		l_temp_ptr = &((*l_temp_ptr)->h_next);
		APL_FREE(l_curr_format_node);

	}
APL_GOBACK_SUCCESS
RETURN_FAILURE:
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}


/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Conv_Lnk_Lst																 *
 *                                                                                                       *
 * Description           : This Function is used to Convert file to linked list							 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_file							   FILE *							I	   file pointer				 *
 *																										 *
 * p_process_name					   char *							I      Name of the process		 *
 *																									     *
 * p_process_key					   char *							I      Key of the Process		 *
 *																										 *
 * p_start_date						   char *							I	   Started Date				 *
 *																										 *
 * p_gfu_file_map					   GFU_FILE_MAP_STRUCT_H *			I	   Conatins Details about the file *
 *																										 *
 * p_gfu_format_map_lst				   GFU_FORMAT_MAP_STRUCT_LST **		I      Format List				 *
 *																									     *
 * p_file_lst						   GFU_FILE_LST **					O      The Output List			 *
 *                                                                                                       *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/

int Prnt_Format(GFU_FORMAT_MAP_STRUCT_LST **p_gfu_format_map_lst)
{
	GFU_FORMAT_MAP_STRUCT_LST **l_temp_ptr = p_gfu_format_map_lst;
	while(*l_temp_ptr)
	{
		printf("%s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %d\n %s\n %s",
				(*l_temp_ptr) ->  h_refno,
				(*l_temp_ptr) ->  h_valid,
				(*l_temp_ptr) ->  h_header_text,
				(*l_temp_ptr) ->  h_field_type,
				(*l_temp_ptr) ->  h_label,
				(*l_temp_ptr) ->  h_seq,
				(*l_temp_ptr) ->  h_start,
				(*l_temp_ptr) ->  h_end,
				(*l_temp_ptr) ->  h_remove_char,
				(*l_temp_ptr) ->  h_remove_last_char,
				(*l_temp_ptr) ->  h_static_val,
				(*l_temp_ptr) ->  h_val_type,
				(*l_temp_ptr) ->  h_date_format,
				(*l_temp_ptr) ->  h_header,
				(*l_temp_ptr) ->      h_srl_no,
				(*l_temp_ptr) ->  h_repeat,
				(*l_temp_ptr) ->  h_query);
	l_temp_ptr = &((*l_temp_ptr)->h_next);
	}

}
int GFU_Conv_Lnk_Lst(	FILE *p_file,
						char *p_process_name,
						char *p_process_key,
						char *p_start_date,
						GFU_FILE_MAP_STRUCT_H *p_gfu_file_map,
	/**					GFU_FILE_LST **p_file_lst,**/
						GFU_TOKEN_VAL_STRUCT_LST **p_gfu_env_map_lst,
						GFU_VAL_MAP_STRUCT_LST **p_gfu_val_map_lst,
						GFU_REQ_MAP_STRUCT_H *p_gfu_req_map_h,
						DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	/**GFU_FILE_LST **l_temp_ptr = p_file_lst;**/
	GFU_FORMAT_MAP_STRUCT_LST **l_gfu_format_map_lst = (GFU_FORMAT_MAP_STRUCT_LST **)NULL;
	GFU_FORMAT_MAP_STRUCT_LST *l_gfu_format_map_free = (GFU_FORMAT_MAP_STRUCT_LST *)NULL;
	GFU_FORMAT_MAP_STRUCT_LST **l_gfu_header_map_lst = (GFU_FORMAT_MAP_STRUCT_LST **)NULL;
	GFU_FORMAT_MAP_STRUCT_LST *l_gfu_header_map_free = (GFU_FORMAT_MAP_STRUCT_LST *)NULL;

	GFU_TOKEN_VAL_STRUCT_LST **l_token_value = (GFU_TOKEN_VAL_STRUCT_LST **)NULL;
	GFU_TOKEN_VAL_STRUCT_LST	*l_token_value_free = (GFU_TOKEN_VAL_STRUCT_LST *)NULL;
	int l_count = 1;
	int l_line_no = 0;
	int l_line_len = 0;
	char l_skip_line[GFU_SKIP_LINE_LEN];
	char l_line[GFU_LINE_LEN];
	char l_refno[GFU_REFNO_LEN];
	char l_status_info[100];
	char l_temp_module[100];
	
	APL_FUNCTION_ENTER(l_logfile)



	
	l_gfu_header_map_lst = (GFU_FORMAT_MAP_STRUCT_LST **)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_LST *));
	l_token_value = (GFU_TOKEN_VAL_STRUCT_LST **)calloc(1,sizeof(GFU_TOKEN_VAL_STRUCT_LST *));
	l_gfu_format_map_lst = (GFU_FORMAT_MAP_STRUCT_LST **)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_LST *));
	
	if(!strcmp(p_gfu_file_map -> h_check_header,"Y"))
	{
	if(APL_FAILURE == Rtv_Format_Frm_Header(	p_gfu_file_map -> h_refno,
												p_gfu_file_map -> h_header,
												p_gfu_file_map -> h_format_no,
												l_gfu_header_map_lst,
												l_debug_info_ptr))

	{	
		printf("Failed in Rtv_Format_Frm_Header\n");
		APL_GOBACK_FAIL
	}
	}
	IF_COND_NOT_EXISTS("GFU_PROCESS","LINE_FORMATS")
	{
		if(APL_FAILURE == GFU_Rtv_Format(	p_gfu_file_map -> h_refno,
					p_gfu_file_map,
					l_gfu_format_map_lst,
					l_debug_info_ptr))
		{	
			printf("Failed in GFU_Rtv_Format\n");
			APL_GOBACK_FAIL
		}
	}
	else
	{
		printf("Condition  Exists\n");
	}

	while(!feof(p_file))
	{	
		/**usleep(MICRO_SECONDS);**/
		IF_COND_EXISTS("GFU_PROCESS","LINE_FORMATS")
		{
        while(*l_gfu_format_map_lst)
        {
                l_gfu_format_map_free = (*l_gfu_format_map_lst) -> h_next;
                APL_FREE((*l_gfu_format_map_lst));
                (*l_gfu_format_map_lst) = l_gfu_format_map_free;
        }
		}
		else
		{
			printf("Condition Doent Exists\n");
		}
       while(*l_token_value)
       {
                l_token_value_free = (*l_token_value) -> h_next;
                APL_FREE((*l_token_value));
                (*l_token_value) = l_token_value_free;
        }
		if(APL_FAILURE == CO_FreeErrLst(l_debug_info_ptr))
			APL_GOBACK_FAIL

		

		l_token_value = (GFU_TOKEN_VAL_STRUCT_LST **)calloc(1,sizeof(GFU_TOKEN_VAL_STRUCT_LST *));
		printf("Line No |%d|\n",l_line_no);
		if(!(l_line_no%GFU_COMMIT_COUNT))
		{
			memset(l_status_info,APL_NULL_CHAR,sizeof(l_status_info));
			/**sprintf(l_status_info," Parsed Till Line |%d| Record |%d|\n",l_line_no,l_count - 1);**/
			sprintf(l_status_info," Processed Till Line |%d| Record |%d|\n",l_line_no,l_count - 1);

			if(APL_FAILURE == BT_Status_Update(	p_process_name,
												p_process_key,
												p_start_date,
												l_status_info,
												l_debug_info_ptr))
				APL_GOBACK_FAIL
		}
											

		l_line_no ++;

/**
		l_gfu_format_map_lst = (GFU_FORMAT_MAP_STRUCT_LST **)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_LST *));
		**/


		switch(p_gfu_file_map -> h_file_type[0])
		{
			case GFU_ASCII:
			case GFU_POSITION:
					memset(l_refno,APL_NULL_CHAR,sizeof(l_refno));
					/**if(feof(p_file))APL_GOBACK_FAIL -- Biju **/
					memset(l_line,APL_NULL_CHAR,sizeof(l_line));	
					fgets(l_line,GFU_LINE_LEN,p_file);
							Alert("Hi");

					/* Added by Kalyan to terminate line by comma if comma is not present for csv upload -- 23/05/2007 */
					l_line_len=strlen(l_line);
					printf("KS -- Length of Selected Line is ... [%d]\n",l_line_len);

					if(l_line_len>0)
 					if((strstr(p_gfu_file_map -> h_file_name,".csv")!=NULL)||(strstr(p_gfu_file_map -> h_file_name,".CSV")!=NULL))
					{
						printf("KS -- This is CSV File ... Checking for termination by Comma....\n");
						printf("Termination Char is ........[%c]\n",l_line[l_line_len-1]);
						printf("Gouse ::: Delimiter is l_line[l_line_len-2] [%c]",l_line[l_line_len-2]);
						if(l_line[l_line_len-2]=='|')//[l_line_len-1] to [l_line_len-2]& ',' to '|' - Changed by Gouse for Web Cust Deal Upload
						{
							printf("KS -- Terminated By Comma ... No changes Required ....\n");
						}
						else if(l_line[l_line_len-1]=='\n'||l_line[l_line_len-1]=='\0')
						{
							printf("KS -- This Line is Terminated By New-Line Char ...\n");
							if(l_line[l_line_len-2]== toascii(13))
							{
								printf("KS -- Found ^M Char... Removing.......\n");
								printf("KS -- Line b4 appending...%s\n",l_line);
								l_line[l_line_len-2]=',';
								printf("KS -- Line After appending...%s\n",l_line); 
							}
							else if(l_line[l_line_len-2]!=',')
							{
								printf("KS -- Comma Missing at end of Line...appending....\n");
								printf("KS -- Line b4 appending...%s\n",l_line);
								//strcat(l_line,",");
								l_line[l_line_len-1]=',';
								l_line[l_line_len]='\n';
								l_line[l_line_len]='\0';
								printf("KS -- Line After appending...%s\n",l_line);
							}
						}
						else if (l_line[l_line_len-1]==' ')
						{
							int j=0;
							printf("KS -- Blank Space ....\n"); 
							for(j=l_line_len-1;j!=0;j--)
							{
								if(l_line[j] !=' ')
								{
									printf("KS -- Comma Missing at end of Line...appending....\n");
									printf("KS -- Line b4 appending...%s\n",l_line);
									strcat(l_line,",");
									printf("KS -- Line After appending...%s\n",l_line);
									break;
								}
							}
						}
						else
						{
							printf("KS -- Not Terminated by Space or New line.... appending\n");
							printf("KS -- Line b4 appending...%s\n",l_line);
							strcat(l_line,",");
							printf("KS -- Line After appending...%s\n",l_line);
						}
					
					}
					if(strrchr(l_line,'\n'))*(strrchr(l_line,'\n')) = APL_NULL_CHAR;
					memset(l_skip_line,APL_NULL_CHAR,sizeof(l_skip_line));
					sprintf(l_skip_line,"%s%d%s",GFU_SKIP_LINE_DEL,l_line_no,GFU_SKIP_LINE_DEL);
					/**fprintf(l_logfile,"Line|%d|%s|\n",l_line_no,l_line);**/
					memset(g_line,APL_NULL_CHAR,sizeof(g_line));
					strcpy(g_line,l_line);
					if(strstr(p_gfu_file_map -> h_skip_line,l_skip_line))
					{
						BT_IF_DEBUG
							fprintf(l_logfile,"Skipping Specified Line |%d| \n",l_line_no);

						if(APL_FAILURE == GFU_UpdErrorDet(	l_line_no,
											"Y",
											APL_NULL_STRING,
											APL_NULL_STRING,
											APL_NULL_STRING,
											"Line Should Not Be Processed, Skipped",
											l_debug_info_ptr))
							APL_GOBACK_FAIL
						if(APL_FAILURE == GFU_Write_Skipped(	l_line_no,
											l_debug_info_ptr))
						APL_GOBACK_FAIL


						continue;

					}
					if(l_line_no == p_gfu_file_map -> h_header)
					{
						BT_IF_DEBUG
							fprintf(l_logfile,"Skipping Header Line |%d| \n",l_line_no);

						if(APL_FAILURE == GFU_UpdErrorDet(	l_line_no,
											"Y",
											APL_NULL_STRING,
											APL_NULL_STRING,
											APL_NULL_STRING,
											"Line Is Header, Skipped",
											l_debug_info_ptr))
							APL_GOBACK_FAIL
						if(APL_FAILURE == GFU_Write_Skipped(	l_line_no,
											l_debug_info_ptr))
						APL_GOBACK_FAIL

						continue;
					}
					if(!strlen(l_line))continue;
							Alert("Hi");

					IF_COND_EXISTS("GFU_PROCESS","LINE_FORMATS")
					{
					if(APL_FAILURE == Rtv_Format_Refno(	l_line,
														l_line_no,
														l_refno,
									p_gfu_req_map_h,
														l_debug_info_ptr))
					{	
							fprintf(l_logfile,"Failed in Rtv_Format_Refno\n");
							/* Commented By Kalyan on 28/05/2007 */
							/*if(APL_FAILURE == GFU_UpdErrorDet(  l_line_no,"N",
										"FAILURE",
									APL_NULL_STRING,
									APL_NULL_STRING,
									APL_NULL_STRING,
									l_debug_info_ptr))
							APL_GOBACK_FAIL
						if(APL_FAILURE == GFU_Write_Skipped(   l_line_no,
											l_debug_info_ptr))
									APL_GOBACK_FAIL */

						continue;
					}
			
			BT_IF_DEBUG
					fprintf(l_logfile,"Refno |%s|\n",l_refno);
						strcpy(l_temp_module,p_gfu_file_map -> h_module);
						strcpy(p_gfu_file_map -> h_module,l_refno);	
						l_gfu_format_map_lst = (GFU_FORMAT_MAP_STRUCT_LST **)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_LST *));
					if(APL_FAILURE == GFU_Rtv_Format(	l_refno,
										p_gfu_file_map,
										l_gfu_format_map_lst,
										l_debug_info_ptr))
					{	
							fprintf(l_logfile,"Failed in GFU_Rtv_Format\n");
							if(APL_FAILURE == GFU_UpdErrorDet(  l_line_no,
										"N",
										"FAILURE",
										APL_NULL_STRING,
										APL_NULL_STRING,
										"Failed To Retrieve Format",
										l_debug_info_ptr))
						APL_GOBACK_FAIL

									if(APL_FAILURE == GFU_Write_Skipped(   l_line_no,
												l_debug_info_ptr))
										APL_GOBACK_FAIL
							Alert("Hi");
							strcpy(p_gfu_file_map -> h_module,l_temp_module);
											continue;


						}
							strcpy(p_gfu_file_map -> h_module,l_temp_module);

					}
					else
					{
						printf("Condition Doent Exists\n");
					}

					/*Prnt_Format(l_gfu_format_map_lst);*/
					/** After Retrieving the format lets Proceeding For CSV/EXCEL/TEXT Setup **/
					if(APL_FAILURE == Process_C_E_T(	l_gfu_format_map_lst,
																l_refno,
																p_gfu_file_map -> h_module,
																p_gfu_file_map -> h_vendor,
																l_debug_info_ptr))
					{
						CO_ProcMonitor(APL_OUT_FILE,"Failed in PCT ",l_debug_info_ptr,NULL);
						APL_GOBACK_FAIL
					}
					/*Prnt_Format(l_gfu_format_map_lst);*/
																	
					if(!strcmp(p_gfu_file_map -> h_check_header,"Y"))
					{
					if(APL_FAILURE == GF_Chk_Header_Format(	p_gfu_file_map,
															l_gfu_format_map_lst,
															l_gfu_header_map_lst,
															l_debug_info_ptr))

					{	
						printf("Failed in Rtv_Format_Frm_Header\n");
						APL_GOBACK_FAIL
					}
					}

					/**if(!strlen(l_line))continue; Already Done Aboive -- Biju **/
					Alert("Before Read Ascii");

			
					if(APL_FAILURE == Read_Ascii(	l_line,
															l_line_no,
															p_gfu_file_map,
															l_gfu_format_map_lst,
															l_token_value,
															l_debug_info_ptr))
					{
						if(APL_FAILURE == GFU_UpdErrorDet(	l_line_no,"N",
											"FAILURE",
											APL_NULL_STRING,
											APL_NULL_STRING,
											APL_NULL_STRING,
											l_debug_info_ptr))
							APL_GOBACK_FAIL
						if(APL_FAILURE == GFU_Write_Skipped(	l_line_no,
											l_debug_info_ptr))
						APL_GOBACK_FAIL

						continue;
					}
					Alert("Before Read Ascii");
					break;
				
			case GFU_BINARY:
							/*Read_Binary(p_file,p_gfu_file_map,l_gfu_format_map_lst,l_token_value);*/
							break;
		}	
		/** l_token_value  Cotains Token And values We need **/
		/**usleep(MICRO_SECONDS);**/
		Alert("Before Specific Fn");
		if(GF_SpecificRecFun( 	l_token_value,
									p_gfu_file_map,
									p_start_date,
									l_debug_info_ptr) == APL_FAILURE)
		{
			APL_GOBACK_FAIL
		}
		Alert("After Specific Fn");

		Alert("Before Process Rec");
		if(APL_FAILURE == GFU_Process_Rec(  p_gfu_env_map_lst,
					p_gfu_val_map_lst,
					p_gfu_req_map_h,
					l_token_value,
					l_line_no,
					l_debug_info_ptr))
		{
			if(APL_FAILURE == GFU_UpdErrorDet(  l_line_no,
						"N",
						"FAILURE",
						APL_NULL_STRING,
						APL_NULL_STRING,
						APL_NULL_STRING,
						l_debug_info_ptr))
				APL_GOBACK_FAIL

			if(APL_FAILURE == GFU_Write_Skipped(   l_line_no,
								l_debug_info_ptr))
				APL_GOBACK_FAIL

		}
		Alert("After Process Rec");
		l_count ++;
		/**
			
		while((*l_temp_ptr) != NULL)
		{
			l_temp_ptr = &((*l_temp_ptr)->h_next);
		}
		if(((*l_temp_ptr) = (GFU_FILE_LST *)calloc(1,sizeof(GFU_FILE_LST))) == NULL)
		{
			APL_GOBACK_FAIL
		}
		(*l_temp_ptr)->h_rec_no = l_count ++;
		(*l_temp_ptr)->h_line_no = l_line_no;
		(*l_temp_ptr)->h_token_val = l_token_value;

		if(GF_SpecificRecFun( 	(*l_temp_ptr),
									p_gfu_file_map,
									p_start_date,
									l_debug_info_ptr) == APL_FAILURE)
		{
			APL_GOBACK_FAIL
		}



		
		(*l_temp_ptr)->h_next = (GFU_FILE_LST *)NULL;
		**/
		
		/**
		IF_COND_EXISTS("GFU_PROCESS","LINE_FORMATS")
		{
        while(*l_gfu_format_map_lst)
        {
                l_gfu_format_map_free = (*l_gfu_format_map_lst) -> h_next;
                APL_FREE((*l_gfu_format_map_lst));
                (*l_gfu_format_map_lst) = l_gfu_format_map_free;
        }
		}
		**/
		
	}
	memset(l_status_info,APL_NULL_CHAR,sizeof(l_status_info));
	sprintf(l_status_info," Processed Till Line |%d| Record |%d|\n",l_line_no,l_count - 1);

	if(APL_FAILURE == BT_Status_Update(	p_process_name,
												p_process_key,
												p_start_date,
												l_status_info,
												l_debug_info_ptr))
		APL_GOBACK_FAIL

APL_GOBACK_SUCCESS
RETURN_FAILURE:
		IF_COND_NOT_EXISTS("GFU_PROCESS","LINE_FORMATS")
		{
        while(*l_gfu_format_map_lst)
        {
                l_gfu_format_map_free = (*l_gfu_format_map_lst) -> h_next;
                APL_FREE((*l_gfu_format_map_lst));
                (*l_gfu_format_map_lst) = l_gfu_format_map_free;
        }
		}
        while(*l_gfu_header_map_lst)
        {
                l_gfu_format_map_free = (*l_gfu_header_map_lst) -> h_next;
                APL_FREE((*l_gfu_header_map_lst));
                (*l_gfu_header_map_lst) = l_gfu_format_map_free;
        }

	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
		IF_COND_NOT_EXISTS("GFU_PROCESS","LINE_FORMATS")
		{
        while(*l_gfu_format_map_lst)
        {
                l_gfu_format_map_free = (*l_gfu_format_map_lst) -> h_next;
                APL_FREE((*l_gfu_format_map_lst));
                (*l_gfu_format_map_lst) = l_gfu_format_map_free;
        }
		}
        while(*l_gfu_header_map_lst)
        {
                l_gfu_format_map_free = (*l_gfu_header_map_lst) -> h_next;
                APL_FREE((*l_gfu_header_map_lst));
                (*l_gfu_header_map_lst) = l_gfu_format_map_free;
        }

	APL_FUNCTION_RET_SUCCESS(l_logfile)
}








/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Rtv_Format																 *
 *                                                                                                       *
 * Description           : This Function is used to Convert file to linked list							 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_format_refno					   char *							I	   gets format specified according to the refno*
 *																										 *
 * p_gfu_file_map_h					   GFU_FILE_MAP_STRUCT_H *			I	   Conatins Details about the file *
 *																										 *
 * p_gfu_format_map_lst				   GFU_FORMAT_MAP_STRUCT_LST **		I      Format List				 *
 *																									     *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/






int GFU_Rtv_Format(	char *p_format_refno,
					GFU_FILE_MAP_STRUCT_H *p_gfu_file_map_h,
					GFU_FORMAT_MAP_STRUCT_LST **p_gfu_format_map_lst,
					DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;
	GFU_FORMAT_MAP_STRUCT_LST **l_temp_ptr = p_gfu_format_map_lst;
	GFU_FORMAT_MAP_STRUCT_I		*l_gfu_format_map_i;
	GFU_FORMAT_MAP_STRUCT_H		*l_gfu_format_map_h;
	int l_cnt = 0;
	sqlca.sqlcode = 0;

	APL_FUNCTION_ENTER(l_logfile)

		/*
	EXEC SQL DECLARE l_cur_format_map CURSOR FOR 
			SELECT *
			FROM GFFORMATMAP
			WHERE REFNO = :p_format_refno
		**	AND HEADER_TEXT_IND = 'T' **
			ORDER BY SERIAL_NO;
*/
		EXEC SQL DECLARE l_cur_format_map CURSOR FOR
			SELECT * FROM GFFORMATMAP 
			WHERE REFNO = :p_gfu_file_map_h->h_module
			/** AND HEADER_TEXT_IND = 'T' **/
			ORDER BY SERIAL_NO;
	/**printf("Error During format Retrival SQLCA sqlcode=%d",sqlca.sqlcode);**/
	IS_ANY_ORA_ERROR

	EXEC SQL OPEN l_cur_format_map;

	IS_ANY_ORA_ERROR

	l_gfu_format_map_h = (GFU_FORMAT_MAP_STRUCT_H *)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_H));
	l_gfu_format_map_i = (GFU_FORMAT_MAP_STRUCT_I *)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_I));	

	for(;;)
	{
		
		memset(l_gfu_format_map_h,NULL,sizeof(GFU_FORMAT_MAP_STRUCT_H));
		memset(l_gfu_format_map_i,NULL,sizeof(GFU_FORMAT_MAP_STRUCT_I));
		EXEC SQL FETCH l_cur_format_map
				INTO :l_gfu_format_map_h:l_gfu_format_map_i;
		
		
		if(sqlca.sqlcode == 1403)break;
		IS_ANY_ORA_ERROR

		while((*l_temp_ptr) != (GFU_FORMAT_MAP_STRUCT_LST *)NULL)
		{
			l_temp_ptr = &((*l_temp_ptr)->h_next);
		}
		if(((*l_temp_ptr) = (GFU_FORMAT_MAP_STRUCT_LST *)calloc(1,sizeof(GFU_FORMAT_MAP_STRUCT_LST))) == NULL)
		{
			APL_GOBACK_FAIL
		}
		strcpy((*l_temp_ptr)->h_refno,l_gfu_format_map_h -> h_refno);
		strcpy((*l_temp_ptr)->h_valid,l_gfu_format_map_h -> h_valid);
		strcpy((*l_temp_ptr) -> h_header_text,l_gfu_format_map_h -> h_header_text);
		strcpy((*l_temp_ptr) -> h_field_type,l_gfu_format_map_h -> h_field_type);
		strcpy((*l_temp_ptr) -> h_label,l_gfu_format_map_h -> h_label);
		strcpy((*l_temp_ptr) -> h_seq,l_gfu_format_map_h -> h_seq);
		strcpy((*l_temp_ptr) -> h_start,l_gfu_format_map_h -> h_start);
		strcpy((*l_temp_ptr) -> h_end,l_gfu_format_map_h -> h_end);
		strcpy((*l_temp_ptr) -> h_remove_char,l_gfu_format_map_h -> h_remove_char);
		strcpy((*l_temp_ptr) -> h_remove_last_char,l_gfu_format_map_h -> h_remove_last_char);
		strcpy((*l_temp_ptr) -> h_static_val,l_gfu_format_map_h -> h_static_val);
		strcpy((*l_temp_ptr) -> h_val_type,l_gfu_format_map_h -> h_val_type);
		strcpy((*l_temp_ptr) -> h_date_format,l_gfu_format_map_h -> h_date_format);
		strcpy((*l_temp_ptr) -> h_header,l_gfu_format_map_h -> h_header);
		(*l_temp_ptr) -> h_srl_no = l_gfu_format_map_h -> h_srl_no;
		strcpy((*l_temp_ptr) -> h_repeat,l_gfu_format_map_h -> h_repeat);
		strcpy((*l_temp_ptr) -> h_query,l_gfu_format_map_h -> h_query);
		(*l_temp_ptr) -> h_next = (GFU_FORMAT_MAP_STRUCT_LST *)NULL;
		l_cnt++;


	}
	EXEC SQL CLOSE l_cur_format_map;
	IS_ANY_ORA_ERROR
	if(!l_cnt)APL_GOBACK_FAIL
	APL_GOBACK_SUCCESS
RETURN_FAILURE:
	
	APL_FREE(l_gfu_format_map_h);
	APL_FREE(l_gfu_format_map_i);
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:

	APL_FREE(l_gfu_format_map_h);
	APL_FREE(l_gfu_format_map_i);
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}



/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GF_Chk_Header_Format															 *
 *                                                                                                       *
 * Description           : This Function is used to Validate Against header							     *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_gfu_file_map_h					   GFU_FILE_MAP_STRUCT_H *			I	   Conatins Details about the file *
 *																										 *
 * p_gfu_format_map_lst				   GFU_FORMAT_MAP_STRUCT_LST **		I      Format List				 *
 *																										 *
 * p_gfu_header_map_lst				   GFU_FORMAT_MAP_STRUCT_LST **		I      Header List				 *
 *																									     *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/

int GF_Chk_Header_Format(	GFU_FILE_MAP_STRUCT_H *p_gfu_file_map_h,
							GFU_FORMAT_MAP_STRUCT_LST **p_gfu_format_map_lst,
							GFU_FORMAT_MAP_STRUCT_LST **p_gfu_header_map_lst,
							DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	GFU_FORMAT_MAP_STRUCT_LST **l_format = p_gfu_format_map_lst;
	GFU_FORMAT_MAP_STRUCT_LST **l_header;
APL_FUNCTION_ENTER(l_logfile)


	if(!strcmp(p_gfu_file_map_h -> h_check_header,"N"))APL_GOBACK_SUCCESS
	while((*l_format))
	{
		l_header = p_gfu_header_map_lst;
		while((*l_header))
		{
			if(!strcmp((*l_header) -> h_header,(*l_format) -> h_header) && strcmp((*l_format) -> h_field_type,"STATIC") && (*((*l_format) -> h_field_type) != GF_DELIM_CHAR_HASH))
			{
				if(strcmp((*l_header) -> h_start,(*l_format) -> h_start))
				{
BT_IF_DEBUG
					fprintf(l_logfile,"Header Format Not Matching |%s| |%s| On Start\n",(*l_header) -> h_start,(*l_format) -> h_start);
					APL_GOBACK_FAIL
				}
				if(strcmp((*l_header) -> h_end,(*l_format) -> h_end))
				{
BT_IF_DEBUG
					fprintf(l_logfile,"Header Format Not Matching |%s| |%s| On End\n",(*l_header) -> h_end,(*l_format) -> h_end);
					APL_GOBACK_FAIL
				}
			}
			printf("Matching |%s| |%s|\n",(*l_header) -> h_header,(*l_format) -> h_header);
			l_header = &((*l_header)->h_next);
			
		}
		l_format = &((*l_format)->h_next);
	}
APL_GOBACK_SUCCESS
RETURN_FAILURE:
	
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}



/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Rtv_File																     *
 *                                                                                                       *
 * Description           : This Function is used parse parametr string, get file pointer				 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_gfu_file_map_h					   GFU_FILE_MAP_STRUCT_H *			I	   Conatins Details about the file *
 *																										 *
 * p_file							   FILE	**							O      File pointer returned	 *
 *																									     *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/

int GFU_Rtv_File(	GFU_FILE_MAP_STRUCT_H *p_gfu_file_map_h,
			FILE **p_file,
			DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;
	char l_skip_line[GFU_SKIP_LINE_LEN];
	char l_cfg_filename[GFU_PATH_LEN];
	char l_param_data[GFU_LINE_LEN];
	char l_upl_dir[GFU_PATH_LEN];
	char l_upl_inp[GFU_PATH_LEN];
	char l_upl_out[GFU_PATH_LEN];
	char l_tmp_file[GFU_PATH_LEN];
	char l_exec_string[1000];
	FILE *fp_cfg = (FILE *)NULL;

		fflush(stdout);
	
	/* Kalyan -- Memset the declared strings with Null -- Start*/

	memset(l_upl_dir,APL_NULL_CHAR,sizeof(l_upl_dir));
	memset(l_upl_inp,APL_NULL_CHAR,sizeof(l_upl_inp));
	memset(l_upl_out,APL_NULL_CHAR,sizeof(l_upl_out));
	memset(l_tmp_file,APL_NULL_CHAR,sizeof(l_tmp_file));
	memset(l_exec_string,APL_NULL_CHAR,sizeof(l_exec_string));

	/* Kalyan -- Memset the declared strings with Null -- End */



	memset(l_param_data,APL_NULL_CHAR,sizeof(l_param_data));
	strcpy(l_param_data,g_param_data);

		fflush(stdout);
	strcpy(l_cfg_filename,getenv("INTL_ROOT_PATH"));
	strcat(l_cfg_filename,"/intl_sun.cfg");

	APL_FUNCTION_ENTER(l_logfile)
		fflush(stdout);
		printf("\n After Entered ...1");
	fp_cfg = fopen(l_cfg_filename,"r");
	
	if(fp_cfg == (FILE *)NULL)
	{
		BT_IF_DEBUG
			fprintf(l_logfile, "Config File |%s|\n",l_cfg_filename);
		BT_IF_DEBUG
			CO_ProcMonitor(l_logfile,"Failed To Open Config File",NULL,NULL);
		
		APL_GOBACK_FAIL
	}
	
	printf("\n After Entered ...2");
	CO_Rtv_DataString(l_param_data,"FILE_NAME",p_gfu_file_map_h -> h_file_name);
	memset(g_file_name,APL_NULL_CHAR,sizeof(g_file_name));
	strcpy(g_file_name,p_gfu_file_map_h -> h_file_name);

	memset(p_gfu_file_map_h -> h_skip_line,APL_NULL_CHAR,sizeof(p_gfu_file_map_h -> h_skip_line));
	strcpy(p_gfu_file_map_h -> h_skip_line,GFU_SKIP_LINE_DEL);
	CO_Rtv_DataString(l_param_data,"SKIP_LINE",l_skip_line);
	strcat(p_gfu_file_map_h -> h_skip_line,l_skip_line);
	strcat(p_gfu_file_map_h -> h_skip_line,GFU_SKIP_LINE_DEL);
	CO_Rtv_DataString(l_param_data,"REFNO",p_gfu_file_map_h -> h_refno);
	CO_Rtv_DataString(l_param_data,"FILE_TYPE",p_gfu_file_map_h -> h_file_type);
	CO_Rtv_DataString(l_param_data,"MODULE",p_gfu_file_map_h -> h_module);
	CO_Rtv_DataString(l_param_data,"DELIM",p_gfu_file_map_h -> h_delimiter);
	CO_Rtv_DataInt(l_param_data,"HEADER",&(p_gfu_file_map_h -> h_header));
	
	CO_Rtv_DataInt(l_param_data,"FORMAT_LINE",&(p_gfu_file_map_h -> h_format_no));
	CO_Rtv_DataString(l_param_data,"MAKER",p_gfu_file_map_h -> h_maker);
	CO_Rtv_DataString(l_param_data,"CHECKHEADER",p_gfu_file_map_h -> h_check_header);
	CO_Rtv_DataString(l_param_data,"MAKERDT",p_gfu_file_map_h -> h_maker_dt);
	CO_Rtv_DataString(l_param_data,"ACCESS_STAMP",p_gfu_file_map_h -> h_access_stamp);
	CO_Rtv_DataString(l_param_data,"VENDOR",p_gfu_file_map_h -> h_vendor);

	if ( CO_ReadToken(fp_cfg,"INTL_UPL_PATH",l_upl_dir,l_debug_info_ptr) == APL_FAILURE)
		APL_GOBACK_FAIL

	printf("\n Herereeeeeeeee............\n");
	printf("\n gouse... h_delimiter |%s|\n",p_gfu_file_map_h ->h_delimiter);

	/* Kalyan */

	if((strstr(p_gfu_file_map_h -> h_file_name,".xls")!=NULL)||(strstr(p_gfu_file_map_h -> h_file_name,".XLS")!=NULL))
	{
		memset(l_tmp_file,APL_NULL_CHAR,sizeof(l_tmp_file));
		printf("Entered the IF loop of xls file ... proceeding for conversion of XLS to CSV \n"); 
		strcpy(l_upl_inp,l_upl_dir);
		strcpy(l_upl_out,l_upl_dir);

		strcat(l_upl_inp,p_gfu_file_map_h -> h_file_name);
		strncpy(l_tmp_file,p_gfu_file_map_h -> h_file_name,strlen(p_gfu_file_map_h -> h_file_name)-3);
		printf("\n l_tmp_file=|%s|\n",l_tmp_file);
		fflush(stdout);
		strcat(l_tmp_file,"CSV");//csv to CSV changed by Gouse
		strcat(l_upl_out,l_tmp_file);

		printf(" l_upl_inp --  %s\n",l_upl_inp);
		printf(" l_tmp_file --  %s\n",l_tmp_file);
		printf(" l_upl_out --  %s\n",l_upl_out);

		printf("\n\n\n\n**************************\n\n\n");

		char l_param_str[1000]=APL_NULL_STRING;
		sprintf(l_param_str,"xlstocsv.ksh %s %s",l_upl_inp,l_upl_out);

		printf("\n l_param_str=|%s| \n",l_param_str);

		fflush(stdout);
	//	system(l_param_str); Commented By Gouse - Same has been done in UploadFile.java
		
		strcpy(p_gfu_file_map_h -> h_file_name,l_tmp_file);

		strcpy(p_gfu_file_map_h -> h_delimiter,"|"); 
	       //	strcpy(p_gfu_file_map_h -> h_delimiter,","); //Added by Gouse - 24/02/2012
	}

	/* Kalyan --Till Here */
		

	strcat(l_upl_dir,p_gfu_file_map_h -> h_file_name);
	
	BT_IF_DEBUG
	fprintf(l_logfile, "File |%s||%s|\n",l_upl_dir,p_gfu_file_map_h -> h_file_type);

	if(p_file == (FILE **)NULL)APL_GOBACK_SUCCESS;

	if(!strcmp(p_gfu_file_map_h -> h_file_type,GFU_BINARY_FILE) )
	{
		*p_file = fopen(l_upl_dir,"rb");
		l_bk_file = fopen(l_upl_dir,"rb");
	}
	else if(!strcmp(p_gfu_file_map_h -> h_file_type,GFU_ASCII_FILE) || !strcmp(p_gfu_file_map_h -> h_file_type,"P"))
	{
		*p_file = fopen(l_upl_dir,"r");
		l_bk_file = fopen(l_upl_dir,"r");
	}

	if (*p_file == (FILE *)NULL || l_bk_file == (FILE *)NULL)
	{
		
		printf("Failed To Open file|%s|\n",p_gfu_file_map_h -> h_file_name);
		APL_GOBACK_FAIL
	}
	APL_GOBACK_SUCCESS

RETURN_FAILURE:
	if(fp_cfg != (FILE *)NULL)fclose(fp_cfg);
	APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	if(fp_cfg != (FILE *)NULL)fclose(fp_cfg);
	APL_FUNCTION_RET_SUCCESS(l_logfile)

}



/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Rtv_ReqMap																 *
 *                                                                                                       *
 * Description           : This Function is used to retrive request details, wrapper,sp name etc.		 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_module							   char *							I	   Module name				 *
 *																										 *
 * p_gfu_file_map_h					   GFU_REQ_MAP_STRUCT_H *			O	   Request Details			 *
 *																										 *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/


int GFU_Rtv_ReqMap(	char *p_module, 
					GFU_REQ_MAP_STRUCT_H *p_gfu_req_map_h,
					DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	struct sqlca sqlca;

	APL_FUNCTION_ENTER(l_logfile)
	GFU_REQ_MAP_STRUCT_I *l_gfu_req_map_i = (GFU_REQ_MAP_STRUCT_I *)NULL;
	l_gfu_req_map_i = (GFU_REQ_MAP_STRUCT_I *)calloc(1,sizeof(GFU_REQ_MAP_STRUCT_I));
	EXEC SQL SELECT GFREQMAP.*
				INTO :p_gfu_req_map_h:l_gfu_req_map_i
				FROM GFREQMAP
				WHERE MODULE = :p_module;

	IS_ANY_ORA_ERROR

APL_GOBACK_SUCCESS
RETURN_FAILURE:
	APL_FREE(l_gfu_req_map_i);
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FREE(l_gfu_req_map_i);
	APL_FUNCTION_RET_SUCCESS(l_logfile)

}


/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Rtv_Env																 *
 *                                                                                                       *
 * Description           : This Function is used to get details for environment string					 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_module							   char *							I	   Module Name				 *
 *																										 *
 * p_gfu_val_map_lst				   GFU_TOKEN_VAL_STRUCT_LST **		O	   list with details		 *
 *																									     *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/




int GFU_Rtv_Env(	char *p_module,
					GFU_TOKEN_VAL_STRUCT_LST **p_gfu_val_map_lst,
					DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	pid_t l_myid; // Kalyan 
	char  l_userid[15];
	struct sqlca sqlca;
	GFU_TOKEN_VAL_STRUCT_LST **l_temp_ptr = p_gfu_val_map_lst;
	GFU_ENV_MAP_STRUCT_I		*l_gfu_env_map_i = (GFU_ENV_MAP_STRUCT_I *)NULL;
	GFU_ENV_MAP_STRUCT_H		*l_gfu_env_map_h =(GFU_ENV_MAP_STRUCT_H *)NULL;

	APL_FUNCTION_ENTER(l_logfile)

	l_myid=getpid(); //Kalyan

	printf("\nKS -- Fetched pid is --- [%d] \n",l_myid);
	
	printf("\n\n =========================== \n\n");
	printf("Module Is :|%s|\n",p_module);
	fflush(stdout);
	Alert("sqlcacode : %d\n",sqlca.sqlcode);
	EXEC SQL DECLARE l_cur_env_map CURSOR FOR
			SELECT GFENVMAP.*
			FROM GFENVMAP
			WHERE MODULE = :p_module;
			Alert("sqlcacode : %d\n",sqlca.sqlcode);
	IS_ANY_ORA_ERROR

	EXEC SQL OPEN l_cur_env_map;
	Alert("sqlcacode : %d\n",sqlca.sqlcode);
	IS_ANY_ORA_ERROR

	l_gfu_env_map_h = (GFU_ENV_MAP_STRUCT_H *)calloc(1,sizeof(GFU_ENV_MAP_STRUCT_H));
	l_gfu_env_map_i = (GFU_ENV_MAP_STRUCT_I *)calloc(1,sizeof(GFU_ENV_MAP_STRUCT_I));	

	for(;;)
	{
		memset(l_gfu_env_map_h,NULL,sizeof(l_gfu_env_map_h));
		memset(l_gfu_env_map_i,NULL,sizeof(l_gfu_env_map_i));
		
		EXEC SQL FETCH l_cur_env_map
					INTO :l_gfu_env_map_h:l_gfu_env_map_i;
		Alert("sqlcacode : %d\n",sqlca.sqlcode);
		if(sqlca.sqlcode == 1403)break;
		IS_ANY_ORA_ERROR
		
		/* Kalyan -- Dynamically fetch the User Id */

		printf("l_gfu_env_map_h->h_token :|%s|\n",l_gfu_env_map_h->h_token);
		fflush(stdout);
		
		if( strcmp(l_gfu_env_map_h->h_token,"USER")==0)
		{    /* retro by Tanuja for KOTAK start */
                     IF_COND_EXISTS("WI_GF_UPLOAD","PROCESS_NAME")
                     {
			EXEC SQL SELECT 
					USR 
				 INTO
					:l_userid
					//l_gfu_env_map_h->h_value
				 FROM
					SYS_BATCHPROC
				 WHERE
					PROCESS_NAME='WI_GF_Upload' AND
					STATUS='started' AND
					PROC_ID=:l_myid;
                     }
                     else
                     { /* retro by Tanuja for KOTAK end */
			EXEC SQL SELECT USR INTO :l_userid
				FROM SYS_BATCHPROC
				WHERE PROCESS_NAME='WEB_GF_Upload' AND
				  STATUS='started' AND 
			      PROC_ID=:l_myid;
                     }
			IS_ANY_ORA_ERROR
	
			if(strlen(l_userid)>0)
			{
				strcpy(l_gfu_env_map_h->h_value,l_userid);
			}
		}

		/* Kalyan Dynamically fetch the User Id -- Till Here */

		printf("l_gfu_env_map_h->h_value :|%s|\n",l_gfu_env_map_h->h_value);
		fflush(stdout);


		while((*l_temp_ptr) != (GFU_TOKEN_VAL_STRUCT_LST *)NULL)
		{
			l_temp_ptr = &((*l_temp_ptr)->h_next);
		}
		if(((*l_temp_ptr) = (GFU_TOKEN_VAL_STRUCT_LST *)calloc(1,sizeof(GFU_TOKEN_VAL_STRUCT_LST))) == NULL)
		{
			APL_GOBACK_FAIL
		}
		strcpy((*l_temp_ptr) -> h_token, l_gfu_env_map_h -> h_token);
		Remove_Last_Char(l_gfu_env_map_h -> h_value,GF_DELIM_STR_SPACE,l_debug_info_ptr);
		strcpy((*l_temp_ptr) -> h_value, l_gfu_env_map_h -> h_value);

		printf("\n\n =========================== \n\n");
	}
	EXEC SQL CLOSE l_cur_env_map;
APL_GOBACK_SUCCESS
RETURN_FAILURE:
	APL_FREE(l_gfu_env_map_h);
	APL_FREE(l_gfu_env_map_i);
	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	APL_FREE(l_gfu_env_map_h);
	APL_FREE(l_gfu_env_map_i);
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}


/*********************************************************************************************************
 *                                                                                                       *
 * Function Name         : GFU_Process_File																 *
 *                                                                                                       *
 * Description           : This Function is used to Process The file									 *
 *                                                                                                       *
 * Parameter                           Type                             Mode   Description               *
 * ------------                        --------                         -----  ---------------           *
 *																										 *
 * p_process_name					   char *							I      Name of the process		 *
 *																									     *
 * p_process_key					   char *							I      Key of the Process		 *
 *																										 *
 * p_start_date						   char *							I	   Started Date				 *
 *																										 *
 * l_debug_info_ptr                    DEBUG_INFO_STRUCT_H **           I      Debug Info Structure      *
 *                                                                                                       *
 * Return Values        :                                                                                *
 *                                                                                                       *
 *  APL_SUCCESS  - SUCCESS                                                                               *
 *  APL_FAILURE  - FAILURE                                                                               *
 *                                                                                                       *
 ********************************************************************************************************/




int GFU_Process_File(	char *p_process_name,
			char *p_process_key,
			char *p_start_date,
			char *p_user,
			FILE *p_file,
			DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{

	/**FILE *l_file = p_file;**/
	/**GFU_FILE_MAP_STRUCT_H *g_gfu_file_map_h = (GFU_FILE_MAP_STRUCT_H *)NULL;**/
	/**GFU_FILE_LST **l_file_lst = (GFU_FILE_LST **)NULL;**/
	GFU_VAL_MAP_STRUCT_LST **l_gfu_val_map_lst = (GFU_VAL_MAP_STRUCT_LST **)NULL;
	GFU_REQ_MAP_STRUCT_H *l_gfu_req_map_h = (GFU_REQ_MAP_STRUCT_H *)NULL;
	GFU_TOKEN_VAL_STRUCT_LST **l_gfu_env_map_lst = (GFU_TOKEN_VAL_STRUCT_LST **)NULL;

	/* Added By Kalyan on 28/05/2007 for Report File format Changes -- Start*/

	int l_int_num=0,l_loopcnt=0;
	char **temp;

	/* Added By Kalyan on 28/05/2007 for Report File format Changes -- End*/

		
	/** Free............... **/
	GFU_VAL_MAP_STRUCT_LST *l_gfu_val_map_free = (GFU_VAL_MAP_STRUCT_LST *)NULL;
	GFU_TOKEN_VAL_STRUCT_LST *l_gfu_env_map_free = (GFU_TOKEN_VAL_STRUCT_LST *)NULL;
	GFU_FILE_LST *l_file_free = (GFU_FILE_LST *)NULL;
	GFU_TOKEN_VAL_STRUCT_LST *l_token_val_free = (GFU_TOKEN_VAL_STRUCT_LST *)NULL;

	/** Free............... **/

	/**g_gfu_file_map_h = (GFU_FILE_MAP_STRUCT_H *)calloc(1,sizeof(GFU_FILE_MAP_STRUCT_H));**/
	/**l_file_lst = (GFU_FILE_LST **)calloc(1,sizeof(GFU_FILE_LST *));	**/
	l_gfu_val_map_lst = (GFU_VAL_MAP_STRUCT_LST **)calloc(1,sizeof(GFU_VAL_MAP_STRUCT_LST *));
	l_gfu_env_map_lst = (GFU_TOKEN_VAL_STRUCT_LST **)calloc(1,sizeof(GFU_TOKEN_VAL_STRUCT_LST *));
	l_gfu_req_map_h = (GFU_REQ_MAP_STRUCT_H *)calloc(1,sizeof(GFU_REQ_MAP_STRUCT_H));

	APL_FUNCTION_ENTER(l_logfile)

	/**if(APL_FAILURE == GFU_Rtv_File(	g_gfu_file_map_h,
					&l_file,
					l_debug_info_ptr))
	{
		printf("Failed in GFU_Rtv_File\n");
		APL_GOBACK_FAIL
	}*/
	if(APL_FAILURE == GFU_Rtv_ReqMap(	g_gfu_file_map_h -> h_module,
						l_gfu_req_map_h,
						l_debug_info_ptr))
	{
		printf("Failed in GFU_Rtv_ReqMap\n");
		APL_GOBACK_FAIL
	}
	/* Added By Kalyan on 28/05/2007 for Report File format Changes -- Start*/
	fprintf(l_userfile,"=====================================================================================================================\n");
	//fprintf(l_userfile,"%s\t%s\t%-70s%-10s\t%s\n","LINE","SKIPPED",l_gfu_req_map_h->h_rep_label,"STATUS","REASON");

	//fprintf(l_userfile,"%s\t%s\t%-70s%-10s\t%s\n","LINE","SKIPPED",l_gfu_req_map_h->h_rep_label,"STATUS","REASON");
	fprintf(l_userfile,"%s\t%s\t","LINE","SKIPPED");

        if(APL_FAILURE == CO_SplitStr(l_gfu_req_map_h->h_rep_label, '|', &l_int_num, &temp))
        {
        	printf("Failure from first CO_SplitStr with seperator as | \n");
                APL_GOBACK_FAIL
        }

        for(l_loopcnt=0;l_loopcnt<l_int_num;l_loopcnt++)
        {
		printf("KS -- Label %d Selected is - [%s]\n",l_loopcnt,temp[l_loopcnt]);
		if(strcmp(temp[l_loopcnt],"IDENTIY_NO")==0)
		{
			fprintf(l_userfile,"%-30s","REFERENCE NO.");
		}
		else if(strcmp(temp[l_loopcnt],"CLIENT")==0)
		{
			fprintf(l_userfile,"%-30s","CLIENT CODE");
		}
		else
		{
			fprintf(l_userfile,"%-30s",temp[l_loopcnt]);
		}
	}
	fprintf(l_userfile,"%-10s\t%s\n","STATUS","REASON");

	fprintf(l_userfile,"=====================================================================================================================\n");

	/* Added By Kalyan on 28/05/2007 for Report File format Changes -- End*/
	if(APL_FAILURE == GFU_Rtv_Env(	g_gfu_file_map_h -> h_module,
					l_gfu_env_map_lst,
						l_debug_info_ptr))
	{
		printf("Failed in GFU_Rtv_Env\n");
		APL_GOBACK_FAIL
	}
	if(APL_FAILURE == GFU_Conv_Lnk_Lst(	p_file,
						p_process_name,
						p_process_key,
						p_start_date,
						g_gfu_file_map_h,
					l_gfu_env_map_lst,
						l_gfu_val_map_lst,
						l_gfu_req_map_h,
					l_debug_info_ptr))
	{
		printf("Failed in GFU_Conv_Lnk_Lst\n");
		APL_GOBACK_FAIL
	}




	/**if(APL_FAILURE ==  GFU_Process_Lst(l_file_lst,
					p_process_name,
					p_process_key,
					p_start_date,
					l_gfu_val_map_lst,
					l_gfu_req_map_h,
					l_gfu_env_map_lst,
					l_debug_info_ptr))
	{
		printf("Failed in GFU_Process_Lst\n");
		APL_GOBACK_FAIL
	}
	**/

	if( GFU_Summ_Rpt( p_start_date,
							p_process_name,
							p_user,
							l_userfile,
							l_logfile,
							l_skipped_file,
							l_format_file,
							g_gfu_file_map_h -> h_module,
							l_debug_info_ptr) == APL_FAILURE)
	{
		CO_ProcMonitor(l_logfile,"Failed in GFU_Summ_Rpt",NULL,NULL);
		APL_GOBACK_FAIL
	}	

APL_GOBACK_SUCCESS
RETURN_FAILURE:
	/**if(l_file != (FILE *)NULL)fclose(l_file);**/
	
	
	/**APL_FREE(g_gfu_file_map_h)**/
	APL_FREE(l_gfu_req_map_h)

        while(*l_gfu_val_map_lst)
        {
                l_gfu_val_map_free = (*l_gfu_val_map_lst) -> h_next;
                APL_FREE((*l_gfu_val_map_lst));
                (*l_gfu_val_map_lst) = l_gfu_val_map_free;
        }

        while(*l_gfu_env_map_lst)
        {
                l_gfu_env_map_free = (*l_gfu_env_map_lst) -> h_next;
                APL_FREE((*l_gfu_env_map_lst));
                (*l_gfu_env_map_lst) = l_gfu_env_map_free;
        }
/**
		while(*l_file_lst)
        {
                l_file_free = (*l_file_lst) -> h_next;
				
				while((*((*l_file_lst) -> h_token_val)))
				{
					l_token_val_free = (*((*l_file_lst) -> h_token_val)) -> h_next;
					APL_FREE((*((*l_file_lst) -> h_token_val)))
					(*((*l_file_lst) -> h_token_val)) =  l_token_val_free;
				}
                APL_FREE((*l_file_lst));
                (*l_file_lst) = l_file_free;
        }
	
**/

	 APL_FUNCTION_RET_FAILURE(l_logfile)

RETURN_SUCCESS:
	/**if(l_file != (FILE *)NULL)fclose(l_file);**/

/**	APL_FREE(l_gfu_file_map_h)**/
  	APL_FREE(l_gfu_req_map_h)
        while(*l_gfu_val_map_lst)
        {
                l_gfu_val_map_free = (*l_gfu_val_map_lst) -> h_next;
                APL_FREE((*l_gfu_val_map_lst));
                (*l_gfu_val_map_lst) = l_gfu_val_map_free;
        }

        while(*l_gfu_env_map_lst)
        {
                l_gfu_env_map_free = (*l_gfu_env_map_lst) -> h_next;
                APL_FREE((*l_gfu_env_map_lst));
                (*l_gfu_env_map_lst) = l_gfu_env_map_free;
        }
/**
		while(*l_file_lst)
        {
                l_file_free = (*l_file_lst) -> h_next;
				
				while((*((*l_file_lst) -> h_token_val)))
				{
					l_token_val_free = (*((*l_file_lst) -> h_token_val)) -> h_next;
					APL_FREE((*((*l_file_lst) -> h_token_val)))
					(*((*l_file_lst) -> h_token_val)) =  l_token_val_free;
				}
                APL_FREE((*l_file_lst));
                (*l_file_lst) = l_file_free;
        }
**/
	APL_FUNCTION_RET_SUCCESS(l_logfile)
}




int main(int argc,char **argv)
{

	/********** Web Custody Single Login Changes : Vinay Kalaskar *********/

	char *chr_webdata;
	char g_proc_data[4001] = APL_NULL_STRING;
	char p_web_data[4001] = APL_NULL_STRING;

	/**********************************************************************/

	struct sqlca sqlca;
	int i = 0;

	FILE *chr_finifile;
	/**GFU_FILE_MAP_STRUCT_H l_gfu_file_map_h;**/
	/* Increased the size of User Id for Web Intellect Encryption - Decryption Changes - NarenV */
	char chr_inifile[150],chr_l_uname[APL_USERID_LEN+20],chr_l_passwd[APL_PASSWD_LEN],chr_custody_id_b[APL_USERID_LEN],chr_buffer[KEY_LENGTH];
	DEBUG_INFO_STRUCT_H	**l_debug_info_ptr = (DEBUG_INFO_STRUCT_H **)NULL;
	INTL_ENV_DATA_STRUCT_H  l_intl_envdatastruct_h;
	char l_rep_name[14]  = APL_NULL_STRING;
	FILE *l_file = (FILE *)NULL;

	APL_FUNCTION_ENTER(APL_OUT_FILE)
	l_debug_info_ptr = (DEBUG_INFO_STRUCT_H	**)calloc(1,sizeof(DEBUG_INFO_STRUCT_H	*));

	fprintf(APL_OUT_FILE,"\n\n\n**********************Enters the Great GFU************************\n");
	MAIN_ARG



	memset(g_param_data,APL_NULL_CHAR,sizeof(g_param_data));
	strcpy(g_param_data,argv[9]);

	   memset(chr_inifile,APL_NULL_CHAR,150);
   memset(chr_buffer,APL_NULL_CHAR,KEY_LENGTH);
   memset(chr_l_uname,APL_NULL_CHAR,40);
   memset(chr_l_passwd,APL_NULL_CHAR,40);



	/********** Web Custody Single Login Changes : Vinay Kalaskar *********/

	strcpy(g_proc_data,argv[9]);
	
	printf("\n\n=== Displaying PROC_DATA ====== :|%s|\n",g_proc_data);
	fflush(stdout);

    strcpy(p_web_data,strtok_r(g_proc_data,WEB_INDICATOR,&chr_webdata));

	if(chr_webdata != NULL)
	{
		strcpy(g_custody_web_ind,"W");
	    printf("=== System Running As Web : |%s|\n\n",g_custody_web_ind);
	}
    else
	{
		strcpy(g_custody_web_ind,"C");
	    printf("=== System Running As Custody : |%s|\n\n",g_custody_web_ind);
	}


	/**********************************************************************/


	strcpy(chr_inifile,getenv("INTL_ROOT_PATH"));
	strcat(chr_inifile,"/intl_sun.cfg");
	fflush(stdout);


	if ( (chr_finifile = fopen(chr_inifile,"r") ) == NULL)
	APL_GOBACK_FAIL;

	fflush(stdout);

	strcpy(g_sys_date,argv[2]);


	/* if ( CO_ReadToken(chr_finifile,"WEB_INTL_DB_USR",chr_l_uname,l_debug_info_ptr) == APL_FAILURE)
	{
			printf("KS --- Could not find DB username \n EXITING \n FAILED IN GF_Upload");
	APL_GOBACK_FAIL
	}
	if ( CO_ReadToken(chr_finifile,"WEB_INTL_DB_PWD",chr_l_passwd,l_debug_info_ptr) == APL_FAILURE)
	{
			printf("KS --- Could not find DB password \n EXITING \n FAILED IN GF_Upload");
	APL_GOBACK_FAIL
	} *** Commented for Web Intellect Encryption - Decryption Changes **** Naren V */

	
	/** Web Intellect Encryption - Decryption Changes - Start - Naren V **/

	/* Calling Web Custody Login Details */
	APL_FETCH_DB_LOGIN_DETAILS(chr_finifile, "W", chr_l_uname, chr_l_passwd , APL_OUT_FILE , l_debug_info_ptr)

	if ( !strlen(chr_l_uname) )
	{
		CO_ProcMonitor(APL_OUT_FILE,"\n Could not find Web Int DB username \n EXITING \n FAILED IN GF_Upload",NULL,NULL);
		APL_GOBACK_FAIL
	}

	if ( !strlen(chr_l_passwd) )
	{
		CO_ProcMonitor(APL_OUT_FILE,"\n Could not find Web Int DB password \n EXITING \n FAILED IN GF_Upload",NULL,NULL);
		APL_GOBACK_FAIL
	}
	/** Web Intellect Encryption - Decryption Changes - End   - Naren V **/


    EXEC SQL CONNECT :chr_l_uname IDENTIFIED BY :chr_l_passwd;

	g_gfu_file_map_h = (GFU_FILE_MAP_STRUCT_H *)calloc(1,sizeof(GFU_FILE_MAP_STRUCT_H));

	if( GFU_Rtv_File( g_gfu_file_map_h,
				&l_file,
				l_debug_info_ptr) == APL_FAILURE)
	{
		APL_GOBACK_FAIL
	}

	strcpy(l_rep_name,"GF_");
	strncat(l_rep_name,g_gfu_file_map_h -> h_refno,10);
	strcat(l_rep_name,APL_NULL_STRING);
	l_rep_name[14] = APL_NULL_CHAR;
	if ( CO_Rtv_RptFileName(l_rep_name,
                                "Technical Log",
                                100,
                                argv[5],
                                argv,
                                &l_logfile,
                                l_debug_info_ptr) == APL_FAILURE)
       {
               CO_ProcMonitor(l_logfile,"Failed in CO_Rtv_RptFileName",NULL,NULL);
	       APL_GOBACK_FAIL
       }

	sleep(1);
	if ( CO_Rtv_RptFileName(l_rep_name,
                                "Skipped/Error Lines",
                                500,
                                argv[5],
                                argv,
                                &l_skipped_file,
                                l_debug_info_ptr) == APL_FAILURE)
       {
               CO_ProcMonitor(l_logfile,"Failed in CO_Rtv_RptFileName",NULL,NULL);
	       APL_GOBACK_FAIL
       }
	sleep(1);
	if ( CO_Rtv_RptFileName(l_rep_name,
                                "User Log",
                                500,
                                argv[5],
                                argv,
                                &l_userfile,
                                l_debug_info_ptr) == APL_FAILURE)
       {
               CO_ProcMonitor(l_logfile,"Failed in CO_Rtv_RptFileName",NULL,NULL);
	       APL_GOBACK_FAIL
       }
BT_IF_DEBUG
	CO_ProcMonitor(l_userfile,"Processing Started",NULL,NULL);
BT_IF_DEBUG
       /*fprintf(l_userfile,"%s\t%s\t%8s\t%s\n","LINE","SKIPPED","STATUS","REASON");Commented By Kalyan */
		//fprintf(l_userfile,"%s\t%s\t%s\t\t%s\t\t\t%s\t%s\n","LINE","SKIPPED","TOKEN","VALUE","STATUS","REASON");
		/* Commented on 28/5/2007 For report file Formatting 
		fprintf(l_userfile,"=====================================================================================================================\n");
		fprintf(l_userfile,"%s\t%s\t%-30s%-40s%-10s\t%s\n","LINE","SKIPPED","TOKEN","VALUE","STATUS","REASON");
		fprintf(l_userfile,"=====================================================================================================================\n"); */
	sleep(1);

	
	if ( CO_Rtv_RptFileName(l_rep_name,
                                "Format File",
                                100,
                                argv[5],
                                argv,
                                &l_format_file,
                                l_debug_info_ptr) == APL_FAILURE)
       {
               CO_ProcMonitor(l_logfile,"Failed in CO_Rtv_RptFileName",NULL,NULL);
	       APL_GOBACK_FAIL
       }
BT_IF_DEBUG
	fprintf(l_format_file,"\t%s\t%s\t%s\t%s\n","HEADER","SEQ","START","END");
BT_IF_DEBUG
	CO_ProcMonitor(l_logfile,"Got the Report",NULL,NULL);

BT_IF_DEBUG
	CO_ProcMonitor(APL_OUT_FILE,"Got The Connection !!!",NULL,NULL);
	if(APL_FAILURE == BT_Status_Lock(	argv[0],
			argv[1],
			argv[2],
			l_debug_info_ptr))
	{
		
		APL_GOBACK_FAIL
	}


	for( i = 0; i<argc ; i++)
	{
		fprintf(APL_OUT_FILE,"Arguement %d |%s|\n",i,argv[i]);
	}
   if ( CO_RtvSysParams(l_debug_info_ptr) == APL_FAILURE)
	      APL_GOBACK_FAIL

      
	if(APL_FAILURE == GFU_Process_File( argv[0],argv[1],argv[2],argv[5] ,l_file,l_debug_info_ptr))
	{
               CO_ProcMonitor(l_logfile,"Failed in GFU_Process_File",NULL,NULL);
	       APL_GOBACK_FAIL
	}

	

RETURN_SUCCESS  :

BT_IF_DEBUG
	fprintf(l_userfile,"=====================================================================================================================\n");
	CO_ProcMonitor(l_userfile,"Processing Ended Successfully",NULL,NULL);
	APL_CLOSE_FILE(l_logfile);
	APL_CLOSE_FILE(l_skipped_file);
	APL_CLOSE_FILE(l_userfile);
	APL_CLOSE_FILE(l_format_file);
	APL_CLOSE_FILE(chr_finifile);
	APL_CLOSE_FILE(l_file);
	if(l_bk_file!= (FILE *)NULL)fclose(l_bk_file);
	fprintf(APL_OUT_FILE,"\n**********************Yep! AS Your Wish!!!************************");

	if(APL_FAILURE == BT_Status_Completed(	argv[0], 
						argv[1],
						argv[2],
						l_debug_info_ptr))
		APL_GOBACK_FAIL

	EXEC SQL COMMIT;
	IS_ANY_ORA_ERROR
        return(0);
    
RETURN_FAILURE  :
BT_IF_DEBUG
	fprintf(l_userfile,"=====================================================================================================================\n");
	CO_ProcMonitor(l_userfile,"Processing Ended in Failure",NULL,NULL);
	APL_CLOSE_FILE(l_logfile);
	APL_CLOSE_FILE(l_skipped_file);
	APL_CLOSE_FILE(l_userfile);
	APL_CLOSE_FILE(l_format_file);
	APL_CLOSE_FILE(l_bk_file);
	APL_CLOSE_FILE(chr_finifile);
	APL_CLOSE_FILE(l_file);
	CO_ProcMonitor(APL_OUT_FILE,"\nOoops! Its Failure!!!\n",l_debug_info_ptr,NULL);
       system("date");
       EXEC SQL COMMIT;
       return(-1);

}
