/*
 *    COPYRIGHT NOTICE
 *
 *   Copyright 2005 Polaris Software Lab Limited. All rights reserved.
 *
 *   These materials are confidential and proprietary to
 *    Polaris Software Lab Limited and no part of these materials should
 *    be reproduced, published, transmitted or distributed in any form or
 *    by any means, electronic, mechanical, photocopying, recording or
 *    otherwise, or stored in any information storage or retrieval system
 *    of any nature nor should the materials be disclosed to third parties
 *    or used in any other manner for which this is not authorized, without
 *    the prior express written authorization of Polaris Software Lab Limited.
*/
/*********************************************************************
 *
 * Module Name         :      Master Maintenance
 *
 * File Name           :      MT_UpdDL_TAKEOVER.pc
 *
 * Description         :      This file contains db functions for updating
 *                            Master Details.
 *
 *
 *            Version Control Block
 *
 * Date        Version     Author         Description       RFS No.
 * ---------   --------  ------------     -------------     ---------
 * 23/01/2006   1.0       Sonal        New file       HDFCDL_025
 *
 *********************************************************************/

#include "CO_HostStructdef.h"
EXEC SQL INCLUDE SQLCA.H;



int MT_ModDbDL_TAKEOVER(DL_TAKEOVER_STRUCT_H *p_dl_takeover_struct_h,DL_TAKEOVER_SEQ_STRUCT_H *p_dl_takeover_seq_struct_h,INTL_ENV_DATA_STRUCT_H *p_intl_envdatastruct_h,DEBUG_INFO_STRUCT_H **l_debug_info_ptr)
{
	
	/* Variable Declarations */
  DL_TAKEOVER_STRUCT_I *l_dl_takeover_struct_i;
  DL_TAKEOVER_SEQ_STRUCT_I *l_dl_takeover_seq_struct_i; 
  
  struct sqlca sqlca;
  MT_INSTRUMENT_STRUCT_H * mt_instrument_struct_h;
  MT_CORE_SYS_PARAMS_STRUCT_H *mt_core_sys_params_struct_h;
  SYS_DL_DEAL_STRUCT_H *p_dl_deal_struct_h;
  SYS_DL_DEAL_STRUCT_H *p_dl_deal_struct_h1;
  SYS_DL_DEAL_STRUCT_I *p_dl_deal_struct_i;  	
  int int_return;
  int int_h_trdrepseqnum=0;
  char chr_acc_stamp_compare[APL_DATE_LEN] = APL_NULL_STRING;
  char  chr_ref_no_compare[APL_DATE_LEN] = APL_NULL_STRING;
  char chr_status_compare[APL_STATUS_LEN] = APL_NULL_STRING;
  char chr_sys_access_stamp[APL_DATE_LEN] = APL_NULL_STRING;
  char chr_sys_date[APL_DATE_LEN]=APL_NULL_STRING;
  short p_i_maker, p_i_makerdt, p_i_checker, p_i_checkerdt, p_i_access_stamp;
  short p_i_access_stamp_compare;
  short p_i_status = 0;
  int int_error_flag = APL_SUCCESS;
  int int_l_rowexists = 0;
  char *l_key_codes[8];
  char *l_key_values[8];
  char chr_l_table_name[50] = APL_NULL_STRING;
  char chr_l_field_val[40] = APL_NULL_STRING;
  char self[7];
  int  int_rfdeals;
  int  int_retval = APL_SUCCESS;
  char p_cln_code[40] = APL_NULL_STRING;
  char p_ref_no[40] = APL_NULL_STRING;
  char l_clncode[11] =  APL_NULL_STRING;
  char l_clncode_sf[11] =  APL_NULL_STRING;
  double l_safekeep_qty = 0;
  double l_qty = 0;
  short i_clncode = 0;
  short i_clncode_sf = 0;
  short i_safekeep_qty = 0;
  short i_qty = 0;
  char l_sequence[10] = APL_NULL_STRING;
  /*
  char nmatch[4000] = APL_NULL_STRING;
*/
    short l_count = 0;
	
	#ifdef APL_THREADS
   	 APL_SET_CONTEXT
    	EXEC SQL CONTEXT USE :my_ctx_local;
	#endif

	 APL_FUNCTION_ENTER(APL_OUT_FILE);

	p_dl_deal_struct_h1 = (SYS_DL_DEAL_STRUCT_H *) calloc (1,sizeof(SYS_DL_DEAL_STRUCT_H));  
  	p_dl_deal_struct_h =(SYS_DL_DEAL_STRUCT_H *) calloc(1,sizeof(SYS_DL_DEAL_STRUCT_H));
  	p_dl_deal_struct_i =(SYS_DL_DEAL_STRUCT_I *) calloc(1,sizeof(SYS_DL_DEAL_STRUCT_I));  
  	l_dl_takeover_struct_i=(DL_TAKEOVER_STRUCT_I *)calloc(1,sizeof(DL_TAKEOVER_STRUCT_I));
  	mt_instrument_struct_h=(MT_INSTRUMENT_STRUCT_H *)calloc(1,sizeof(MT_INSTRUMENT_STRUCT_H)); 
  	l_dl_takeover_seq_struct_i = (DL_TAKEOVER_SEQ_STRUCT_I *)calloc(1,sizeof(DL_TAKEOVER_SEQ_STRUCT_I));  
  	mt_core_sys_params_struct_h =(MT_CORE_SYS_PARAMS_STRUCT_H *) calloc(1,sizeof(MT_CORE_SYS_PARAMS_STRUCT_H));
	APL_MALLOC_FAIL(p_dl_deal_struct_h1);
  	APL_MALLOC_FAIL(l_dl_takeover_struct_i);
  	APL_MALLOC_FAIL(p_dl_takeover_seq_struct_h);
  	APL_MALLOC_FAIL(l_dl_takeover_seq_struct_i);
  	APL_MALLOC_FAIL(p_dl_deal_struct_h);
  	APL_MALLOC_FAIL(p_dl_deal_struct_i);
  	APL_MALLOC_FAIL(mt_instrument_struct_h);
  	APL_MALLOC_FAIL(mt_core_sys_params_struct_h);

	memset(p_dl_deal_struct_h1, NULL, sizeof(SYS_DL_DEAL_STRUCT_H));
	memset(p_dl_deal_struct_h, NULL, sizeof(SYS_DL_DEAL_STRUCT_H));
	memset(p_dl_deal_struct_i, NULL, sizeof(SYS_DL_DEAL_STRUCT_I));
	memset(l_dl_takeover_struct_i, NULL, sizeof(DL_TAKEOVER_STRUCT_I));
	memset(mt_instrument_struct_h, NULL, sizeof(MT_INSTRUMENT_STRUCT_H));
	memset(l_dl_takeover_seq_struct_i, NULL, sizeof(DL_TAKEOVER_SEQ_STRUCT_I));
	memset(mt_core_sys_params_struct_h, NULL, sizeof(MT_CORE_SYS_PARAMS_STRUCT_H));


  	p_i_maker =0;
  	p_i_makerdt =0;
  	p_i_checker =0;
  	p_i_checkerdt =0;
  	p_i_access_stamp =0;
  	p_i_access_stamp_compare =0;

	/***************************************************************************************/
	/*
		EXEC SQL BEGIN DECLARE SECTION;

		EXEC SQL VAR p_dl_takeover_struct_h->h_instr_cd IS STRING;
		EXEC SQL VAR p_dl_takeover_struct_h -> h_ref_no IS STRING;
		EXEC SQL VAR p_dl_takeover_struct_h -> h_depository IS STRING;
		EXEC SQL VAR p_dl_takeover_struct_h -> h_status IS STRING;
		EXEC SQL VAR p_dl_takeover_struct_h -> h_comments IS STRING;
		EXEC SQL VAR p_dl_takeover_struct_h->h_instr_cd IS STRING;
		EXEC SQL VAR p_dl_takeover_struct_h->h_instr_cd IS STRING;
		EXEC SQL VAR p_dl_takeover_struct_h->h_instr_cd IS STRING;


		EXEC SQL END DECLARE SECTION;
		*/
	EXEC SQL VAR p_dl_takeover_struct_h->h_ref_no IS STRING;


	printf("\nin function MT_ModDbDL_TAKEOVER\n");
	/*
  	printf("\n The start of the function p_dl_takeover_struct_h-> h_ref_no=%s\n",p_dl_takeover_struct_h-> h_ref_no);
	*/
	if (strcmp(p_intl_envdatastruct_h->h_process,"U"))   /* Upload Takeover - [Retrofit HDFC] */
	{
 	if (!strlen(p_dl_takeover_struct_h-> h_ref_no)) l_dl_takeover_struct_i->i_ref_no =-1;
    else l_dl_takeover_struct_i->i_ref_no =0;
	}
 
 	if(p_dl_takeover_struct_h->h_qty==0)
		l_dl_takeover_struct_i->i_qty=-1;
  	else
	 	l_dl_takeover_struct_i->i_qty=0; 

		if(p_dl_takeover_struct_h->h_takeover_qty==0)
		l_dl_takeover_struct_i->i_takeover_qty=-1;
  	else
	 	l_dl_takeover_struct_i->i_takeover_qty=0; 

	
  	printf("\nMANDATORY VALIDATIONS\n");																																		    
	printf("\nserial no is |%s|\n",p_dl_takeover_struct_h->h_serial_no);
	printf("\np_dl_takeover_struct_h->h_takeover_qty=|%lf|n",p_dl_takeover_struct_h->h_takeover_qty);
	printf("\np_dl_takeover_struct_h->h_depository=|%s|\n",p_dl_takeover_struct_h->h_depository);
	printf("\np_dl_takeover_struct_h->h_instr_cd=|%s|\n",p_dl_takeover_struct_h->h_instr_cd);
	printf("\np_dl_takeover_struct_h->h_qty=|%lf|\n",p_dl_takeover_struct_h->h_qty);
	
 	if(CO_RtvSysDtTime(chr_sys_access_stamp,l_debug_info_ptr) !=APL_SUCCESS)
		{
			APL_GOBACK_FAIL
		}

	/*
	printf("\n I have even completed insert %s\n",p_intl_envdatastruct_h->h_mode);	
	*/
	/* Upload Takeover - [Retrofit HDFC] Start */
	if (!strcmp(p_intl_envdatastruct_h->h_process,"U"))     
	{ 
		EXEC SQL SELECT count(*) into :l_count FROM dl_takeover_seq
			where CLN_CODE = :p_dl_takeover_seq_struct_h->h_cln_code;

		IS_ANY_ORA_ERROR
			printf("\n UPLOAD - count is |%d|\n",l_count);
		if(l_count == 1)
		{
			EXEC SQL SELECT REF_NO into :p_dl_takeover_seq_struct_h->h_ref_no FROM DL_TAKEOVER_SEQ
				WHERE CLN_CODE = :p_dl_takeover_seq_struct_h->h_cln_code;

			IS_ANY_ORA_ERROR
		}
		else
		{
			EXEC SQL SELECT :p_dl_takeover_seq_struct_h->h_cln_code ||  DL_TAKEOVERSEQ.NEXTVAL into :p_dl_takeover_seq_struct_h->h_ref_no FROM DUAL; //Modified by Sunny for removing underscore
	
			IS_ANY_ORA_ERROR
		}
		printf("\n UPLOAD - ref no is |%s|\n",p_dl_takeover_seq_struct_h->h_ref_no);
		strcpy(p_dl_takeover_struct_h->h_ref_no,p_dl_takeover_seq_struct_h->h_ref_no);
	}
	printf("\n p_dl_takeover_seq_struct_h->h_ref_no |%s|\n",p_dl_takeover_seq_struct_h->h_ref_no);

 	if (!strcmp(p_intl_envdatastruct_h->h_mode,APL_FUNC_INPUT))
	{
		/******** mandatory chks for duplication ********/
		
		l_key_codes[0]="REF_NO";
		l_key_codes[1]="INSTR_CD";
		l_key_codes[2]="DEPOSITORY";
		l_key_codes[3]=APL_NULL_STRING;

		l_key_values[0] = p_dl_takeover_struct_h->h_ref_no;
		l_key_values[1] = p_dl_takeover_struct_h->h_instr_cd;
		l_key_values[2] = p_dl_takeover_struct_h->h_depository;
		l_key_values[3] =	APL_NULL_STRING;
		
   		strcpy(chr_l_table_name,"DL_TAKEOVER");
		printf("\nBefore CR_Rtv_MastChldChrVal \n ");

    	int_retval = CR_Rtv_MastChldChrVal( l_key_codes,
                                        l_key_values,
                                        chr_l_table_name,
                                        "REF_NO",
                                        chr_l_field_val,
                                        l_debug_info_ptr);
		
		printf("\n chr_l_field_val----|%s| \n",chr_l_field_val);

    	if (strcmp(chr_l_field_val,APL_NULL_STRING))
		{
			printf("record exist");
			 if (CO_InsertErr
			(l_debug_info_ptr,
			 ERR_DL_TAKEOVER_DEPO_INST_INVALID, 
  			 APL_NULL_STRING,
			 APL_NULL_STRING,
			 APL_NULL_STRING,
			 __LINE__,
			 __FILE__
			) != APL_SUCCESS)
			APL_GOBACK_FAIL
			APL_GOBACK_FAIL
		}
		
		else
		{
			printf("\n record not found--\n");
			/*
			strcpy(l_debug_info_ptr,APL_NULL_STRING);
			
			free(l_debug_info_ptr);
			*/
		
		}
			
		printf("\n after CR_Rtv_MastChldChrVal \n ");
		
		strcpy(chr_ref_no_compare,chr_l_field_val);
		printf("\n REf NO|%s|\n",chr_l_field_val);

		printf("\n ENTERING INPUT MODE \n");
		APL_IF_DEBUG
 		{
  			CO_ProcMonitor(APL_OUT_FILE, "Entered Input of Function MT_UpdDL_TAKEOVER\n",
													NULL,p_intl_envdatastruct_h);
 		}
	strcpy(p_dl_takeover_struct_h->h_status,STATUS_UAUTH);
	l_dl_takeover_struct_i->i_status =0;
	strcpy(p_dl_takeover_struct_h->h_maker,p_intl_envdatastruct_h->usr);
	l_dl_takeover_struct_i->i_maker=0;
	strcpy(p_dl_takeover_struct_h->h_makerdt,chr_sys_access_stamp);
	l_dl_takeover_struct_i->i_makerdt=0;
	strcpy(p_dl_takeover_struct_h->h_accesstamp,chr_sys_access_stamp);
	l_dl_takeover_struct_i->i_accesstamp =0;
    /*
	printf("\nI am before insert %s\n",p_dl_takeover_struct_h->h_accesstamp); 
	*/
	EXEC SQL SELECT CLN_CODE into :p_cln_code from DL_TAKEOVER_SEQ where CLN_CODE=:p_dl_takeover_seq_struct_h->h_cln_code;
	printf("\n CHECKING FOR CLN CODE FOR MASTER ENTRY %d \n",sqlca.sqlcode);
	
	IS_ANY_ORA_ERROR;
	

	if(sqlca.sqlcode==1403)
	  {				
		EXEC SQL SELECT REF_NO into :p_ref_no from DL_TAKEOVER_SEQ where REF_NO=:p_dl_takeover_struct_h->h_ref_no;
		IS_ANY_ORA_ERROR;
		printf("\n CHECKING FOR REF NO FOR MASTER ENTRY  %d \n",sqlca.sqlcode);
		if(sqlca.sqlcode==1403)
		   {	
				EXEC SQL INSERT INTO DL_TAKEOVER_SEQ VALUES(:p_dl_takeover_seq_struct_h:l_dl_takeover_seq_struct_i);
				printf("\n AFTER INSERTING IN MASTER TABLE |%d|\n",sqlca.sqlcode);
				IS_ANY_ORA_ERROR;
				
				EXEC SQL INSERT INTO DL_TAKEOVER VALUES (:p_dl_takeover_struct_h:l_dl_takeover_struct_i);

				IS_ANY_ORA_ERROR_AND_DUPLICATE(MAP_DET_EXIST,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING)

				printf("\n AFTER INSERTING IN CHILD TABLE (MASTER ENTRY) |%d|\n",sqlca.sqlcode);
				IS_ANY_ORA_ERROR;
			}
		}
	else
		{
				
				EXEC SQL SELECT REF_NO INTO :p_dl_takeover_struct_h->h_ref_no FROM DL_TAKEOVER_SEQ WHERE CLN_CODE=:p_dl_takeover_seq_struct_h->h_cln_code;

				printf("\n CHECKING FOR REF NO FOR CHILD  ENTRY  %d \n",sqlca.sqlcode);
				printf("\nREFERENCE NO IN MASTER TABLE IS |%s| \n",p_dl_takeover_seq_struct_h->h_ref_no);
				printf("\n REFERENCE NO IN CHILD TABLE IS |%s| \n",p_dl_takeover_struct_h->h_ref_no);

				IS_ANY_ORA_ERROR;

				EXEC SQL INSERT INTO DL_TAKEOVER VALUES (:p_dl_takeover_struct_h:l_dl_takeover_struct_i);

				printf("\n AFTER INSERTING IN CHILD TABLE  |%d|\n",sqlca.sqlcode);
				IS_ANY_ORA_ERROR_AND_DUPLICATE(MAP_DET_EXIST,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING);



			}
	}	
	else
	{

	/* COMMENTED BY AMISH	
	   l_key_codes[0]="CI_NO";
	*/
		/* ADDED BY AMISH */
		
		
		l_key_codes[0]="REF_NO";
		l_key_codes[1]="SERIAL_NO";
		l_key_codes[2]=APL_NULL_STRING;

		l_key_values[0]=p_dl_takeover_struct_h->h_ref_no;
		l_key_values[1]=p_dl_takeover_struct_h->h_serial_no;
		l_key_values[2] =APL_NULL_STRING;
		
		/*
		l_key_codes[0]="REF_NO";
		l_key_codes[1]="INSTR_CD";
		l_key_codes[2]="DEPOSITORY";
		l_key_codes[3]="CI_NO";

		l_key_codes[4]="TAKEOVER_QTY";
		l_key_codes[5]="QTY";
		
		l_key_codes[4]="PHY_FLG";
		l_key_codes[5]=APL_NULL_STRING;

		l_key_values[0] = p_dl_takeover_struct_h->h_ref_no;
		l_key_values[1] = p_dl_takeover_struct_h->h_instr_cd;
		l_key_values[2] = p_dl_takeover_struct_h->h_depository;
		l_key_values[3] = p_dl_takeover_struct_h->h_ci_no;
		
		l_key_values[4] = p_dl_takeover_struct_h->h_takeover_qty;
		l_key_values[5] = p_dl_takeover_struct_h->h_qty;
		
		l_key_values[4] = p_dl_takeover_struct_h->h_phy_flg;
		l_key_values[5] = APL_NULL_STRING;
	*/
   		strcpy(chr_l_table_name,"DL_TAKEOVER");
		printf("\before CR_Rtv_MastChldChrVal \n ");

    	int_retval = CR_Rtv_MastChldChrVal( l_key_codes,
                                        l_key_values,
                                        chr_l_table_name,
                                        "ACCESSTAMP",
                                        chr_l_field_val,
                                        l_debug_info_ptr);


    	if (int_retval != APL_SUCCESS)
         APL_GOBACK_FAIL
		printf("\n after CR_Rtv_MastChldChrVal \n ");

		strcpy(chr_acc_stamp_compare,chr_l_field_val);
		printf("\n access stamp |%s|\n",chr_l_field_val);
    
		int_retval = CR_Rtv_MastChldChrVal( l_key_codes,
                                        l_key_values,
                                        chr_l_table_name,
                                        "STATUS",
                                        chr_l_field_val,
                                        l_debug_info_ptr);

		if (int_retval != APL_SUCCESS)
         APL_GOBACK_FAIL

		strcpy(chr_status_compare,chr_l_field_val);
			printf("\n status |%s|\n",chr_status_compare);
    
	}

 	if (!strcmp(p_intl_envdatastruct_h->h_mode,APL_FUNC_MODIFY))
		{
        /*******************************************/
		
		l_key_codes[0]="REF_NO";
		l_key_codes[1]="INSTR_CD";
		l_key_codes[2]="DEPOSITORY";
		l_key_codes[3]=APL_NULL_STRING;

		l_key_values[0] = p_dl_takeover_struct_h->h_ref_no;
		l_key_values[1] = p_dl_takeover_struct_h->h_instr_cd;
		l_key_values[2] = p_dl_takeover_struct_h->h_depository;
		l_key_values[3] =	APL_NULL_STRING;
		
   		strcpy(chr_l_table_name,"DL_TAKEOVER");
		printf("\before CR_Rtv_MastChldChrVal \n ");

    	int_retval = CR_Rtv_MastChldChrVal( l_key_codes,
                                        l_key_values,
                                        chr_l_table_name,
                                        "SERIAL_NO",
                                        chr_l_field_val,
                                        l_debug_info_ptr);
		

    	printf("\n chr_l_field_val----|%s| \n",chr_l_field_val);

		/*    	if (strcmp(chr_l_field_val,APL_NULL_STRING))
		*/		if (((strcmp(chr_l_field_val,APL_NULL_STRING))!=0) && ((strcmp(chr_l_field_val,p_dl_takeover_struct_h->h_serial_no))!=0))
		{
			printf("record exist");
			 if (CO_InsertErr
			(l_debug_info_ptr,
			 ERR_DL_TAKEOVER_DEPO_INST_INVALID, 
			 APL_NULL_STRING,
			 APL_NULL_STRING,
			 APL_NULL_STRING,
			 __LINE__,
			 __FILE__
			) != APL_SUCCESS)
			APL_GOBACK_FAIL
			APL_GOBACK_FAIL
		}
		else
		{
			//printf("\n record not found--|%s|\n",l_debug_info_ptr); Changes done for AIX Migration
                        printf("\n record not found--\n"); 
			/*
			strcpy(l_debug_info_ptr,APL_NULL_STRING);
			free(l_debug_info_ptr);
			*/
		
		}
		
		printf("\n after CR_Rtv_MastChldChrVal \n ");
		
		strcpy(chr_ref_no_compare,chr_l_field_val);
		printf("\n SERIAL NO IS|%s|\n",chr_l_field_val);
		/*
		strcpy(chr_ref_no_compare,chr_l_field_val);
		printf("\n SERIAL NO  NO|%s|\n",chr_l_field_val);
		*/
		
		/**************************************************/
  			p_i_checker =-1;
  			p_i_checkerdt =-1;
			strcpy(p_dl_takeover_struct_h->h_checker,APL_NULL_STRING);
			strcpy(p_dl_takeover_struct_h->h_checkerdt,APL_NULL_STRING);
			
			APL_IF_DEBUG
 			{
  				CO_ProcMonitor(APL_OUT_FILE, "Entered modify of Function MT_ModDBNoDlvDet\n",
													NULL,p_intl_envdatastruct_h);
 			}
	     	/*EXEC SQL SELECT ACCESSTAMP FROM DL_TAKEOVER WHERE ACCESSTAMP=:p_dl_takeover_struct_h->h_accesstamp AND
				               SERIAL_NO=:p_dl_takeover_struct_h->h_serial_no;
		  	if(sqlca.sqlcode==0)
			{	
				APL_IF_DEBUG
				{
					CO_ProcMonitor(APL_OUT_FILE, "Record Already been modified\n",
										                   NULL,p_intl_envdatastruct_h);
				}
			
			
				APL_FAILURE;
			}	*/
					     

      		printf("\n access stamp in modify mode from struct |%s|\n",p_dl_takeover_struct_h->h_accesstamp);
			
			printf("\n chr_sys_access_stamp=%s \n ",chr_sys_access_stamp);
	   		printf("\n chr_acc_stamp_compare=%s \n ",chr_acc_stamp_compare);
		
	   		if (!strcmp(p_dl_takeover_struct_h->h_accesstamp,chr_acc_stamp_compare))
	   			{
					strcpy(p_dl_takeover_struct_h->h_accesstamp,chr_sys_access_stamp);
					printf("\nEntered MODIFY AFTER ACCESS STAMP COMPARISION\n");
					printf("\nserial no is |%s|\n",p_dl_takeover_struct_h->h_serial_no);
					printf("\np_dl_takeover_struct_h->h_takeover_qty=|%lf|\n",p_dl_takeover_struct_h->h_takeover_qty);
					printf("\np_dl_takeover_struct_h->h_depository=%s\n",p_dl_takeover_struct_h->h_depository);
					printf("\np_dl_takeover_struct_h->h_instr_cd=%s\n",p_dl_takeover_struct_h->h_instr_cd);
					printf("\np_dl_takeover_struct_h->h_qty=|%lf|\n",p_dl_takeover_struct_h->h_qty);
					l_dl_takeover_struct_i->i_accesstamp =0;
 		 
		/*		   	
					EXEC SQL SELECT CLN_CODE into :l_clncode:i_clncode from dl_takeover_seq
							where REF_NO = :p_dl_takeover_struct_h->h_ref_no;
							IS_ANY_ORA_ERROR
               
               EXEC SQL SELECT CLIENT into :l_clncode_sf:i_clncode_sf
							FROM DL_SAFEK
							WHERE INSTR_CODE = :p_dl_takeover_struct_h->h_instr_cd
							AND CLIENT = :l_clncode;
							IS_ANY_ORA_ERROR
					if(strcmp(l_clncode_sf,APL_NULL_STRING))
					{
					    printf("\nENTRING DL SAFEKKKKKKKKKKK\n");
              		 EXEC SQL SELECT QTY into :l_qty:i_qty from DL_TAKEOVER
							WHERE REF_NO = :p_dl_takeover_struct_h->h_ref_no
							AND INSTR_CD = :p_dl_takeover_struct_h->h_instr_cd;
					
			     			 printf("\n QTY ISSSS|%lf|**********\n",l_qty);
							 printf("\np_dl_takeover_struct_h->h_qty*****|%lf| \n",p_dl_takeover_struct_h->h_qty);	
					     
							EXEC SQL SELECT CLN_CODE into :l_clncode:i_clncode from dl_takeover_seq
							where REF_NO = :p_dl_takeover_struct_h->h_ref_no;
							IS_ANY_ORA_ERROR
		                
							printf("CLN CODE IS |%s|\n",l_clncode); 
			     			 if(p_dl_takeover_struct_h->h_qty > l_qty)
							{
                  	   l_safekeep_qty = p_dl_takeover_struct_h->h_qty - l_qty; 
              		 		if(!strcmp(chr_status_compare,STATUS_UAUTH))
								{
						   
									printf("*********************\nSTATUS UU\n");
                	   		int_return = DL_Mod_Posn(l_clncode,p_dl_takeover_struct_h->
							  			  h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'C','2',
										 	&l_safekeep_qty,'I',"FREE",l_debug_info_ptr);		  
						
								}
               			if(!strcmp(chr_status_compare,STATUS_AUTH)) 
								{
									printf("*********************\nSTATUS AA\n");
                   			int_return = DL_Mod_Posn(l_clncode,p_dl_takeover_struct_h->
								 			  h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'S','2',
											  	 		&l_safekeep_qty,'I',"FREE",l_debug_info_ptr);
						
								}
						
							}
							if(p_dl_takeover_struct_h->h_qty < l_qty)
							{
               			  l_safekeep_qty = l_qty - p_dl_takeover_struct_h->h_qty;
              				 if(!strcmp(chr_status_compare,STATUS_UAUTH))
									{
						
										printf("*********************\nSTATUS UU\n");
                				   int_return = DL_Mod_Posn(l_clncode,p_dl_takeover_struct_h->
							  			  h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'C','2',
										 	&l_safekeep_qty,'D',"FREE",l_debug_info_ptr);		  
						
									}
               			if(!strcmp(chr_status_compare,STATUS_AUTH)) 
									{
										printf("*********************\nSTATUS AA\n");
         			          	int_return = DL_Mod_Posn(l_clncode,p_dl_takeover_struct_h->
								 			  h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'S','2',
											  	 		&l_safekeep_qty,'D',"FREE",l_debug_info_ptr);
						
									}
						
							}
					}	
	*/				
		/*				
					EXEC SQL SELECT SAFEKEEP_POS into :l_safekeep_pos:i_safekeep_pos from DL_SAFEK
				      where CLIENT = :l_clncode 
					     AND  INSTR_CODE = :p_dl_takeover_struct_h->h_instr_cd;
					
					   IS_ANY_ORA_ERROR
							
					if(l_safekeep_pos < p_dl_takeover_struct_h->h_qty)
					{
						 l_safekeep_qty = l_safekeep_pos;
					}
					else
						l_safekeep_qty = 
		
               printf("\n******MOD***client code is |%s|\n",l_clncode);
					
					printf("\n******MOD***client code is |%s|\n",p_dl_takeover_seq_struct_h->h_cln_code);
					
					printf("\n******MOD***instr code is |%s|\n",p_dl_takeover_struct_h->h_instr_cd);
					printf("STATUS IS chr_status_compare |%s|\n",chr_status_compare);
					printf("STATUS IS  p_dl_takeover_struct_h->h_status |%s|\n",p_dl_takeover_struct_h->h_status);
               if(!strcmp(chr_status_compare,STATUS_UAUTH))
					{
						
						printf("*********************\nSTATUS UU\n");
                 int_return = DL_Mod_Posn(l_clncode,p_dl_takeover_struct_h->
							  			  h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'C','2',
										 	&p_dl_takeover_struct_h->h_qty,'D',"FREE",l_debug_info_ptr);		  
						
					}
               if(!strcmp(chr_status_compare,STATUS_AUTH)) 
					{
						printf("*********************\nSTATUS AA\n");
                   int_return = DL_Mod_Posn(l_clncode,p_dl_takeover_struct_h->
								 			  h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'S','2',
											  	 		&p_dl_takeover_struct_h->h_qty,'D',"FREE",l_debug_info_ptr);
						
					}
		*/			
		  			strcpy(p_dl_takeover_struct_h->h_status,STATUS_UAUTH);
					l_dl_takeover_struct_i->i_status =0;

					EXEC SQL UPDATE DL_TAKEOVER  SET 
					MAKER =:p_intl_envdatastruct_h->usr:p_i_maker,
					MAKER_DT =:chr_sys_access_stamp:p_i_makerdt,
					CHECKER =:p_dl_takeover_struct_h->h_checker:p_i_checker,
					CHECKER_DT =:p_dl_takeover_struct_h->h_checkerdt:p_i_checkerdt,
					STATUS =:p_dl_takeover_struct_h->h_status:l_dl_takeover_struct_i->i_status,
					REF_NO =:p_dl_takeover_struct_h->h_ref_no :l_dl_takeover_struct_i->i_ref_no,
					CI_NO =:p_dl_takeover_struct_h->h_ci_no  :l_dl_takeover_struct_i->i_ci_no, 
					INSTR_CD =:p_dl_takeover_struct_h->h_instr_cd :l_dl_takeover_struct_i->i_instr_cd,
					QTY= :p_dl_takeover_struct_h->h_qty :l_dl_takeover_struct_i->i_qty,
			    	PHY_FLG = :p_dl_takeover_struct_h->h_phy_flg :l_dl_takeover_struct_i->i_phy_flg,
					TAKEOVER_QTY= :p_dl_takeover_struct_h->h_takeover_qty :l_dl_takeover_struct_i->i_takeover_qty,	
					DEPOSITORY = :p_dl_takeover_struct_h->h_depository  :l_dl_takeover_struct_i-> i_depository,
					ACCESSTAMP= :p_dl_takeover_struct_h->h_accesstamp  :l_dl_takeover_struct_i->i_accesstamp,
					SERIAL_NO= :p_dl_takeover_struct_h->h_serial_no :l_dl_takeover_struct_i->i_serial_no
               /*
					COMMENTS= :p_dl_takeover_struct_h->h_comments  :l_dl_takeover_struct_i->i_comments,
						
					*/
					WHERE 
					SERIAL_NO= :p_dl_takeover_struct_h->h_serial_no; 
			
					/*		
					EXEC SQL UPDATE DL_TAKEOVER  SET 
					CHECKER =:p_dl_takeover_struct_h->h_checker:p_i_checker,
					CHECKER_DT =:p_dl_takeover_struct_h->h_checkerdt:p_i_checkerdt,
					STATUS =:p_dl_takeover_struct_h->h_status:l_dl_takeover_struct_i->i_status,
					ACCESSTAMP= :p_dl_takeover_struct_h->h_accesstamp  :l_dl_takeover_struct_i->i_accesstamp,
					COMMENTS= :p_dl_takeover_struct_h->h_comments  :l_dl_takeover_struct_i->i_comments,
					WHERE
						SERIAL_NO= :p_dl_takeover_struct_h->h_serial_no;
					*/		
				
         			printf("\n UPDATE IN MODIFY MODE |%d|\n",sqlca.sqlcode);  					 
              
					IS_ANY_ORA_ERROR;
				}
			else 
			   {
					if (CO_InsertErr
					(l_debug_info_ptr,
					 ERR_ACCESSSTAMP_CHGD, 
					 APL_NULL_STRING,
					 APL_NULL_STRING,
					 APL_NULL_STRING,
					 __LINE__,
					 __FILE__
					) != APL_SUCCESS)
					APL_GOBACK_FAIL
					APL_GOBACK_FAIL
				} 
		}

	 if (!strcmp(p_intl_envdatastruct_h->h_mode,APL_FUNC_AUTHORISE))
		{

			APL_IF_DEBUG
 			{
  				CO_ProcMonitor(APL_OUT_FILE, "Entered authorize of Function MT_ModDBNoDlvDet\n",
													NULL,p_intl_envdatastruct_h);
 			}
			
			printf("\n ACCESS STAMP IN AUTHORISE MODE %s \n",p_dl_takeover_struct_h->h_accesstamp);
		    printf("\n AUTHORIZE--chr_acc_stamp_compare=%s",chr_acc_stamp_compare);
        /* strcpy(p_dl_takeover_struct_h->h_accesstamp,chr_acc_stamp_compare);*/
			if (strcmp(p_dl_takeover_struct_h->h_accesstamp,chr_acc_stamp_compare)==0)
	   			{
					printf("\n I have entered strcmp of AUT\n");
			
	   	   			if(strcmp(p_dl_takeover_struct_h->h_status,STATUS_DEL_UAUTH))
	    			{
						printf("Inside Aut %s\n",p_intl_envdatastruct_h->processtion);
						l_dl_takeover_struct_i->i_accesstamp =0;
						strcpy(p_dl_takeover_struct_h->h_checker,p_intl_envdatastruct_h->usr);
						l_dl_takeover_struct_i->i_checker=0;
						strcpy(p_dl_takeover_struct_h->h_checkerdt,chr_sys_access_stamp);
						l_dl_takeover_struct_i->i_checkerdt=0;
						strcpy(p_dl_takeover_struct_h->h_status,STATUS_AUTH);
						l_dl_takeover_struct_i->i_status =0;
						strcpy(p_dl_takeover_struct_h->h_status,"AA");
									
						int_rfdeals = p_dl_takeover_struct_h->h_qty;
						EXEC SQL SELECT  DL_TAKEOVERSEQ.NEXTVAL into :l_sequence FROM DUAL;
						IS_ANY_ORA_ERROR
						/*p_dl_deal_struct_h->h_qty = p_dl_takeover_struct_h->h_qty - p_dl_takeover_struct_h->h_takeover_qty;*/
					
						printf("\n The serial no before AUTHORIZATION is %s\n", p_dl_takeover_struct_h->h_serial_no);
						strcpy(p_dl_deal_struct_h->h_origindentity_no,p_dl_takeover_struct_h->h_ref_no);				        
						strcpy(p_dl_deal_struct_h->h_indentity_no,"TR_");
						/*
						strcat(p_dl_deal_struct_h->h_indentity_no,p_dl_takeover_struct_h->h_serial_no);
						*/
						strcat(p_dl_deal_struct_h->h_indentity_no,l_sequence);
						strcpy(p_dl_deal_struct_h->h_dl_client,p_dl_takeover_seq_struct_h->h_cln_code);
						printf("The ref_no IN AUT is : %s",p_dl_deal_struct_h->h_dl_client);
						strcpy(p_dl_deal_struct_h->h_dlt,chr_sys_access_stamp);
						strcpy(p_dl_deal_struct_h->h_setldt,chr_sys_access_stamp);
						strcpy(p_dl_deal_struct_h->h_instr_code,p_dl_takeover_struct_h->h_instr_cd);	  
						strcpy(p_dl_deal_struct_h->h_origindentity_no,p_dl_deal_struct_h->h_indentity_no);	
						strcpy(chr_sys_date,chr_sys_access_stamp);
					
						printf("\n this is yours p_dl_deal_struct_h->h_dl_client %s \n",p_dl_deal_struct_h->h_dl_client);      
						strcpy(p_dl_deal_struct_h->h_deal_status,"CS");
						strcpy(p_dl_deal_struct_h->h_dl_secstatus,"CS");
						strcpy(p_dl_deal_struct_h->h_dl_mnystatus,"CS"); 
						p_dl_deal_struct_h->h_qty = p_dl_takeover_struct_h->h_qty;
						
						strcpy(p_dl_deal_struct_h->h_misinfo,"TAKEOVER"); /*	ISKB-1929 Use
						of Informaton to identify Takeover Deal	*/ 
						
						if(p_dl_takeover_struct_h->h_qty==p_dl_takeover_struct_h->h_takeover_qty)
						  {
							  /*
							  
                      EXEC SQL SELECT CLIENT into :l_clncode:i_clncode
								 FROM DL_SAFEK
								 WHERE INSTR_CODE = :p_dl_takeover_struct_h->h_instr_cd
							    AND CLIENT = :p_dl_takeover_seq_struct_h->h_cln_code;
							    IS_ANY_ORA_ERROR
								 if(sqlca.sqlcode == 1403)
								 {
									    printf("\n INITIAL AUTHORIZATION \n");
                               int_return=DL_Mod_DefaultDeal(p_dl_deal_struct_h,p_dl_takeover_struct_h,
																				p_intl_envdatastruct_h,l_debug_info_ptr);
									 
										int_return = DL_Mod_Posn(p_dl_takeover_seq_struct_h->h_cln_code,p_dl_takeover_struct_h->
																h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'C','2',
																&p_dl_takeover_struct_h->h_qty,'D',"FREE",l_debug_info_ptr);
										
										int_return = DL_Mod_Posn(p_dl_takeover_seq_struct_h->h_cln_code,p_dl_takeover_struct_h->
																h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'S','2',
																&p_dl_takeover_struct_h->h_qty,'I',"FREE",l_debug_info_ptr);
								 }
							 	 
								 else 
					          {
					  			    
									    printf("\nAUTHORIZATION AFTER MODIFICATION \n");
               					int_return=DL_Mod_DefaultDeal(p_dl_deal_struct_h,p_dl_takeover_struct_h,
																	p_intl_envdatastruct_h,l_debug_info_ptr); 
								
              			 			EXEC SQL SELECT QTY into :l_qty:i_qty from DL_TAKEOVER
										WHERE REF_NO = :p_dl_takeover_struct_h->h_ref_no
										AND INSTR_CD = :p_dl_takeover_struct_h->h_instr_cd;
										
			     		
										EXEC SQL SELECT CLN_CODE into :l_clncode:i_clncode from dl_takeover_seq
										where REF_NO = :p_dl_takeover_struct_h->h_ref_no;
											IS_ANY_ORA_ERROR
					                
			      					if(p_dl_takeover_struct_h->h_qty > l_qty)
										{
                     			
											l_safekeep_qty = p_dl_takeover_struct_h->h_qty - l_qty; 
											printf("\n *******l_safekeep_qty*****|%s|\n",l_safekeep_qty);				
								
                   					int_return = DL_Mod_Posn(p_dl_takeover_seq_struct_h->h_cln_code,
														p_dl_takeover_struct_h->h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'S','2',
											  	 		&l_safekeep_qty,'I',"FREE",l_debug_info_ptr);
						
				  					  }
									 if(p_dl_takeover_struct_h->h_qty < l_qty)
									 {
                 					l_safekeep_qty = l_qty - p_dl_takeover_struct_h->h_qty;	
									    printf("\n *******l_safekeep_qty*****|%s|\n",l_safekeep_qty);
										 
                   					int_return = DL_Mod_Posn(p_dl_takeover_seq_struct_h->h_cln_code,
													p_dl_takeover_struct_h->h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'S','2',
											  	 		&l_safekeep_qty,'D',"FREE",l_debug_info_ptr);
					
						   		}


								 }	
								
							
								
								else		
			 					{

		*/						
                         int_return=DL_Mod_DefaultDeal(p_dl_deal_struct_h,p_dl_takeover_struct_h,
																				p_intl_envdatastruct_h,l_debug_info_ptr);
							
				            /*  commented on 12/04
								 int_return = DL_Mod_Posn(p_dl_takeover_seq_struct_h->h_cln_code,p_dl_takeover_struct_h->
																h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'C','2',
																&p_dl_takeover_struct_h->h_qty,'D',"FREE",l_debug_info_ptr);
								
								int_return = DL_Mod_Posn(p_dl_takeover_seq_struct_h->h_cln_code,p_dl_takeover_struct_h->
																h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'S','2',
																&p_dl_takeover_struct_h->h_qty,'I',"FREE",l_debug_info_ptr);
									*/
								 
							/*	
								}
								*/
								/*
						  		EXEC SQL INSERT INTO DL_BIFDET VALUES(:p_dl_takeover_seq_struct_h->h_cln_code,:p_dl_deal_struct_h->h_indentity_no,:p_dl_takeover_struct_h->h_qty,:p_dl_takeover_struct_h->h_depository,:chr_sys_access_stamp);
								IS_ANY_ORA_ERROR
								*/
						  }
						else
							  {
								/*
								strcat(p_dl_deal_struct_h->h_indentity_no,"_");
								strcat(p_dl_deal_struct_h->h_indentity_no,l_sequence); 
							  */	
								strcat(p_dl_deal_struct_h->h_indentity_no,"_1");   
								p_dl_deal_struct_h->h_qty = p_dl_takeover_struct_h->h_qty;	
                        /*								
                        EXEC SQL SELECT CLIENT into :l_clncode:i_clncode
								 FROM DL_SAFEK
								 WHERE INSTR_CODE = :p_dl_takeover_struct_h->h_instr_cd
							    AND CLIENT = :p_dl_takeover_seq_struct_h->h_cln_code;
							    IS_ANY_ORA_ERROR
								 if(sqlca.sqlcode == 1403)
							  {
									      printf("\nINITIAL AUTHORISATION\n");
								  			int_return=DL_Mod_DefaultDeal(p_dl_deal_struct_h,p_dl_takeover_struct_h,
																		p_intl_envdatastruct_h,l_debug_info_ptr);
						 					int_return = DL_Mod_Posn(p_dl_takeover_seq_struct_h->h_cln_code,
													p_dl_takeover_struct_h->h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'C','2',
									 				&p_dl_takeover_struct_h->h_qty,'D',"FREE",l_debug_info_ptr);

											int_return = DL_Mod_Posn(p_dl_takeover_seq_struct_h->h_cln_code,
													p_dl_takeover_struct_h->h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'S','2',
													&p_dl_takeover_struct_h->h_qty,'I',"FREE",l_debug_info_ptr);
								
								 }
								 
								 else 
					          {
									 printf("\nAUTHORIZATION AFTER MODIFICATION \n");
					  			
									 
               					int_return=DL_Mod_DefaultDeal(p_dl_deal_struct_h,p_dl_takeover_struct_h,
																	p_intl_envdatastruct_h,l_debug_info_ptr); 
										
								
              			 			EXEC SQL SELECT QTY into :l_qty:i_qty from DL_TAKEOVER
										WHERE REF_NO = :p_dl_takeover_struct_h->h_ref_no
										AND INSTR_CD = :p_dl_takeover_struct_h->h_instr_cd;
										printf("**********qty**** is |%s|\n",l_qty);
										printf("**********p_dl_takeover_struct_h->h_qty>l_qty**** is |%s|\n",
												p_dl_takeover_struct_h->h_qty);
										
			     		
										EXEC SQL SELECT CLN_CODE into :l_clncode:i_clncode from dl_takeover_seq
										where REF_NO = :p_dl_takeover_struct_h->h_ref_no;
											IS_ANY_ORA_ERROR
					                
			      					if(p_dl_takeover_struct_h->h_qty > l_qty)
										{
                                       
                     				l_safekeep_qty = p_dl_takeover_struct_h->h_qty - l_qty;
											

                                  p_dl_deal_struct_h->h_qty = l_safekeep_qty;     
											 printf("\np_dl_deal_struct_h->h_qty|%s|**\n",p_dl_deal_struct_h->h_qty);
               					int_return=DL_Mod_DefaultDeal(p_dl_deal_struct_h,p_dl_takeover_struct_h,
																	p_intl_envdatastruct_h,l_debug_info_ptr); 
						                printf("\n *******l_safekeep_qty*****|%s|\n",l_safekeep_qty);
								
                   					int_return = DL_Mod_Posn(p_dl_takeover_seq_struct_h->h_cln_code,
														p_dl_takeover_struct_h->h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'S','2',
											  	 		&l_safekeep_qty,'I',"FREE",l_debug_info_ptr);
						
				  					  }
									 if(p_dl_takeover_struct_h->h_qty < l_qty)
									 {
                 					l_safekeep_qty = l_qty - p_dl_takeover_struct_h->h_qty;	
									    printf("\n *******l_safekeep_qty*****|%s|\n",l_safekeep_qty);
                                
                                p_dl_deal_struct_h->h_qty = l_safekeep_qty;     
               					  int_return=DL_Mod_DefaultDeal(p_dl_deal_struct_h,p_dl_takeover_struct_h,
																	p_intl_envdatastruct_h,l_debug_info_ptr); 
						    

                   					int_return = DL_Mod_Posn(p_dl_takeover_seq_struct_h->h_cln_code,
													p_dl_takeover_struct_h->h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'S','2',
											  	 		&l_safekeep_qty,'D',"FREE",l_debug_info_ptr);
					
						   		}


								 }	
							*/	 
								
								
                        	int_return=DL_Mod_DefaultDeal(p_dl_deal_struct_h,p_dl_takeover_struct_h,
																				p_intl_envdatastruct_h,l_debug_info_ptr);
							/*	commented on 12/04
									
									int_return = DL_Mod_Posn(p_dl_takeover_seq_struct_h->h_cln_code,p_dl_takeover_struct_h->
																h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'C','2',
																&p_dl_takeover_struct_h->h_qty,'D',"FREE",l_debug_info_ptr);
								
									int_return = DL_Mod_Posn(p_dl_takeover_seq_struct_h->h_cln_code,p_dl_takeover_struct_h->
																h_instr_cd,p_dl_takeover_struct_h->h_depository,"",'S','2',
																&p_dl_takeover_struct_h->h_qty,'I',"FREE",l_debug_info_ptr);
								  
							*/
									printf("\n QTY IS |%lf|\n",p_dl_takeover_struct_h->h_qty);
									printf("\n takeover qty is|%lf|\n",p_dl_takeover_struct_h->h_takeover_qty);
									p_dl_deal_struct_h1->h_qty = p_dl_takeover_struct_h->h_takeover_qty - p_dl_takeover_struct_h->h_qty;
								printf("\n QTY AFTER SUBTRACTION IS |%lf| \n",p_dl_deal_struct_h1->h_qty); 
								/*
								strcat(p_dl_deal_struct_h->h_indentity_no,"_1");   
								int_return=DL_Mod_DefaultDeal(p_dl_deal_struct_h,p_dl_takeover_struct_h,l_debug_info_ptr);			
								free(p_dl_deal_struct_h);       							
								*/
								l_dl_takeover_struct_i->i_accesstamp =0;
								strcpy(p_dl_takeover_struct_h->h_checker,p_intl_envdatastruct_h->usr);
								l_dl_takeover_struct_i->i_checker=0;
								strcpy(p_dl_takeover_struct_h->h_checkerdt,chr_sys_access_stamp);
								l_dl_takeover_struct_i->i_checkerdt=0;
								strcpy(p_dl_takeover_struct_h->h_status,STATUS_AUTH);
								l_dl_takeover_struct_i->i_status =0;
											
								strcpy(p_dl_deal_struct_h1->h_dl_secstatus,"");
								strcpy(p_dl_deal_struct_h1->h_dl_mnystatus,"");
								strcpy(p_dl_deal_struct_h1->h_indentity_no,"TR_");
								/*
								strcat(p_dl_deal_struct_h1->h_indentity_no,p_dl_takeover_struct_h->h_serial_no);	
								strcat(p_dl_deal_struct_h->h_indentity_no,"_" );
								*/
								strcat(p_dl_deal_struct_h1->h_indentity_no,l_sequence);
								strcat(p_dl_deal_struct_h1->h_indentity_no,"_2"); 
								strcpy(p_dl_deal_struct_h1->h_dl_client,p_dl_takeover_seq_struct_h->h_cln_code);
								printf("\n IN AUTH--CLN CODE%s \n", p_dl_deal_struct_h1->h_dl_client);	
								strcpy(p_dl_deal_struct_h1->h_deal_status,"CC");
								
								strcpy(p_dl_deal_struct_h1->h_misinfo,"TAKEOVER"); /* Added by Ekta Use of Informaton to identify Takeover Deal	*/
								
								/*
								p_dl_deal_struct_h1->h_qty=p_dl_takeover_struct_h->h_qty;
								*/
								printf("\n IN AUTH--indentity_no=%s \n",p_dl_deal_struct_h1->h_indentity_no);
								/*
								strcpy(p_dl_deal_struct_h1->h_dl_client,p_dl_takeover_seq_struct_h->h_cln_code);		
								*/
								int_return=DL_Mod_DefaultDeal(p_dl_deal_struct_h1,p_dl_takeover_struct_h,p_intl_envdatastruct_h,l_debug_info_ptr);		
								printf("\nAMISH-------------COMPLETED-----------------\n");
							  /*		 

								int_return=DL_Mod_DefaultDeal(p_dl_deal_struct_h,p_dl_takeover_struct_h,l_debug_info_ptr);
								
								if(APL_FAILURE == DL_Proc_Trd(p_dl_deal_struct_h,&int_h_trdrepseqnum,p_intl_envdatastruct_h,l_debug_info_ptr))
									{
											CO_ProcMonitor(APL_OUT_FILE,"Failure from DL_Proc_Trd", NULL, NULL);
											APL_GOBACK_FAIL;
									}

								*/	
								}		
					
							printf("\np_dl_takeover_struct_h->h_status=%s\n",p_dl_takeover_struct_h->h_status); 
							EXEC SQL UPDATE DL_TAKEOVER SET 
							CHECKER =:p_intl_envdatastruct_h->usr:p_i_checker,
							CHECKER_DT =:chr_sys_access_stamp:p_i_access_stamp,
							ACCESSTAMP =:chr_sys_access_stamp:p_i_access_stamp,
							STATUS =:p_dl_takeover_struct_h->h_status:l_dl_takeover_struct_i->i_status
							/*
							COMMENTS=:p_dl_takeover_struct_h->h_comments:l_dl_takeover_struct_i->i_comments
							*/
							WHERE 
							SERIAL_NO= :p_dl_takeover_struct_h->h_serial_no;	
							printf("\n UPDATE IN AUTH MODE %d \n",sqlca.sqlcode);  
							printf("\n The serial no after autherisation is %s\n", p_dl_takeover_struct_h->h_serial_no);  	
						
							IS_ANY_ORA_ERROR_AND_DUPLICATE(MAP_DET_EXIST,APL_NULL_STRING,APL_NULL_STRING,APL_NULL_STRING) 

							IS_ANY_ORA_ERROR;	
				  }
   				else  
	    		  {
	    				EXEC SQL DELETE FROM DL_TAKEOVER 
						WHERE 
						SERIAL_NO =:p_dl_takeover_struct_h->h_serial_no;  
			/*	EXEC SQL DELETE DL_TAKEOVER_SEQ
					WHERE
					REF_NO =:p_dl_takeover_struct_h->h_ref_no*/
			      /*rakesh
					AND CI_NO=:p_dl_takeover_struct_h->h_ci_no AND
					INSTR_CD =:p_dl_takeover_struct_h->h_instr_cd AND DEPOSITORY=:p_dl_takeover_struct_h->h_depository;
					*/    
					
										 
          
					   IS_ANY_ORA_ERROR;
					}
			}
			else 
			{
				if (CO_InsertErr
					(l_debug_info_ptr,
					 ERR_ACCESSSTAMP_CHGD, 
					 APL_NULL_STRING,
		   			APL_NULL_STRING,
					 APL_NULL_STRING,
					 __LINE__,
					 __FILE__
					) != APL_SUCCESS)
					APL_GOBACK_FAIL
					APL_GOBACK_FAIL
			}  
	}

 if (!strcmp(p_intl_envdatastruct_h->h_mode,APL_FUNC_RESET))
	  {
		printf("\n IN RESET MODE \n");
		APL_IF_DEBUG
		{
  			CO_ProcMonitor(APL_OUT_FILE, "Entered reset of Function MT_ModDBNoDlvDet\n",
													NULL,p_intl_envdatastruct_h);
 		  }
      /*
		strcpy(chr_acc_stamp_compare,p_dl_takeover_struct_h->h_accesstamp);	
	  */
		if (!strcmp(p_dl_takeover_struct_h->h_accesstamp,chr_acc_stamp_compare))
		 {
			printf("\nAFTER ACCESS STAMP COMPARISION\n");
   			if(strcmp(p_dl_takeover_struct_h->h_status,STATUS_DEL_UAUTH)==0)
	    		{
					printf("\n STATUS IS |%s|\n",p_dl_takeover_struct_h->h_status);
					strcpy(p_dl_takeover_struct_h->h_accesstamp,chr_sys_access_stamp);
					l_dl_takeover_struct_i->i_accesstamp =0;
					strcpy(p_dl_takeover_struct_h->h_checker,p_intl_envdatastruct_h->usr);
					l_dl_takeover_struct_i->i_checker=0;
					strcpy(p_dl_takeover_struct_h->h_checkerdt,chr_sys_access_stamp);
					l_dl_takeover_struct_i->i_checkerdt=0;
					strcpy(p_dl_takeover_struct_h->h_status,STATUS_AUTH);
					l_dl_takeover_struct_i->i_status =0;
					strcpy(p_dl_takeover_struct_h->h_status,"AA");
					EXEC SQL UPDATE DL_TAKEOVER SET 
					CHECKER =:p_intl_envdatastruct_h->usr:p_i_checker,
					CHECKER_DT =:chr_sys_access_stamp:p_i_access_stamp,
					ACCESSTAMP =:chr_sys_access_stamp:p_i_access_stamp,
					STATUS =:p_dl_takeover_struct_h->h_status:l_dl_takeover_struct_i->i_status
					/*
					REF_NO =:p_dl_takeover_struct_h->h_ref_no:l_dl_takeover_struct_i->i_ref_no,										             CI_NO =:p_dl_takeover_struct_h->h_ci_no:l_dl_takeover_struct_i->i_ci_no,
					INSTR_CD=:p_dl_takeover_struct_h->h_instr_cd:l_dl_takeover_struct_i-> i_instr_cd,
					QTY=:p_dl_takeover_struct_h-> h_qty:l_dl_takeover_struct_i->i_qty,
					PHY_FLG =:p_dl_takeover_struct_h->h_phy_flg:l_dl_takeover_struct_i->i_phy_flg,
					TAKEOVER_QTY=:p_dl_takeover_struct_h->h_takeover_qty:l_dl_takeover_struct_i->i_takeover_qty,
					DEPOSITORY=:p_dl_takeover_struct_h->h_depository:l_dl_takeover_struct_i->i_depository,
					MAKER=:p_dl_takeover_struct_h->h_maker:l_dl_takeover_struct_i->i_maker,        
					MAKER_DT=:p_dl_takeover_struct_h->h_makerdt:l_dl_takeover_struct_i->i_makerdt,
					COMMENTS=:p_dl_takeover_struct_h->h_comments:l_dl_takeover_struct_i->i_comments,
					SERIAL_NO= :p_dl_takeover_struct_h->h_serial_no :l_dl_takeover_struct_i->i_serial_no
					*/
					WHERE 
					SERIAL_NO= :p_dl_takeover_struct_h->h_serial_no;

					IS_ANY_ORA_ERROR;	
			}
	   }
	   else 
	   {
			if (CO_InsertErr
			(l_debug_info_ptr,
			 ERR_ACCESSSTAMP_CHGD, 
			 APL_NULL_STRING,
			 APL_NULL_STRING,
			 APL_NULL_STRING,
			 __LINE__,
			 __FILE__
			) != APL_SUCCESS)
			APL_GOBACK_FAIL
			APL_GOBACK_FAIL
	   } 
	}

 if (!strcmp(p_intl_envdatastruct_h->h_mode,APL_FUNC_DELETE))
	{
  		p_i_checker =-1;
  		p_i_checkerdt =-1;

		strcpy(p_dl_takeover_struct_h->h_checker,APL_NULL_STRING);
		strcpy(p_dl_takeover_struct_h->h_checkerdt,APL_NULL_STRING);
				
		APL_IF_DEBUG
 		{
  			CO_ProcMonitor(APL_OUT_FILE, "Entered delete of Function MT_ModDBNoDlvDet\n",
													NULL,p_intl_envdatastruct_h);
 		}
		

		
		
	/*	EXEC SQL SELECT ACCESSTAMP FROM DL_TAKEOVER WHERE ACCESSTAMP=:p_dl_takeover_struct_h->h_accesstamp AND
		          SERIAL_NO=:p_dl_takeover_struct_h->h_serial_no;
		 			 if(sqlca.sqlcode==0)
						         {
										  APL_IF_DEBUG
											{
													CO_ProcMonitor(APL_OUT_FILE, "Record Already been modified\n",
																		NULL,p_intl_envdatastruct_h);
											}


											APL_FAILURE;
									}*/
						

				
if (!strcmp(p_dl_takeover_struct_h->h_accesstamp,chr_acc_stamp_compare))
	  {

		
		if(strcmp(p_dl_takeover_seq_struct_h->h_cln_code,APL_NULL_STRING)==0)
		{
			
			printf("instrument level DELETION \n");
		/*	EXEC SQL DELETE FROM DL_TAKEOVER_SEQ where REF_NO=:p_dl_takeover_struct_h->h_ref_no;
			EXEC SQL DELETE FROM DL_TAKEOVER_SEQ where REF_NO=:p_dl_takeover_struct_h->h_ref_no
			AND CI_NO=:p_dl_takeover_struct_h->h_ci_no AND
			INSTR_CD =:p_dl_takeover_struct_h->h_instr_cd AND DEPOSITORY=:p_dl_takeover_struct_h->h_depository;
		
			IS_ANY_ORA_ERROR;*/
        	strcpy(p_dl_takeover_struct_h->h_accesstamp,chr_sys_access_stamp);
	    	l_dl_takeover_struct_i->i_accesstamp =0;
			strcpy(p_dl_takeover_struct_h->h_status,STATUS_DEL_UAUTH);
			l_dl_takeover_struct_i->i_status =0;
            printf("\n ACCESS STAMP IN DELETE MODE %s\n",chr_sys_access_stamp);  
			printf("\np_intl_envdatastruct_h->usr=%s\n",p_intl_envdatastruct_h->usr);
			printf("\np_dl_takeover_struct_h->h_checker=%s\n",p_dl_takeover_struct_h->h_checker);
			printf("\np_dl_takeover_struct_h->h_checkerdt=%s\n",p_dl_takeover_struct_h->h_checkerdt);
			printf("\np_dl_takeover_struct_h->h_status=%s\n",p_dl_takeover_struct_h->h_status);
			printf("\np_dl_takeover_struct_h->h_ref_no=%s\n",p_dl_takeover_struct_h->h_ref_no);
			printf("\np_dl_takeover_struct_h->h_ci_no=%s\n",p_dl_takeover_struct_h->h_ci_no);
			printf("\np_dl_takeover_struct_h->h_instr_cd=%s\n",p_dl_takeover_struct_h->h_instr_cd);
			printf("\np_dl_takeover_struct_h->h_qty=%lf\n",p_dl_takeover_struct_h->h_qty);//AIX -Warning Removal
			printf("\np_dl_takeover_struct_h->h_phy_flg=%s\n",p_dl_takeover_struct_h->h_phy_flg);
			printf("\np_dl_takeover_struct_h->h_takeover_qty=%lf\n",p_dl_takeover_struct_h->h_takeover_qty);//AIX -Warning Removal
			printf("\np_dl_takeover_struct_h->h_depository=%s\n",p_dl_takeover_struct_h->h_depository);
			printf("\np_dl_takeover_struct_h->h_comments=%s\n",p_dl_takeover_struct_h->h_comments);
			printf("\np_dl_takeover_struct_h->h_serial_no=%s\n",p_dl_takeover_struct_h->h_serial_no);
			strcpy(p_dl_takeover_struct_h->h_ref_no,"ABCD");
			/*
			p_dl_takeover_struct_h->h_qty=0;
			p_dl_takeover_struct_h->h_takeover_qty=0;
			EXEC SQL UPDATE DL_TAKEOVER SET
			MAKER =:p_intl_envdatastruct_h->usr:p_i_maker,
			MAKER_DT =:chr_sys_access_stamp:p_i_makerdt,
			CHECKER =:p_dl_takeover_struct_h->h_checker:p_i_checker,
			CHECKER_DT =:p_dl_takeover_struct_h->h_checkerdt:p_i_checkerdt,
			STATUS =:p_dl_takeover_struct_h->h_status:l_dl_takeover_struct_i->i_status,
			ACCESSTAMP =:chr_sys_access_stamp:p_i_access_stamp,
			REF_NO =:p_dl_takeover_struct_h->h_ref_no:l_dl_takeover_struct_i->i_ref_no,
			CI_NO =:p_dl_takeover_struct_h->h_ci_no:l_dl_takeover_struct_i->i_ci_no,
			INSTR_CD=:p_dl_takeover_struct_h->h_instr_cd:l_dl_takeover_struct_i->i_instr_cd,
			QTY=:p_dl_takeover_struct_h->h_qty:l_dl_takeover_struct_i->i_qty,
			PHY_FLG =:p_dl_takeover_struct_h->h_phy_flg:l_dl_takeover_struct_i->i_phy_flg,
			TAKEOVER_QTY=:p_dl_takeover_struct_h->h_takeover_qty:l_dl_takeover_struct_i->i_takeover_qty,
			DEPOSITORY=:p_dl_takeover_struct_h->h_depository:l_dl_takeover_struct_i->i_depository,
			COMMENTS=:p_dl_takeover_struct_h->h_comments:l_dl_takeover_struct_i->i_comments
			WHERE
																																													SERIAL_NO =:p_dl_takeover_struct_h->h_serial_no;
			*/

			EXEC SQL UPDATE DL_TAKEOVER  SET 
			MAKER =:p_intl_envdatastruct_h->usr:p_i_maker,
			MAKER_DT =:chr_sys_access_stamp:p_i_makerdt,
			CHECKER =:p_dl_takeover_struct_h->h_checker:p_i_checker,
			CHECKER_DT =:p_dl_takeover_struct_h->h_checkerdt:p_i_checkerdt,
			STATUS =:p_dl_takeover_struct_h->h_status:l_dl_takeover_struct_i->i_status,
			ACCESSTAMP= :p_dl_takeover_struct_h->h_accesstamp  :l_dl_takeover_struct_i->i_accesstamp,
			COMMENTS= :p_dl_takeover_struct_h->h_comments  :l_dl_takeover_struct_i->i_comments
			WHERE
				SERIAL_NO= :p_dl_takeover_struct_h->h_serial_no;
	
			printf("\n sqlca.sqlcode=%d\n",sqlca.sqlcode);			

          
			
		}
	   else
		{	
         
			printf("master level\n");	
			
			printf("\n p_dl_takeover_struct_h->h_accesstamp=%s\n",p_dl_takeover_struct_h->h_accesstamp);
			printf("\n chr_acc_stamp_compare=%s\n",chr_acc_stamp_compare);
			printf("\nIN MASTER LEVEL DELATION \n");
			strcpy(p_dl_takeover_struct_h->h_accesstamp,chr_sys_access_stamp);
			l_dl_takeover_struct_i->i_accesstamp =0;
			strcpy(p_dl_takeover_struct_h->h_status,STATUS_DEL_UAUTH);
			l_dl_takeover_struct_i->i_status =0;
					/*
					EXEC SQL UPDATE DL_TAKEOVER  SET 
            	MAKER =:p_intl_envdatastruct_h->usr:p_i_maker,
					MAKER_DT =:chr_sys_access_stamp:p_i_makerdt,
					CHECKER =:p_dl_takeover_struct_h->h_checker:p_i_checker,
					CHECKER_DT =:p_dl_takeover_struct_h->h_checkerdt:p_i_checkerdt,
            	STATUS =:p_dl_takeover_struct_h->h_status:l_dl_takeover_struct_i->i_status,
					ACCESSTAMP =:chr_sys_access_stamp:p_i_access_stamp,
					REF_NO =:p_dl_takeover_struct_h->h_ref_no:l_dl_takeover_struct_i->i_ref_no,
					
				   CI_NO =:p_dl_takeover_struct_h-> h_ci_no:l_dl_takeover_struct_i->i_ci_no,
					
					INSTR_CD=:p_dl_takeover_struct_h->h_instr_cd:l_dl_takeover_struct_i->i_instr_cd,	
					QTY=:p_dl_takeover_struct_h->h_qty:l_dl_takeover_struct_i->i_qty,													                PHY_FLG =:p_dl_takeover_struct_h->h_phy_flg:l_dl_takeover_struct_i->i_phy_flg,
					TAKEOVER_QTY=:p_dl_takeover_struct_h->h_takeover_qty:l_dl_takeover_struct_i->i_takeover_qty,
						                      
					DEPOSITORY=:p_dl_takeover_struct_h->h_depository:l_dl_takeover_struct_i->i_depository,						                 
					COMMENTS=:p_dl_takeover_struct_h->h_comments:l_dl_takeover_struct_i->i_comments,
					SERIAL_NO= :p_dl_takeover_struct_h->h_serial_no :l_dl_takeover_struct_i->i_serial_no
    
           WHERE                 
			  			REF_NO =:p_dl_takeover_struct_h->h_ref_no;
				     */

						
			EXEC SQL UPDATE DL_TAKEOVER  SET 
			MAKER =:p_intl_envdatastruct_h->usr:p_i_maker,
			MAKER_DT =:chr_sys_access_stamp:p_i_makerdt,
			CHECKER =:p_dl_takeover_struct_h->h_checker:p_i_checker,
			CHECKER_DT =:p_dl_takeover_struct_h->h_checkerdt:p_i_checkerdt,
			STATUS =:p_dl_takeover_struct_h->h_status:l_dl_takeover_struct_i->i_status,
			ACCESSTAMP =:chr_sys_access_stamp:p_i_access_stamp,
			COMMENTS=:p_dl_takeover_struct_h->h_comments:l_dl_takeover_struct_i->i_comments
    
           WHERE                 
			REF_NO =:p_dl_takeover_struct_h->h_ref_no;         
		  
	    	printf("\n sqlca.sqlcode=%d\n",sqlca.sqlcode);    			
			
			}
			IS_ANY_ORA_ERROR;
	  }
		else 
	   {
			if (CO_InsertErr
			(l_debug_info_ptr,
			 ERR_ACCESSSTAMP_CHGD, 
			 APL_NULL_STRING,
			 APL_NULL_STRING,
			 APL_NULL_STRING,
			 __LINE__,
			 __FILE__
			) != APL_SUCCESS)
			
			APL_GOBACK_FAIL;
	   } 
	}


 if (int_error_flag == APL_FAILURE)
	{
		APL_GOBACK_FAIL;
	}
 	APL_GOBACK_SUCCESS

 RETURN_SUCCESS :
	{
		APL_FUNCTION_RET_SUCCESS(APL_OUT_FILE)
		free(l_dl_takeover_struct_i);
		return(APL_SUCCESS);
	}
  RETURN_FAILURE :
	{
 		APL_FUNCTION_RET_FAILURE(APL_OUT_FILE)
		free(l_dl_takeover_struct_i);
		return(APL_FAILURE);
	}
}

