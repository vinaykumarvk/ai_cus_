/*
 *    COPYRIGHT NOTICE
 *
 *   Copyright 2015 Intellect Design Arena Limited. All rights reserved.
 *
 *   These materials are confidential and proprietary to
 *    Intellect Design Arena Limited and no part of these materials should
 *    be reproduced, published, transmitted or distributed in any form or
 *    by any means, electronic, mechanical, photocopying, recording or
 *    otherwise, or stored in any information storage or retrieval system
 *    of any nature nor should the materials be disclosed to third parties
 *    or used in any other manner for which this is not authorized, without
 *    the prior express written authorization of Intellect Design Arena Limited.
 */
/*********************************************************************
 *
 * Module Name         :      DEAL PROCESSING
 *
 * File Name           :      DL_MAP_RESET.pc
 *
 * Description         :      MAPPING_MATCHING_RESET
 *
 *
 *
 *            Version Control Block
 *
 * Date        Version     Author           Description        RFS No.
 * ---------   --------  ---------------  ------------------   ---------
 * 16/02/2006   1.0                          DEAL SETL BLK  HDFCGN_009
 * 30/11/2010   1.0.1.7   Siva Ganapathi   Changes done for ISKB_4396 Reset of Exch order matching for PMS Clients
 * 18/10/2011             Sana Bhatkar     Retro done for AIX mig for Changes done for ISKB_4967 for resetting of deals and orders
 * 09/05/2012             Amit Nair			 ISKB_4755 changes have been reverted as for matched records brokerage was not being adjusted during reset	
 * 25/05/2015             Sharanya Shenoy    Changes done for Lien Release on Reset of Exch order matching incase the lien was already marked. 
 * 01/03/2016             Mrinal Bansal      Changes done to use Exchnage Code in Reset Matching (ISKB_8206)

 *************************************************************************/



#include<stdio_64.h>
#include <time.h>
#include "Intellect_Common.h"
#include "Intellect_Interface.h"
#include "DL_Interface.h"
#include "BT_Common.h"
#include "CR_Common.h"
#include "Intellect_Error.h"
#include "CO_IndStructdef.h"


#define DATA_FIELD_SEPRTR ''
#define DATA_VALUE_SEPRTR ''

#define LIEN_INK_STATUS "IN"
#define LIEN_MOD_STATUS "MI"
#define LIEN_RELFAIL_STATUS "RF"


EXEC SQL INCLUDE SQLCA.H;

int main(int argc,char **argv)  //AIX-Warnings Removal 
{	
	 DEBUG_INFO_STRUCT_H **l_debug_info_ptr = (DEBUG_INFO_STRUCT_H **) NULL;
	 l_debug_info_ptr = (DEBUG_INFO_STRUCT_H **)calloc(1,sizeof(DEBUG_INFO_STRUCT_H *)); 
	 
	
	 INTL_ENV_DATA_STRUCT_H *p_intl_envdatastruct_h;
	 p_intl_envdatastruct_h =(INTL_ENV_DATA_STRUCT_H *) calloc(1,sizeof(INTL_ENV_DATA_STRUCT_H));
	 memset(p_intl_envdatastruct_h,NULL,sizeof(INTL_ENV_DATA_STRUCT_H));
	 APL_MALLOC_FAIL(p_intl_envdatastruct_h);

	 
 	 //Commented for warnings as part of ISKB 1493 short int_ret_val = 0;
	 int l_int_num = 0;
	 int l_int_num1 = 0;
	 //Commented for warnings as part of ISKB 1493 int l_flag = 0;
	 //Commented for warnings as part of ISKB 1493 int int_error_flag = APL_SUCCESS;

	 //Commented for warnings as part of ISKB 1493 char *p_user = NULL;
	 //Commented for warnings as part of ISKB 1493 char *p_filename = NULL;
	 char  **temp = ( char **)NULL;
	 char  **temp1 = ( char **)NULL;
	 char	query[1500] = APL_NULL_STRING;
 	 char	query1[1500] = APL_NULL_STRING;
	 char	query2[1500] = APL_NULL_STRING;
	 char query3[1500] = APL_NULL_STRING;
	 char query4[1500] = APL_NULL_STRING;
	 //Commented for warnings as part of ISKB 1493 char  p_env_str[2000] = APL_NULL_STRING;

	 //Commented for warnings as part of ISKB 1493 char *chr_db_id = NULL;
	 //Commented for warnings as part of ISKB 1493 char *chr_db_pwd = NULL;
	 //Commented for warnings as part of ISKB 1493 char l_cln_code[11] = APL_NULL_STRING;
	 //Commented for warnings as part of ISKB 1493 char l_ref_no[17] = APL_NULL_STRING;	 
	 char l_records[400] = APL_NULL_STRING;
	 char l_pkey[400] = APL_NULL_STRING;
	 //Commented for warnings as part of ISKB 1493 char l_pkey_fail[400] = APL_NULL_STRING;
	 char l_mode[10] = APL_NULL_STRING;
	 char l_status[3] = APL_NULL_STRING;
    char l_contract_cd[17] = APL_NULL_STRING;
	 char l_pkey_temp[400] = APL_NULL_STRING;
	 //Commented for warnings as part of ISKB 1493 char l_pkey_fail_temp[400] = APL_NULL_STRING;
	 char l_contract_key[400] = APL_NULL_STRING;
	 char l_ckey_temp[400] = APL_NULL_STRING;
	 short i_status = 0;
	 short i_contract_cd = 0;
	
	 int i = 0;  
	 int j=0;
	 int x=0;	
	 
	 char chr_l_param_str_both[400]=APL_NULL_STRING;
	 char chr_l_str_client[200]=APL_NULL_STRING;
	 char chr_l_str_refno[200]=APL_NULL_STRING;
	 /* ISKB-401:AmitB:25-08-07	*/
	 char chr_l_str_refno1[200]=APL_NULL_STRING;
  
  /** Added by Vijay For Tolerance Limit Reverse Mapping **/
  char l_client[11]      = APL_NULL_STRING;
  char l_identiy_no[17]  = APL_NULL_STRING;
  char l_note1[261]      = APL_NULL_STRING;
  short i_note1 = 0;
  short i_client = 0;
  short i_identiy_no = 0;
  double l_net_amount_orig = 0;
  short i_net_amount_orig = 0;
  double l_tolerance_limit = 0;
  short i_tolerance_limit = 0;
  char query5[1500] = APL_NULL_STRING;
  //Commented for warnings as part of ISKB 1493 char query6[1500] = APL_NULL_STRING;
  char query7[1500] = APL_NULL_STRING;
  /********************************************************/

  	 /* Added By Gouse for Reset Map Match - ISKB_5999 - Start */
	 char fetch_query[100] = APL_NULL_STRING;
	 char l_client1[11]      = APL_NULL_STRING;
     char l_identiy_no1[17]  = APL_NULL_STRING;
	 char l_seq_no[22] = APL_NULL_STRING;
	 memset(fetch_query,NULL,sizeof(fetch_query));
	 memset(l_client,NULL,sizeof(l_client));
	 memset(l_identiy_no,NULL,sizeof(l_identiy_no));
 	 memset(l_client1,NULL,sizeof(l_client1));
	 memset(l_identiy_no1,NULL,sizeof(l_identiy_no1));
	 memset(l_seq_no,NULL,sizeof(l_seq_no));
	 short l_cond_exists = 0; 
	 /* Added By Gouse for Reset Map Match - ISKB_5999 - End */

	 
       /*Added by Sharanya for Lien Release on Reset Matching:25-May-2015:Start*/
	int l_condition = 0;
	int hvCount = 0; 
	int hvCount1 = 0;
	int l_deal_cd =0;
	int sys_retval = 0;
	char p_lien_release[1000] = APL_NULL_STRING;
	char chr_l_deal_date[APL_DATE_LEN]=APL_NULL_STRING;
	int l_deal_class =0;
	char chr_l_clh_flag[APL_DATE_LEN]=APL_NULL_STRING;
    	time_t hvPrcStrtTime;
    	time_t hvPrcEndTime;
	char chr_l_timeout[4] = APL_NULL_STRING;
	int  hvTimeOut = 0; 
	double diff_seconds; 
	int  hvSleepTime = 0; 
    	int hvFailRec = 0;
	char error[100]= APL_NULL_STRING;
	char *chr_tempchar=NULL;
    	char chr_inifile[PATH_LENGTH];
    	FILE *chr_finifile=NULL;
	char chr_l_sleeptime[2] = APL_NULL_STRING;

	char chr_settl_no[16] = APL_NULL_STRING;
	char chr_exch_cd[4] = APL_NULL_STRING;
	char chr_payout_typ[7] = APL_NULL_STRING;
	memset(chr_payout_typ, APL_NULL_CHAR, sizeof(chr_payout_typ));
	strcpy(chr_payout_typ,"NORMAL"); 
	

	char   chr_err_desc[4001] =APL_NULL_STRING;

        /*Kotubabu-EquityFund-Start*/
	char l_ae_stat[2] = APL_NULL_STRING;
	short l_i_ae_stat=0;
        char l_host_date[APL_DATE_LEN] = APL_NULL_STRING;
        short l_i_host_date =0;
        char l_clh_flag[2] = APL_NULL_STRING;
        char l_pltopl_flg[2]=APL_NULL_STRING;
        short l_i_pltopl_flg=0;
        int skp_val;
        /*Kotubabu-EquityFund-End*/
       
	double l_deal_net_amt = 0.0;

	char g_pdf_db_url[100] = APL_NULL_STRING;
	memset(g_pdf_db_url, APL_NULL_CHAR, sizeof(g_pdf_db_url));
	
	char g_pdf_driver_class[100] = APL_NULL_STRING;
	memset(g_pdf_driver_class, APL_NULL_CHAR, sizeof(g_pdf_driver_class));

	char g_pdf_db_user[APL_USERID_LEN] = APL_NULL_STRING;
	memset(g_pdf_db_user, APL_NULL_CHAR, sizeof(g_pdf_db_user));

	char g_pdf_db_password[50] = APL_NULL_STRING;
	memset(g_pdf_db_password, APL_NULL_CHAR, sizeof(g_pdf_db_password));

	char g_combined_param[351] = APL_NULL_STRING;
	memset(g_combined_param, APL_NULL_CHAR, sizeof(g_combined_param));

	char  chr_custody_id_b[APL_USERID_LEN]               =  APL_NULL_STRING;
	memset(chr_custody_id_b, APL_NULL_CHAR, sizeof(chr_custody_id_b));

	char chr_lien_status[APL_STATUS_LEN] = APL_NULL_STRING;
	memset(chr_lien_status, APL_NULL_CHAR, sizeof(chr_lien_status));

	short i_lien_status = 0;
	short i_exch_code = 0;
	short i_settl_no = 0;
	short i_deal_date = 0;

	if(!(chr_tempchar=getenv("INTL_ROOT_PATH")))
        		APL_GOBACK_FAIL

	sprintf(chr_inifile,"%s/intl_sun.cfg",chr_tempchar);
	if(!(chr_finifile=fopen(chr_inifile,"r")))
	    		APL_GOBACK_FAIL

	if (APL_FAILURE == CO_ReadToken(chr_finifile,"DB_URL",g_pdf_db_url,l_debug_info_ptr))
        {
                printf("Error : DB_URL  not set in intl_sun.cfg File \n");
                APL_GOBACK_FAIL
        }

        if (APL_FAILURE == CO_ReadToken(chr_finifile,"DRIVER_CLASS",g_pdf_driver_class,l_debug_info_ptr))
        {
                printf("Error : DRIVER_CLASS  not set in intl_sun.cfg File \n");
                APL_GOBACK_FAIL
        }

	if(CO_ReadToken(chr_finifile,"INTL_LIEN_SLEEP",chr_l_sleeptime,l_debug_info_ptr)==APL_FAILURE)
	{
		printf("CO_ReadToken Failed for token LIEN SLEEP \n");
	       	APL_GOBACK_FAIL
	}
        printf("\n SLEEP TIME FOR LIEN: chr_l_sleeptime :[%s]",chr_l_sleeptime);
        hvSleepTime = atoi(chr_l_sleeptime);
        printf("\n hvSleepTime:[%d]",hvSleepTime);

	if(CO_ReadToken(chr_finifile,"INTL_LIEN_TIMEOUT",chr_l_timeout,l_debug_info_ptr)==APL_FAILURE)
	{
	       	printf("CO_ReadToken Failed for token LIEN TIMEOUT\n");
	       	APL_GOBACK_FAIL
	}
        printf("\n TIMEOUT FOR LIEN: chr_l_timeout :[%s]",chr_l_timeout);

        hvTimeOut = atoi(chr_l_timeout);
        printf("\n hvTimeOut:[%d]",hvTimeOut);
        fclose(chr_finifile);

	APL_FETCH_DB_LOGIN_DETAILS(l_ptr_ini_file, chr_custody_id_b,g_pdf_db_user,g_pdf_db_password,APL_OUT_FILE,&l_debug_info_ptr)

	printf("\n debug:::: g_pdf_db_user = |%s| g_pdf_db_password = |%s|",g_pdf_db_user, g_pdf_db_password);

	printf("\n g_pdf_db_url = |%s| g_pdf_driver_class = |%s|",g_pdf_db_url, g_pdf_driver_class);

	strcpy(g_combined_param,g_pdf_driver_class);
	strcat(g_combined_param,",");
	strcat(g_combined_param,g_pdf_db_url);
	strcat(g_combined_param,",");
	strcat(g_combined_param,g_pdf_db_user);
	strcat(g_combined_param,",");
	strcat(g_combined_param,g_pdf_db_password);
	strcat(g_combined_param,",");

	EXEC SQL VAR chr_l_deal_date IS STRING;

	EXEC SQL VAR chr_l_clh_flag IS STRING;

	EXEC SQL VAR chr_settl_no IS STRING;

	EXEC SQL VAR chr_exch_cd IS STRING;

	EXEC SQL VAR chr_err_desc IS STRING;
/*Added by Sharanya for Lien Release on Reset Matching:25-May-2015:End*/

/*Priyanka - MCS-SX UAT issue -to reset  NRI Clients and exchange order with master as client*/
/*Priyanka - MCS-SX UAT issue - NRI clients
	 char l_cln_typ[2]=APL_NULL_STRING;
	 short i_l_cln_typ=0;
	 char l_cln_master[11]= APL_NULL_STRING;
	 short i_l_cln_master=0;
	  memset(l_cln_master,NULL,sizeof(l_cln_master));
	  EXEC SQL VAR l_cln_typ IS STRING;
	  EXEC SQL VAR l_cln_master IS STRING;*/
	 char l_cp_code[21]= APL_NULL_STRING;
	 char l_cli_code[11]= APL_NULL_STRING;
	 int l_count=0;
	 short i_l_cli_code=0;
	 short i_l_cp_code=0;
  	 memset(l_cli_code,NULL,sizeof(l_cli_code));
     EXEC SQL VAR l_cli_code IS STRING;
	memset(l_cp_code,NULL,sizeof(l_cp_code));
     EXEC SQL VAR l_cp_code IS STRING;
/*ISKB_8206 : Using Exchnage Code in Reset Matching - Changes by Mrinal - Start*/
     char l_exch_code[4]= APL_NULL_STRING;
     short i_l_exch_code=0;
     memset(l_exch_code,NULL,sizeof(l_exch_code));
     EXEC SQL VAR l_exch_code IS STRING;
/*ISKB_8206 : Using Exchnage Code in Reset Matching- Changes by Mrinal - End*/
/*Priyanka - MCS-SX UAT issue -to reset  NRI Clients and exchange order with master as client */
	 char  chr_g_log_buffer[261] = APL_NULL_STRING;
	 FILE *l_logfile = (FILE *)NULL;
//Commented for warnings as part of ISKB 1493	 FILE *p_logfile = NULL;

  EXEC SQL VAR l_client IS STRING;
  EXEC SQL VAR l_identiy_no IS STRING;
  EXEC SQL VAR l_client1 IS STRING;
  EXEC SQL VAR l_identiy_no1 IS STRING;
  EXEC SQL VAR l_note1 IS STRING;

	 printf("ENV 0 |%s|\n",argv[0]); 	 
 	 printf("ENV 1 |%s|\n",argv[1]); 	 
 	 printf("ENV 2 |%s|\n",argv[2]); 
	 printf("ENV 3 |%s|\n",argv[3]); 
	 printf("ENV 4 |%s|\n",argv[4]); 
	 printf("ENV 5 |%s|\n",argv[5]); 
	 printf("ENV 6 |%s|\n",argv[6]); 
	 printf("ENV 7 |%s|\n",argv[7]); 
	 printf("ENV 8 |%s|\n",argv[8]); 
     			
	strcpy(l_mode,argv[4]);
	printf("MODE IS |%s|\n",l_mode);
	if(	CO_Get_DBConnect(l_debug_info_ptr) == APL_FAILURE)
	{
		APL_GOBACK_FAIL
	}

	/***********	Processing INPUT PARAMETERS	START	**********/
	printf("ENTERING*******AMISH****\n");

	if (APL_FAILURE == CO_Rtv_RptFileName( "7g",
				APL_LOGFILE_DESC,
				100,
				argv[5],
				argv,
				&l_logfile,
				l_debug_info_ptr ) ) 
		{
			CO_ProcMonitor(l_logfile, "Failure from CO RTY:", l_debug_info_ptr, NULL);
			APL_GOBACK_FAIL
		} 


	
	if(BT_Status_Update(argv[0],
				argv[1],
				argv[2],
				APL_STARTED_STATUS,
				l_debug_info_ptr) ==APL_FAILURE)
	{
		APL_GOBACK_FAIL
	}

	/* Added By Gouse for Reset Map Match - ISKB_5999 - Start */
	if (APL_FAILURE == CO_RtvSysParams(l_debug_info_ptr)) 
    	{
         	CO_ProcMonitor(l_logfile, "Error In Getting System Parameters", NULL, NULL);
         	//CO_PrnErr(l_debug_info_struct);
         	APL_GOBACK_FAIL
    	}

	
	IF_COND_EXISTS("GENERIC","DL_MAP_RESET")
	{
		l_cond_exists = 1;	
	}
	else
		l_cond_exists = 0;
	
	if(l_cond_exists == 0)
	{
		/* Added By Gouse for Reset Map Match - ISKB_5999 - End */
	if(APL_FAILURE == CO_SplitStr(argv[9],
				'|',
				&l_int_num,&temp))
		{
			CO_ProcMonitor(l_logfile, "Failure from StrSplitFn", l_debug_info_ptr, NULL);
			APL_GOBACK_FAIL

		}
		
    if(sqlca.sqlcode)
		{
			APL_GOBACK_FAIL
		}

	printf("\n no of arguments are |%d|\n", l_int_num);
	
	for(i=0;i<l_int_num;i++)
	{	
		printf("\nENTERING FOR LOOP\n");
		strcpy(l_records,temp[i]);
		printf("\n  argument |%d| is|%s|",i,temp[0]);
		printf("\n  l_records is |%s|",l_records);//Kotubabu-EquityFund
		skp_val=0; //Kotubabu-EquityFund
		memset(l_pltopl_flg, APL_NULL_CHAR, sizeof(l_pltopl_flg)); //Kotubabu-EquityFund
        memset(l_host_date, APL_NULL_CHAR, sizeof(l_host_date)); //Kotubabu-EquityFund
	   /** Changed By Vijay **/	
		EXEC SQL SELECT A.DEAL_STAT ,A.CONTRACT_CD,A.PLTOPL_FLG,A.HOST_DATE
             INTO :l_status:i_status,
                  :l_contract_cd:i_contract_cd,
		  :l_pltopl_flg:l_i_pltopl_flg,
	          :l_host_date:l_i_host_date
             FROM DL_DEAL A
		         WHERE A.client||';'||A.identiy_no in (:l_records);

		/*
		EXEC SQL SELECT DEAL_STAT ,CLH_FLG INTO :l_status,:l_clh_flg from DL_DEAL
		WHERE CLIENT = :l_cln_code
		AND IDENTIY_NO = :l_ref_no;
		*/

		printf("\n Failed SELECTTING OF DEAL DATA  |%d|\n ",sqlca.sqlcode);
		IS_ANY_ORA_ERROR
		printf("STATUS IS |%s|\n",l_status);
		printf("MODE IS |%s|\n",l_mode);
		printf("Pltopl_flg IS |%s| l_host_date |%s|\n",l_pltopl_flg,l_host_date); //Kotubabu-EquityFund
	        /*Kotubabu-EquityFund-Start*/	
		if(strcmp(l_pltopl_flg,"B")==0 || strcmp(l_pltopl_flg,"C")==0 || strcmp(l_pltopl_flg,"R")==0 || strcmp(l_pltopl_flg,"G")==0)
        {
                           memset(chr_g_log_buffer, NULL, sizeof(chr_g_log_buffer));
                           sprintf(chr_g_log_buffer,"\n** Deal of client ; Reference No |%s| is blocked or Released but not Authorize ***\n",l_records);
                           fprintf(l_logfile,"%s",chr_g_log_buffer);
                           printf("\n Deal is Blocked Client ; reference |%s|",l_records);
						   skp_val = 1;
        }
        else {
	    if (!strcmp(l_host_date,APL_NULL_STRING)==0 || !strcmp(l_host_date,"")==0)
         {
           memset(l_ae_stat, APL_NULL_CHAR, sizeof(l_ae_stat));
           memset(l_clh_flag, APL_NULL_CHAR, sizeof(l_clh_flag));
	       EXEC SQL SELECT DISTINCT  STATUS  into :l_ae_stat:l_i_ae_stat
           	    FROM PRO_ACCTENT  WHERE (SUBSTR(DEAL_IDENT,0,INSTR(DEAL_IDENT,'|',1,2)-1))= (SELECT CLIENT||'|'||IDENTIY_NO FROM DL_DEAL WHERE client||';'||identiy_no in(:l_records)) 
                AND ACC_TYPE='C';
						
	        IS_ANY_ORA_ERROR
		    if(!strcmp(l_ae_stat,APL_NULL_STRING)==0)
		    {
			     strcpy(l_clh_flag,"E");
	        }
	        printf("\n Flag is |%s| and AE_STAT is |%s|",l_clh_flag,l_ae_stat);

            if((strcmp(l_clh_flag,"E")==0) && (strcmp(l_ae_stat,"G")==0))
    	       {
	            memset(chr_g_log_buffer, NULL, sizeof(chr_g_log_buffer));
		        sprintf(chr_g_log_buffer,"\n**Accounting Entries of Deal of client ; Reference No |%s| is Generated but it is is not passed \n",l_records);
		        fprintf(l_logfile,"%s",chr_g_log_buffer);
            	printf("\n Accounting Entries of Deal of Client ; Reference No |%s| is  Generated but it is not passed ",l_records);
                skp_val = 1;
	          }
          }
		 }
		 
         if(skp_val == 0)
		 {    /*Kotubabu-EquityFund-End*/
		 if ((strcmp(l_mode,"RMP")==0)&&(strcmp(l_status,"RC")==0)) 		     
			{	
				printf("\nSTATUS AND MODE CONDITION SATISFIED\n");
				strcat(l_pkey,"'");
				strcat(l_pkey,l_records);
				strcat(l_pkey,"'");
				strcat(l_pkey,",");
				strcpy(l_records,APL_NULL_STRING);
				strcat(l_contract_key,"'");
				strcat(l_contract_key,l_contract_cd);
				strcat(l_contract_key,"'");
				strcat(l_contract_key,",");
				
			
			}
		if ((strcmp(l_mode,"RMH")==0)&&(strcmp(l_status,"PM")==0)) 		     
			{	
				printf("\nSTATUS AND MODE CONDITION SATISFIED\n");
				strcat(l_pkey,"'");
				strcat(l_pkey,l_records);
				strcat(l_pkey,"'");
				strcat(l_pkey,",");
				strcpy(l_records,APL_NULL_STRING);
			
			}
		 } //Kotubabu-EquityFund

	}

         if (strcmp(l_pkey,APL_NULL_STRING)==0) /*Kotubabu-EquityFund-Start*/
         {
           printf("\nFinal PRIMART string is |%s|\n",l_pkey_temp);
           if(BT_Status_Completed(argv[0],
                                argv[1],
                                argv[2],
                                l_debug_info_ptr)   ==  APL_FAILURE )
            {
                APL_GOBACK_FAIL
            }

           CO_ProcMonitor(l_logfile, "SUCESS IN MAIN", l_debug_info_ptr, NULL);
           CO_Proc_RptClose(l_logfile, l_debug_info_ptr);
          
           EXEC SQL COMMIT WORK;
           if(sqlca.sqlcode != 0)APL_GOBACK_FAIL
                exit(0);
         }  /*Kotubabu-EquityFund-End*/

	printf("\nPRIMARY KEY STRING FOR  RECORDS IS |%s|\n",l_pkey);	
	

	strcpy(l_pkey_temp,APL_NULL_STRING);
	strncpy(l_pkey_temp,l_pkey,strlen(l_pkey)-1);
	printf("final PRIMART string is |%s|\n",l_pkey_temp);
	
	if(strcmp(l_contract_key,APL_NULL_STRING)!=0)
 	 {
		strcpy(l_ckey_temp,APL_NULL_STRING);
		strncpy(l_ckey_temp,l_contract_key,strlen(l_contract_key)-1);
		printf("final CONTRACT string is |%s|\n",l_ckey_temp);
	 }
	if(strcmp(l_mode,"RMP")==0)
	{
		printf("ENTERING UPDATE OF MAP RESET\n");
		
		sprintf(query,"UPDATE dl_deal set deal_stat = 'AA' ,FAILREASON_CD=NULL	WHERE client||';'||identiy_no in(%s)",l_pkey_temp);
		printf("\nQUERY IS |%s|\n",query);
		EXEC SQL EXECUTE IMMEDIATE :query;
		printf("\n Failed updating OF DEAL STATUS TO AA  |%d|\n ",sqlca.sqlcode);
		IS_ANY_ORA_ERROR

		sprintf(query1,"UPDATE dl_deal set contract_cd = null,FAILREASON_CD=NULL 	WHERE client||';'||identiy_no	in(%s)",l_pkey_temp);
		printf("\nQUERY1 IS |%s|\n",query1);
		EXEC SQL EXECUTE IMMEDIATE :query1;
		printf("\n Failed updating OF CONTRACT CD |%d|\n ",sqlca.sqlcode);

		IS_ANY_ORA_ERROR
      
		sprintf(query2,"UPDATE dl_bcn set dl_ref_no = null	WHERE contract_cd 	in(%s)",l_ckey_temp);
		printf("\nQUERY2 IS |%s|\n",query2);
		EXEC SQL EXECUTE IMMEDIATE :query2;
		printf("\n Failed updating OF CONTRACT CD |%d|\n ",sqlca.sqlcode);
       
		IS_ANY_ORA_ERROR
      
		sprintf(query3,"UPDATE dl_bcn set STATUS = 'AA'	WHERE contract_cd 	in(%s)",l_ckey_temp);
		printf("\nQUERY3 IS |%s|\n",query3);
		EXEC SQL EXECUTE IMMEDIATE :query3;
		printf("\n Failed updating OF CONTRACT CD |%d|\n ",sqlca.sqlcode);
       
		IS_ANY_ORA_ERROR

  		sprintf(query4,"DELETE FROM DL_BCNMAP_RPT WHERE  DL_CLIENT || ';'|| DL_REF_NO IN (%s)",l_pkey_temp);			
		printf("\nQUERY4 IS |%s|\n",query4);
		EXEC SQL EXECUTE IMMEDIATE :query4;
		printf("\n Failed deletion of report table |%d|\n ",sqlca.sqlcode);

    
    /** Changes By Vijay Tolerance Limit Enh **/
    printf("\n *** Tolerance Limit ---|%lf|\n",l_tolerance_limit);

      sprintf(query5,
      "SELECT A.CLIENT,A.IDENTIY_NO,A.NET_AMOUNT_ORIG,A.TOLERANCE_LIMIT,B.INFO1 FROM DL_BCN_TOL A,DL_DEAL B WHERE A.CLIENT || ';' || A.IDENTIY_NO IN (%s)",
      l_pkey_temp);

      strcat(query5," AND A.CLIENT = B.CLIENT and A.IDENTIY_NO = B.IDENTIY_NO");

      printf("Cursor Query is --|%s|\n",query5);

      EXEC SQL PREPARE S FROM :query5;
      EXEC SQL DECLARE C CURSOR FOR S;
      EXEC SQL OPEN C ;

      for(;;)   
      {
          memset(l_client,APL_NULL_CHAR,11);
          memset(l_identiy_no,APL_NULL_CHAR,17);
          memset(l_note1,APL_NULL_CHAR,261);
          l_net_amount_orig = 0;
          l_tolerance_limit = 0;
          i_client = 0;
          i_identiy_no = 0;
          i_net_amount_orig = 0;
          i_tolerance_limit = 0;
          i_note1 = 0;

				EXEC SQL FETCH C INTO :l_client:i_client,
                                :l_identiy_no:i_identiy_no,
                                :l_net_amount_orig:i_net_amount_orig,
                                :l_tolerance_limit:i_tolerance_limit,
                                :l_note1:i_note1;

          if(APL_ZERO_RESULT_SET)
          {
					break;
				}

          printf("Original Net Amount --|%lf|\n",l_net_amount_orig);
          printf("\n *** Tolerance Limit ---|%lf|\n",l_tolerance_limit);
          printf("l_info1--|%s|\n",l_note1);

          if(l_tolerance_limit > 0)
          {
          	EXEC SQL UPDATE DL_DEAL A 
                   	SET A.NET_AMT = :l_net_amount_orig,
                            A.INFO1 = SUBSTR(:l_note1,1,INSTR(:l_note1,'|')-1)
                   	WHERE CLIENT = :l_client
                     	AND IDENTIY_NO = :l_identiy_no;

					IS_ANY_ORA_ERROR
				}

				
      }

      EXEC SQL CLOSE C;

      /*  
      printf("Original Net Amount --|%lf|\n",l_net_amount_orig);
      printf("Updating Net Amount to Original Value For |%s|\n",l_pkey_temp); */
   
      /*sprintf(query7,"DELETE FROM DL_BCN_TOL WHERE CLIENT || ';' || IDENTIY_NO = (%s)",l_pkey_temp);Commented by JC*/

	/* Added by JC - rectified query above - replaced = with IN */
	sprintf(query7,"DELETE FROM DL_BCN_TOL WHERE CLIENT || ';' || IDENTIY_NO IN (%s)",l_pkey_temp);
		  printf("\nQUERY7 IS |%s|\n",query7);
		  EXEC SQL EXECUTE IMMEDIATE :query7;
		  printf("\n SQLCA.SQLCODE For DELETING Record From DL_BCN_TOL |%d|\n ",sqlca.sqlcode);

	}
   
	if(strcmp(l_mode,"RMH")==0)
	{
		printf("ENTERING UPDATE OF MATCH RESET\n");
/*		
		sprintf(query,"UPDATE dl_deal set deal_stat = 'RC' 	WHERE client||';'||identiy_no in(%s)",l_pkey_temp);
		printf("\nQUERY IS |%s|\n",query);
		EXEC SQL EXECUTE IMMEDIATE :query;
		printf("\n Failed updating OF DEAL STATUS TO PM  |%d|\n ",sqlca.sqlcode);
		IS_ANY_ORA_ERROR

		sprintf(query1,"UPDATE dl_exchgord_upld set STATUS = 'AA' WHERE client||';'||deal_ref_no in(%s)",l_pkey_temp);
		printf("\nQUERY1 IS |%s|\n",query1);
		EXEC SQL EXECUTE IMMEDIATE :query1;
		printf("\n Failed updating OF exchorder status |%d|\n ",sqlca.sqlcode);

		IS_ANY_ORA_ERROR
*/	
		
/*		sprintf(query,"UPDATE dl_deal a SET deal_stat='RC',is_matched=NULL ,brokercomm =(SELECT DECODE(a.deal_cd,'1',a.brokercomm-b.brk_adjust,'3',a.brokercomm-b.brk_adjust,'2',a.brokercomm+b.brk_adjust,'4',a.brokercomm+b.brk_adjust) FROM dl_match_deals b WHERE b.client=a.client and b.ident_no=a.identiy_no) WHERE  deal_stat='PM' AND client||';'||identiy_no IN(%s)",l_pkey_temp);
		
*/		/* ISKB-401:AmitB:25-08-07	*/
		/*Commented and Added below Query by Vikram for--ISKB_4755--Start*/
		/* Uncommented below code bcoz when matched records are resetted then broker commission is not getting adjusted [Issue identified during Kotak Upgrade Testing] */
		sprintf(query,"UPDATE dl_deal a SET deal_stat='RC',is_matched=NULL,brokercomm=DECODE(deal_cd,'1',brokercomm+amt_differ,'3',brokercomm+amt_differ,'2',brokercomm-amt_differ,'4',brokercomm-amt_differ),amt_differ=0 WHERE  deal_stat='PM' AND client||';'||identiy_no IN(%s)",l_pkey_temp);
		/*Commented and Added below Query by Vikram for--ISKB_4755--End*/
		//sprintf(query,"UPDATE dl_deal a SET deal_stat='RC',is_matched=NULL, amt_differ=0 WHERE  deal_stat='PM' AND client||';'||identiy_no IN(%s)",l_pkey_temp);
		printf("\n QUERY IS |%s|\n",query);
		EXEC SQL EXECUTE IMMEDIATE :query;
		printf("\n Error while Updating DEAL 1st |%d|\n ",sqlca.sqlcode);
		IS_ANY_ORA_ERROR

		sprintf(query1,"UPDATE dl_exchgord_upld SET status = 'AA' , deal_ref_no=NULL, matched=NULL WHERE status ='PM' AND client||';'||deal_ref_no in(%s)",l_pkey_temp);	

		printf("\n QUERY1 IS |%s|\n",query1);
		EXEC SQL EXECUTE IMMEDIATE :query1;
		printf("\n Error while Updating exchorder 1st |%d|\n ",sqlca.sqlcode);
		IS_ANY_ORA_ERROR
		
	}


		for(j=0;j<l_int_num;j++)
		{
			sprintf(chr_l_param_str_both,"%s;",temp[j]);
		

		printf("\n String With ; separated Client & Ref No=|%s| \n",chr_l_param_str_both);

		if(APL_FAILURE == CO_SplitStr(chr_l_param_str_both,
												';',
												&l_int_num1,&temp1))
			{
					CO_ProcMonitor(l_logfile, "Failure from StrSplitFn", l_debug_info_ptr, NULL);															APL_GOBACK_FAIL
			}

		/* ISKB-401:AmitB:25-08-2007 */
		  for(x=0; x<l_int_num1;)
		  {
				strcpy(chr_l_str_refno1,temp1[x+1]);
				sprintf(chr_l_str_client,temp1[x]);
				sprintf(chr_l_str_refno,"%s%c%s%c%s","%",DATA_FIELD_SEPRTR,temp1[x+1],DATA_VALUE_SEPRTR,"%");
				
				printf("\n Client=|%s| DealRefNo=|%s| Orig_chr_l_str_refno1=|%s| \n",chr_l_str_client,chr_l_str_refno,chr_l_str_refno1);

				/* SLB CHNGS - AMISH 02/04/2008 */
				/*Query Modified by siva.ganapathi for ISKB_4396 -- resetting exch order matching for PMS clients on 30-Nov-2010 started*/
				Alert("Before Update of dl_exchgord_upld in DL_MAP_RESET.pc"); 
				EXEC SQL UPDATE dl_exchgord_upld
					SET status = 'AA' , deal_ref_no=NULL, matched=NULL
					WHERE (client,order_no) IN
						(SELECT b.cln_code ,a.order_no FROM dl_match_rpt a,mt_cli_exch_map b 
						WHERE 
					   (
							( a.client=b.cln_exch_map_code AND 
							A.MKT_TYPE !=  DECODE(a.exch_code,'NSE','23','BSE','18',' '))/*Priyanka - added default condition in decode for MCS*/
						OR
							(a.client=b.slb_exch_map_code AND 
							A.MKT_TYPE =  DECODE(a.exch_code,'NSE','23','BSE','18',' '))
					     )
						/*AND b.cln_code=:chr_l_str_client */
						AND a.client in (select cln_exch_map_code from mt_cli_exch_map where cln_code=:chr_l_str_client)
						AND deal_ref_no LIKE :chr_l_str_refno)
						AND status='PM';

				Alert("After Update of dl_exchgord_upld in DL_MAP_RESET.pc");

				/*Query Modified by siva.ganapathi for ISKB_4396 -- resetting exch order matching for PMS clients on 30-Nov-2010 Ended*/
						
				printf("\n sqlcode order update=|%d| \n",sqlca.sqlcode);
				IS_ANY_ORA_ERROR
				
				/* SLB CHNGS - AMISH 02/04/2008 */
                                 /* Retro Done for AIX migration */
                                /* Changes done for ISKB_4967 by Vilin Patil----started */ 
				EXEC SQL UPDATE dl_deal SET is_matched=NULL,deal_stat='RC'
					WHERE (client,identiy_no) IN
					(SELECT b.cln_code ,:chr_l_str_refno1 FROM dl_match_rpt a,mt_cli_exch_map b
					 WHERE 
					 (
							(a.client=b.cln_exch_map_code AND 
							A.MKT_TYPE !=  DECODE(a.exch_code,'NSE','23','BSE','18',' '))/*Priyanka - added default condition in decode for MCS*/
					    OR
							(a.client=b.slb_exch_map_code AND 
							A.MKT_TYPE =  DECODE(a.exch_code,'NSE','23','BSE','18',' '))
					  )
					 AND deal_ref_no LIKE :chr_l_str_refno
                                         AND b.cln_code= :chr_l_str_client
    				 AND deal_stat='PM');
				printf("\n sqlcode deal update=|%d| \n",sqlca.sqlcode);
				IS_ANY_ORA_ERROR
                              /* Changes done for ISKB_4967 by Vilin Patil -----ended */ 
				x=x+2;
			}

	     }
	}		

	/* Added By Gouse for Reset Map Match - ISKB_5999 - Start */
	else if(l_cond_exists == 1)
	{
		strcpy(l_seq_no,argv[9]);
		Alert("l_seq_no == %s ",l_seq_no);
		fflush(stdout);
		strcpy(fetch_query,"SELECT key_values from GN_BATCH_INTERMEDIATE where seq_no = ");
		strcat(fetch_query,l_seq_no);
		Alert("\nChk : Query Formed : %s",fetch_query);
		fflush(stdout);
		EXEC SQL PREPARE S FROM :fetch_query;
		printf("ORA for prepare query - [%d]\n", sqlca.sqlcode);
		EXEC SQL DECLARE dl_map_reset_cur CURSOR FOR S;
		printf("ORA for declare query - [%d]\n", sqlca.sqlcode);
		IS_ANY_ORA_ERROR;
		
		EXEC SQL OPEN dl_map_reset_cur;
		printf("ORA for open query - [%d]\n", sqlca.sqlcode);
		IS_ANY_ORA_ERROR;

		for(;;)
		{
			EXEC SQL FETCH dl_map_reset_cur into :l_records;
			printf("ORA after Fetch of dl_map_reset_cur - [%d]\n", sqlca.sqlcode);

			if (sqlca.sqlcode == 1403)
   			{
			   Alert("Closing Cursor");
			   fflush(stdout);
			   EXEC SQL CLOSE dl_map_reset_cur;
			   IS_ANY_ORA_ERROR;
			   break;
			}

			if(APL_FAILURE == CO_SplitStr(l_records, ';', &l_int_num1,&temp1))
			{
				CO_ProcMonitor(l_logfile, "Failure from StrSplitFn", l_debug_info_ptr, NULL);
				APL_GOBACK_FAIL
			}

			memset(l_client1,NULL,sizeof(l_client1));
			memset(l_identiy_no1,NULL,sizeof(l_identiy_no1));
			strcpy(l_client1,temp1[0]);
			strcpy(l_identiy_no1,temp1[1]);

			Alert("l_client1 : %s and l_identiy_no1 : %s",l_client1,l_identiy_no1);
			fflush(stdout);

			/*Kotubabu-EquityFund-Start*/
                        memset(l_pltopl_flg, APL_NULL_CHAR, sizeof(l_pltopl_flg));
                        memset(l_host_date, APL_NULL_CHAR, sizeof(l_host_date));
                        EXEC SQL SELECT PLTOPL_FLG,HOST_DATE into :l_pltopl_flg:l_i_pltopl_flg ,:l_host_date:l_i_host_date FROM DL_DEAL WHERE CLIENT=:l_client1 AND IDENTIY_NO=:l_identiy_no1;

                        IS_ANY_ORA_ERROR

                        printf("\n PLTOPL Flag is |%s| Host_date is |%s|",l_pltopl_flg,l_host_date);
                        if(strcmp(l_pltopl_flg,"B")==0 || strcmp(l_pltopl_flg,"C")==0 || strcmp(l_pltopl_flg,"R")==0 || strcmp(l_pltopl_flg,"G")==0)
                        {
                           memset(chr_g_log_buffer, NULL, sizeof(chr_g_log_buffer));
                           sprintf(chr_g_log_buffer,"\n** Deal of client |%s|,Reference No |%s| is blocked or Released but not Authorize ***\n",l_client1,l_identiy_no1);
                           fprintf(l_logfile,"%s",chr_g_log_buffer);
                           printf("\n Deal is Blocked Client |%s| reference |%s|",l_client1,l_identiy_no1);
                           continue;
                        }
                        if(!strcmp(l_host_date,APL_NULL_STRING)==0 || !strcmp(l_host_date,"")==0)
                        {
                           memset(l_ae_stat, APL_NULL_CHAR, sizeof(l_ae_stat));
                           memset(l_clh_flag, APL_NULL_CHAR, sizeof(l_clh_flag));
			   EXEC SQL SELECT DISTINCT  STATUS  into :l_ae_stat:l_i_ae_stat
 			            FROM PRO_ACCTENT  WHERE (SUBSTR(DEAL_IDENT,0,INSTR(DEAL_IDENT,'|',1,2)-1))= (SELECT CLIENT||'|'||IDENTIY_NO FROM DL_DEAL WHERE CLIENT=:l_client1 AND IDENTIY_NO=:l_identiy_no1) AND ACC_TYPE='C'; 
						
	           IS_ANY_ORA_ERROR
		       if(!strcmp(l_ae_stat,APL_NULL_STRING)==0)
		       {
			     strcpy(l_clh_flag,"E");
		       }
	           printf("\n Flag is |%s| and AE_STAT is |%s|",l_clh_flag,l_ae_stat);

               if((strcmp(l_clh_flag,"E")==0) && (strcmp(l_ae_stat,"G")==0))
       	       {
						memset(chr_g_log_buffer, NULL, sizeof(chr_g_log_buffer));
						sprintf(chr_g_log_buffer,"\n**Accounting Entries of Deal of client |%s| and Reference No |%s| is Generated but it is is not passed \n",l_client1,l_identiy_no1);
						fprintf(l_logfile,"%s",chr_g_log_buffer);
						printf("\n Accounting Entries of Deal of Client |%s| and Reference No |%s| is Generated but it is not passed ",l_client1,l_identiy_no1);
                                                 continue;
	       }
                       }  /*Kotubabu-EquityFund-End*/
			IF_COND_EXISTS("RESET","LIEN_RL_ON_RESET")
			{
				memset(chr_l_deal_date,NULL,sizeof(chr_l_deal_date));
        			memset(chr_l_clh_flag,NULL,sizeof(chr_l_clh_flag));
        			memset(chr_settl_no, NULL, sizeof(chr_settl_no));
        			memset(chr_exch_cd, NULL, sizeof(chr_exch_cd));
        			l_deal_cd = 0;
        			l_deal_class = 0;

				EXEC SQL SELECT DEAL_STAT ,CONTRACT_CD, to_char(A.DEAL_DATE,'dd/mm/yyyy'),A.DEAL_CD,A.DL_CLASS,A.CLH_FLG, A.SETTLEMENT_NO, A.EXCH_CODE, B.STATUS,A.NET_AMT
					into :l_status:i_status,:l_contract_cd:i_contract_cd,
						:chr_l_deal_date:i_deal_date,
				                :l_deal_cd,
                				:l_deal_class,
                				:chr_l_clh_flag,
                				:chr_settl_no:i_settl_no,
                				:chr_exch_cd:i_exch_code,
						:chr_lien_status:i_lien_status,
						:l_deal_net_amt
				from DL_DEAL A,DL_LIEN B
        			WHERE A.CLIENT=B.CLIENT(+)
        			AND A.IDENTIY_NO = B.REF_NO(+)
        			AND A.client= :l_client1 AND
        			A.IDENTIY_NO= :l_identiy_no1;

				IS_ANY_ORA_ERROR;
			}
			else
			{
			EXEC SQL SELECT DEAL_STAT ,CONTRACT_CD INTO :l_status:i_status,:l_contract_cd:i_contract_cd 
				 from DL_DEAL 
				 WHERE client= :l_client1 AND IDENTIY_NO = :l_identiy_no1;	
			printf("ORA after select from DL_DEAL - [%d]\n", sqlca.sqlcode);
			IS_ANY_ORA_ERROR;
                        }

			memset(chr_l_str_refno, NULL, sizeof(chr_l_str_refno));
			sprintf(chr_l_str_refno,"%s%c%s%c%s","%",DATA_FIELD_SEPRTR,l_identiy_no1,DATA_VALUE_SEPRTR,"%");
			Alert("chr_l_str_refno is |%s|",chr_l_str_refno);

	//Added by Sharanya Shenoy for Lien release on Reset Matching/Mapping:start
	IF_COND_EXISTS("RESET","LIEN_RL_ON_RESET")
	{
		if(i_lien_status != -1 && (strcmp(chr_lien_status,LIEN_INK_STATUS) ==0 || strcmp(chr_lien_status,LIEN_MOD_STATUS) == 0 || strcmp(chr_lien_status, LIEN_RELFAIL_STATUS) == 0))
		{
		hvCount = 0;

		printf("Deal Date is - [%s]\n",chr_l_deal_date);
		printf("Deal Code is - [%d]\n",l_deal_cd);
		printf("Deal Class is - [%d]\n",l_deal_class);
		printf("CLH Flag is - [%s]\n",chr_l_clh_flag);
		printf("Deal Net Amount is - [%lf]",l_deal_net_amt);
		 if((l_deal_cd == 4 && l_deal_class == 1  && 
			strcmp(chr_l_clh_flag,"D")== 0 && 
			strcmp(l_mode,"RMP")==0) || 
			(l_deal_cd == 4 && l_deal_class == 1  && strcmp(l_mode,"RMH")==0))
		 {
			printf("\n Lien Markin Present for deal");
			memset(p_lien_release,APL_NULL_CHAR,sizeof(p_lien_release));
			sprintf(p_lien_release,"%sLienMarkReq.ksh %s %s %s %s %s %s %lf %s",chr_tempchar,l_client1, l_identiy_no1, chr_l_deal_date, chr_settl_no, chr_exch_cd, chr_payout_typ,l_deal_net_amt, g_combined_param);
			printf("\n p_lien_release :[%s]",p_lien_release);
			sys_retval=system(p_lien_release);
			printf("\n sys_retval :[%d]",sys_retval);	
			if(sys_retval == 0)
			{
				time(&hvPrcStrtTime);
				Alert("LienMarkReq.ksh Executed Successfully");

				sleep(hvSleepTime);
				Alert("debug ::: after mandatory sleep");

				while(1==1)
				 {
					diff_seconds = 0.0;
					hvFailRec = 0;
					hvCount1 = 0;
					time(&hvPrcEndTime);
					diff_seconds = difftime(hvPrcEndTime,hvPrcStrtTime);

					Alert("diff_seconds = |%lf|",diff_seconds);

					if(diff_seconds < hvTimeOut)
						{
							Alert("debug :: checking count of record for lien release");

							EXEC SQL select count(*) into :hvCount1 from dl_lien_his 
								where client= :l_client1 
								AND REF_NO = :l_identiy_no1 
								and status = 'RL';
							IS_ANY_ORA_ERROR
		
							if (hvCount1 > 0)
								{
										printf("\n Lien Release successful..");
										sprintf(chr_g_log_buffer,"\n LIEN RELEASED FOR CLIENT |%s| and REFERENCE |%s| SUCCESSFULLY",l_client1,l_identiy_no1);
										//fprintf(g_flogfile,"%s",chr_g_log_buffer);
										CO_ProcMonitor(l_logfile,chr_g_log_buffer, l_debug_info_ptr, NULL);
										strcpy(error,"SUCCESS");
										printf("\n error is [%s]",error);
										break;
								}
							else
								{
									Alert("debug ::: status update yet pending .. going for sleep");
									sleep(hvSleepTime);
									continue;
								}
						}
					else
						{
						Alert("Timeout occured");
						memset(error,NULL,sizeof(error));
						memset(chr_err_desc,NULL,sizeof(chr_err_desc));
						strcpy(error,"TIMEOUT");
						EXEC SQL SELECT ERR_DESC INTO :chr_err_desc FROM DL_LIEN 
							WHERE CLIENT = :l_client1
							AND REF_NO = :l_identiy_no1
							AND STATUS IN ('IN','MI','RF');

					Alert("sqlcode.sqlcode = |%d|",sqlca.sqlcode);

					sprintf(chr_g_log_buffer,"\n LIEN RELEASE FAILED FOR CLIENT |%s| and REFERENCE |%s| REASON |%s|",l_client1,l_identiy_no1,chr_err_desc);
					//fprintf(l_logfile,"%s",chr_g_log_buffer);
					CO_ProcMonitor(l_logfile,chr_g_log_buffer, l_debug_info_ptr, NULL);
					//printf("\n error is [%s]",error);
						break;
						}
				}
           		}
		   	else
		   	{
                		printf("LienMarkReq.ksh Executed UnSuccessfully");
				strcpy(error,"FAILURE");
                		continue;
		   	} 
        	}
		else
		{
			strcpy(error,"SUCCESS");
		}
		}
		else
		{
			strcpy(error,"SUCCESS");
		}
	}
	else
	{
		strcpy(error,"SUCCESS");
	}
			

			if(strcmp(l_mode,"RMP")==0)
			{
				Alert("ENTERING UPDATE OF RESET MAPPING\n");
				fflush(stdout);

				
				if(((!strcmp(error,APL_NULL_STRING)  || !strcmp(error,"SUCCESS")) && l_condition == 1) || l_condition ==0)
				{
	                           CO_ProcMonitor(l_logfile, "ENTERING UPDATE OF RESET MAPPING", l_debug_info_ptr, NULL);
				//Added by Sharanya Shenoy for Lien release on Reset Matching/mapping:end
				
				/* changes for CS0023013--start */
				/* sprintf(query,"UPDATE dl_deal set deal_stat = 'AA' ,FAILREASON_CD=NULL WHERE client = '%s' AND identiy_no = '%s'",l_client1,l_identiy_no1); */
				
				printf("before updating dl_deal with authorization status.....\n");
				
				EXEC SQL UPDATE DL_DEAL
				SET DEAL_STAT = 'AA',
				FAILREASON_CD=NULL
				WHERE CLIENT = :l_client1
				AND IDENTIY_NO = :l_identiy_no1;
				
				IS_ANY_ORA_ERROR
				
				/* CO_ProcMonitor(l_logfile, query, l_debug_info_ptr, NULL);
				EXEC SQL EXECUTE IMMEDIATE :query; */
				printf("ORA after update DL_DEAL query..... [%d]\n", sqlca.sqlcode);
				printf("after updating dl_deal with authorization status.....\n");
				/*IS_ANY_ORA_ERROR;*/
				/* updated code --end*/
				/* sprintf(query1,"UPDATE dl_deal set contract_cd = null,FAILREASON_CD=NULL WHERE client = '%s' AND identiy_no = '%s'",l_client1,l_identiy_no1);
				CO_ProcMonitor(l_logfile, query1, l_debug_info_ptr, NULL);
				EXEC SQL EXECUTE IMMEDIATE :query1; */
				printf("before updating dl_deal with contract_cd,failreason_cd.....\n");
				EXEC SQL UPDATE DL_DEAL 
				SET CONTRACT_CD = NULL,
				FAILREASON_CD=NULL 
				WHERE CLIENT = :l_client1
				AND IDENTIY_NO = :l_identiy_no1;
				IS_ANY_ORA_ERROR;
	
				printf("ORA after update DL_DEAL query1..... [%d]\n", sqlca.sqlcode);
				printf("after updating dl_deal with contract_cd,failreason_cd.....\n");
		  
				/* sprintf(query2,"UPDATE dl_bcn set dl_ref_no = null WHERE contract_cd = '%s'",l_contract_cd);
				CO_ProcMonitor(l_logfile, query2, l_debug_info_ptr, NULL);
				EXEC SQL EXECUTE IMMEDIATE :query2; */
				printf("before updating dl_bcn with dl_ref_no.....\n");
				
				EXEC SQL UPDATE DL_BCN 
				SET DL_REF_NO = NULL 
				WHERE CONTRACT_CD = :l_contract_cd;
				IS_ANY_ORA_ERROR;
		  
				printf("ORA after update DL_DEAL query2..... [%d]\n", sqlca.sqlcode);
				printf("after updating dl_bcn with dl_ref_no.....\n");

				/* sprintf(query3,"UPDATE dl_bcn set STATUS = 'AA'	WHERE contract_cd = '%s'",l_contract_cd);
				CO_ProcMonitor(l_logfile, query3, l_debug_info_ptr, NULL);
				EXEC SQL EXECUTE IMMEDIATE :query3; */
				printf("before updating dl_bcn with status authorization.....\n");
				
				EXEC SQL UPDATE DL_BCN 
				SET STATUS = 'AA'	
				WHERE CONTRACT_CD = :l_contract_cd;
				
				IS_ANY_ORA_ERROR;

				printf("ORA after update DL_DEAL query3..... [%d]\n", sqlca.sqlcode);
				printf("after updating dl_bcn with status authorization.....\n");

				/* sprintf(query4,"DELETE FROM DL_BCNMAP_RPT WHERE  DL_CLIENT = '%s' AND DL_REF_NO = '%s'",l_client1,l_identiy_no1);			
				CO_ProcMonitor(l_logfile, query4, l_debug_info_ptr, NULL);
				EXEC SQL EXECUTE IMMEDIATE :query4; */
				
				printf("before updating delete with dl_bcnmap_rpt.....\n");
				
				EXEC SQL DELETE FROM DL_BCNMAP_RPT 
				WHERE  DL_CLIENT = :l_client1 
				AND DL_REF_NO = :l_identiy_no1;
				IS_ANY_ORA_ERROR;

				printf("ORA after update DL_DEAL query4..... [%d]\n", sqlca.sqlcode);
				
				printf("after updating delete with dl_bcnmap_rpt.....\n");
				/* changes for CS0023013--end */	
				Alert("EXITING UPDATE OF RESET MAPPING\n");
				CO_ProcMonitor(l_logfile, "EXITING UPDATE OF RESET MAPPING", l_debug_info_ptr, NULL);
				fflush(stdout);
				/** Changes By Vijay Tolerance Limit Enh **/
				printf("\n *** Tolerance Limit ---|%lf|\n",l_tolerance_limit);

				EXEC SQL SELECT A.CLIENT,A.IDENTIY_NO,A.NET_AMOUNT_ORIG,A.TOLERANCE_LIMIT,B.INFO1 
						INTO :l_client:i_client,
							 :l_identiy_no:i_identiy_no,
							 :l_net_amount_orig:i_net_amount_orig,
							 :l_tolerance_limit:i_tolerance_limit,
							 :l_note1:i_note1 
						FROM DL_BCN_TOL A,DL_DEAL B WHERE A.CLIENT = :l_client1
							AND A.IDENTIY_NO=:l_identiy_no1
							AND A.CLIENT = B.CLIENT and A.IDENTIY_NO = B.IDENTIY_NO;
				Alert("ORA after Fetch of Tolerance Limit - [%d]\n", sqlca.sqlcode);

					  if(l_tolerance_limit > 0)
					  {
						EXEC SQL UPDATE DL_DEAL A 
								SET A.NET_AMT = :l_net_amount_orig,
										A.INFO1 = SUBSTR(:l_note1,1,INSTR(:l_note1,'|')-1)
								WHERE CLIENT = :l_client
									AND IDENTIY_NO = :l_identiy_no;

								IS_ANY_ORA_ERROR
   					  }

				  /*  
				  printf("Original Net Amount --|%lf|\n",l_net_amount_orig);
				  printf("Updating Net Amount to Original Value For |%s|\n",l_pkey_temp); */
			   
				  /*sprintf(query7,"DELETE FROM DL_BCN_TOL WHERE CLIENT || ';' || IDENTIY_NO = (%s)",l_pkey_temp);Commented by JC*/

				/* Added by JC - rectified query above - replaced = with IN */
				/* sprintf(query7,"DELETE FROM DL_BCN_TOL WHERE CLIENT ='%s' AND IDENTIY_NO ='%s'",l_client,l_identiy_no);
				printf("\nQUERY7 IS |%s|\n",query7);
				CO_ProcMonitor(l_logfile, query7, l_debug_info_ptr, NULL);
				EXEC SQL EXECUTE IMMEDIATE :query7; */
				/* changes for CS0023013--start */
				printf("before updating delete with dl_bcnmap_rpt 1.....\n");
				
				EXEC SQL DELETE FROM DL_BCNMAP_RPT 
				WHERE  DL_CLIENT = :l_client1 
				AND DL_REF_NO = :l_identiy_no1;
				
				IS_ANY_ORA_ERROR
				
				printf("\n SQLCA.SQLCODE For DELETING Record From DL_BCN_TOL |%d|\n ",sqlca.sqlcode);

				printf("after updating delete with dl_bcnmap_rpt 1.....\n");
				/* changes for CS0023013--end */
			}
			}
			if(strcmp(l_mode,"RMH")==0)
			{
			
				Alert("ENTERING UPDATE OF RESET MATCHING\n");
				fflush(stdout);
				if(!strcmp(error,APL_NULL_STRING) || !strcmp(error,"SUCCESS"))
				{
				CO_ProcMonitor(l_logfile, "ENTERING UPDATE OF RESET MATCHING", l_debug_info_ptr, NULL);
				sprintf(query,"UPDATE dl_deal a SET deal_stat='RC',is_matched=NULL,brokercomm=DECODE(deal_cd,'1',brokercomm+amt_differ,'3',brokercomm+amt_differ,'2',brokercomm-amt_differ,'4',brokercomm-amt_differ),amt_differ=0 WHERE  deal_stat='PM' AND client='%s' AND identiy_no = '%s'",l_client1,l_identiy_no1);
				printf("\n QUERY IS |%s|\n",query);
				CO_ProcMonitor(l_logfile, query, l_debug_info_ptr, NULL);
				EXEC SQL EXECUTE IMMEDIATE :query;
				printf("\n Error while Updating DEAL 1st |%d|\n ",sqlca.sqlcode);
				IS_ANY_ORA_ERROR

				sprintf(query1,"UPDATE dl_exchgord_upld SET status = 'AA' , deal_ref_no=NULL, matched=NULL WHERE status ='PM' AND client='%s' AND deal_ref_no ='%s'",l_client1,l_identiy_no1);	

				printf("\n QUERY1 IS |%s|\n",query1);
				CO_ProcMonitor(l_logfile, query1, l_debug_info_ptr, NULL);
				EXEC SQL EXECUTE IMMEDIATE :query1;
				printf("\n Error while Updating exchorder 1st |%d|\n ",sqlca.sqlcode);
				IS_ANY_ORA_ERROR

				/*Priyanka - MCS-SX UAT issue -to reset  NRI Clients and exchange order with master as client - start*/			
	/*EXEC SQL select cln_type,cln_master into :l_cln_typ:i_l_cln_typ,:l_cln_master:i_l_cln_master from mt_client where cln_code=:l_client1;*/
/*considering cp code will NOT be same across exchge and 2 diff client without havin master subacc relation cannot have same cp code*/
	Alert("\n PS  l_client1= %s ,chr_l_str_refno= %s ",l_client1,chr_l_str_refno);	 
 fflush(stdout);

/*ISKB_8206 : Using Exchnage Code in Reset Matching - Changes by Mrinal - Start*/
EXEC SQL SELECT EXCH_CODE INTO :l_exch_code:i_l_exch_code FROM DL_DEAL WHERE identiy_no=:l_identiy_no1 and client=:l_client1;

IS_ANY_ORA_ERROR
Alert("\n l_exch_code= %s  " ,l_exch_code);

//EXEC SQL select P.CLN_EXCH_MAP_CODE into :l_cp_code:i_l_cp_code from MT_CLI_EXCH_MAP P,dl_match_rpt R where R.deal_ref_no like '%'||:chr_l_str_refno||'%' AND R.status='PM' and R.client=P.cln_exch_map_code and R.exch_code=P.cln_exch_code and P.STATUS = 'AA'   and P.CLN_CODE=:l_client1;
	
//EXEC SQL select P.CLN_EXCH_MAP_CODE into :l_cp_code:i_l_cp_code from MT_CLI_EXCH_MAP P,dl_match_rpt R where R.deal_ref_no like '%'||:l_identiy_no1||'%' AND R.status='PM' and R.client=P.cln_exch_map_code and R.exch_code=P.cln_exch_code and P.STATUS = 'AA'   and P.CLN_CODE=:l_client1 and ROWNUM=1;

EXEC SQL select P.CLN_EXCH_MAP_CODE into :l_cp_code:i_l_cp_code from MT_CLI_EXCH_MAP P,dl_match_rpt R where R.deal_ref_no like '%'||:l_identiy_no1||'%' AND R.status='PM' and R.client=P.cln_exch_map_code and R.exch_code=P.cln_exch_code and P.STATUS = 'AA'  and P.CLN_CODE=:l_client1 and P.CLN_EXCH_CODE=:l_exch_code and ROWNUM=1;

IS_ANY_ORA_ERROR

Alert("\n PS l_cp_code= %s  ",l_cp_code);

/*ISKB_8206 : Using Exchnage Code in Reset Matching - Changes by Mrinal - End*/

EXEC SQL select count(*) into l_count from mt_cli_exch_map M where CLN_EXCH_MAP_CODE=:l_cp_code and M.STATUS = 'AA' ;
IS_ANY_ORA_ERROR

			EXEC SQL SELECT distinct DECODE(:l_count, 1, B.CLN_CODE, B.CLN_MASTER ) into :l_cli_code:i_l_cli_code FROM mt_cli_exch_map A, MT_CLIENT B where A.CLN_CODE = B.CLN_CODE  AND A.status ='AA' AND B.Status = 'AA' and B.cln_code=:l_client1;
				IS_ANY_ORA_ERROR
					Alert("\n PS l_cli_code= %s  " ,l_cli_code);

/*Priyanka - MCS-SX UAT issue -to reset  NRI Clients and exchange order with master as client  - end*/

/*ISKB_8206 : Using Exchnage Code in Reset Matching - Changes by Mrinal - Start*/

//				EXEC SQL UPDATE dl_exchgord_upld
//				SET status = 'AA' , deal_ref_no=NULL, matched=NULL
//				WHERE (client,order_no) IN
//				(SELECT b.cln_code ,a.order_no FROM dl_match_rpt a,mt_cli_exch_map b 
//					WHERE 
//					((a.client=b.cln_exch_map_code AND 
//					  A.MKT_TYPE !=  DECODE(a.exch_code,'NSE','23','BSE','18',' '))/*Priyanka - added default condition in decode for MCS*/
//					  OR
//					  (a.client=b.slb_exch_map_code AND 
//					   A.MKT_TYPE =  DECODE(a.exch_code,'NSE','23','BSE','18',' '))/*Priyanka - added default condition in decode for MCS*/
//					)
				/*AND b.cln_code=decode(:l_cln_typ,'N',:l_cln_master,:l_client1)Priyanka - MCS-SX UAT issue - added Decode for NRI Clients*/
//				AND b.cln_code=:l_cli_code /*Priyanka - MCS-SX UAT issue -to reset  NRI Clients and exchange order with master as client  - end*/
//				AND deal_ref_no like '%'||:l_identiy_no1||'%') AND status='PM';

				EXEC SQL UPDATE dl_exchgord_upld
				SET status = 'AA' , deal_ref_no=NULL, matched=NULL
				WHERE (client,order_no) IN
				(SELECT b.cln_code ,a.order_no FROM dl_match_rpt a,mt_cli_exch_map b 
					WHERE 
					((a.client=b.cln_exch_map_code AND 
					  A.MKT_TYPE !=  DECODE(a.exch_code,'NSE','23','BSE','18',' '))/*Priyanka - added default condition in decode for MCS*/
					  OR
					  (a.client=b.slb_exch_map_code AND 
					   A.MKT_TYPE =  DECODE(a.exch_code,'NSE','23','BSE','18',' '))/*Priyanka - added default condition in decode for MCS*/
					)
				/*AND b.cln_code=decode(:l_cln_typ,'N',:l_cln_master,:l_client1)Priyanka - MCS-SX UAT issue - added Decode for NRI Clients*/
				AND b.cln_code=:l_cli_code /*Priyanka - MCS-SX UAT issue -to reset  NRI Clients and exchange order with master as client  - end*/
				AND deal_ref_no like :chr_l_str_refno) AND status='PM' AND exchg_code=:l_exch_code;
				
/*ISKB_8206 : Using Exchnage Code in Reset Matching - Changes by Mrinal - End*/
				
				IS_ANY_ORA_ERROR;
	
/*ISKB_8206 : Using Exchnage Code in Reset Matching - Changes by Mrinal - Start*/
//				EXEC SQL UPDATE dl_deal 
//				SET is_matched=NULL,deal_stat='RC'
//				WHERE (client,identiy_no) IN
//				(SELECT b.cln_code ,:l_identiy_no1 FROM dl_match_rpt a,mt_cli_exch_map b
//					WHERE
//					((a.client=b.cln_exch_map_code AND 
//					A.MKT_TYPE !=  DECODE(a.exch_code,'NSE','23','BSE','18',' '))/*Priyanka - added default condition in decode for MCS*/
//					OR
//					(a.client=b.slb_exch_map_code AND 
//					A.MKT_TYPE =  DECODE(a.exch_code,'NSE','23','BSE','18',' '))
//					)
//				AND deal_ref_no like '%'||:l_identiy_no1||'%' 
//				AND b.cln_code= :l_client1 AND deal_stat='PM');
//				IS_ANY_ORA_ERROR;

				EXEC SQL UPDATE dl_deal 
				SET is_matched=NULL,deal_stat='RC'
				WHERE (client,identiy_no) IN
				(SELECT b.cln_code ,:l_identiy_no1 FROM dl_match_rpt a,mt_cli_exch_map b
					WHERE
					((a.client=b.cln_exch_map_code AND 
					A.MKT_TYPE !=  DECODE(a.exch_code,'NSE','23','BSE','18',' '))/*Priyanka - added default condition in decode for MCS*/
					OR
					(a.client=b.slb_exch_map_code AND 
					A.MKT_TYPE =  DECODE(a.exch_code,'NSE','23','BSE','18',' '))
					)
				AND deal_ref_no like '%'||:l_identiy_no1||'%' 
				AND b.cln_code= :l_client1 AND deal_stat='PM') AND exch_code=:l_exch_code;
				IS_ANY_ORA_ERROR;
				
/*ISKB_8206 : Using Exchnage Code in Reset Matching - Changes by Mrinal - End*/				
				Alert("EXITING UPDATE OF RESET MATCHING\n");
				CO_ProcMonitor(l_logfile, "EXITING UPDATE OF RESET MATCHING", l_debug_info_ptr, NULL);
				fflush(stdout);
			}
		}
                }
		EXEC SQL INSERT INTO GN_BATCH_INTERMEDIATE_ARCH
	    SELECT * FROM GN_BATCH_INTERMEDIATE WHERE SEQ_NO = :l_seq_no;
		printf("ORA for insert into GN_BATCH_INTERMEDIATE_ARCH - [%d]\n", sqlca.sqlcode);
		IS_ANY_ORA_ERROR;

		EXEC SQL DELETE FROM GN_BATCH_INTERMEDIATE WHERE SEQ_NO = :l_seq_no;
		printf("ORA for delete from GN_BATCH_INTERMEDIATE - [%d]\n", sqlca.sqlcode);
		IS_ANY_ORA_ERROR;
	}
	/* Added By Gouse for Reset Map Match - ISKB_5999 - End */
 /*
	if(strcmp(l_mode,"REL")==0)
	{
		printf("ENTERING UPDATE OF REL\n");
		sprintf(query1,"UPDATE dl_deal set deal_stat = 'CS' 	WHERE client||';'||identiy_no	in(%s)",l_pkey_temp);
		EXEC SQL EXECUTE IMMEDIATE :query1;
		printf("\n Failed updating OF DEAL STATUS TO CS  |%d|\n ",sqlca.sqlcode);
		IS_ANY_ORA_ERROR
	}
*/
	
	RETURN_SUCCESS :
		CO_ProcMonitor(l_logfile, "SUCESS IN MAIN", l_debug_info_ptr, NULL);

	if(BT_Status_Completed(argv[0],
				argv[1],
				argv[2],
				l_debug_info_ptr)   ==  APL_FAILURE )
	{
		APL_GOBACK_FAIL
	}


	CO_Proc_RptClose(l_logfile, l_debug_info_ptr);

	

	EXEC SQL COMMIT WORK;
	

	if(sqlca.sqlcode != 0)APL_GOBACK_FAIL
		exit(0);

	RETURN_FAILURE    :
	/*CO_Proc_RptClose(l_logfile, l_debug_info_ptr);
	CO_ProcMonitor(l_logfile, "Failure in prog", l_debug_info_ptr, NULL);*///AIX Warning Removal

	exit(APL_FAILURE);
		 
}
